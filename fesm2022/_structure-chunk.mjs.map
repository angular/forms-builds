{"version":3,"file":"_structure-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/compat/validation_errors.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/resolution.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/util.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/util/type_guards.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/schema/logic.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/schema/logic_node.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/schema/path_node.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/schema/schema.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/metadata.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/validation.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/debounce.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/context.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/metadata.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/proxy.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/util/deep_signal.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/structure.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/submit.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/node.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/state.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/field_adapter.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/manager.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/util/normalize_form_args.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/structure.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {AbstractControl, FormArray, FormGroup, ValidationErrors} from '@angular/forms';\nimport {ValidationError} from '../api/rules';\nimport {FieldTree} from '../api/types';\n\n/**\n * An error used for compat errors.\n *\n * @experimental 21.0.0\n * @category interop\n */\nexport class CompatValidationError<T = unknown> implements ValidationError {\n  readonly kind: string = 'compat';\n  readonly control: AbstractControl;\n  readonly fieldTree!: FieldTree<unknown>;\n  readonly context: T;\n  readonly message?: string;\n\n  constructor({context, kind, control}: {context: T; kind: string; control: AbstractControl}) {\n    this.context = context;\n    this.kind = kind;\n    this.control = control;\n  }\n}\n\n/**\n * Converts signal forms validation errors to reactive forms ValidationErrors.\n *\n * @experimental 21.0.0\n */\nexport function signalErrorsToValidationErrors(errors: ValidationError[]): ValidationErrors | null {\n  if (errors.length === 0) {\n    return null;\n  }\n  const errObj: ValidationErrors = {};\n  for (const error of errors) {\n    errObj[error.kind] = error instanceof CompatValidationError ? error.context : error;\n  }\n  return errObj;\n}\n\n/**\n * Converts reactive form validation error to signal forms CompatValidationError.\n * @param errors\n * @param control\n * @return list of errors.\n */\nexport function reactiveErrorsToSignalErrors(\n  errors: ValidationErrors | null,\n  control: AbstractControl,\n): CompatValidationError[] {\n  if (errors === null) {\n    return [];\n  }\n\n  return Object.entries(errors).map(([kind, context]) => {\n    return new CompatValidationError({context, kind, control});\n  });\n}\n\n/**\n * Extracts all reactive errors from a control and its children.\n * @param control\n * @return list of errors.\n */\nexport function extractNestedReactiveErrors(control: AbstractControl): CompatValidationError[] {\n  const errors: CompatValidationError[] = [];\n\n  if (control.errors) {\n    errors.push(...reactiveErrorsToSignalErrors(control.errors, control));\n  }\n\n  if (control instanceof FormGroup || control instanceof FormArray) {\n    for (const c of Object.values(control.controls)) {\n      errors.push(...extractNestedReactiveErrors(c));\n    }\n  }\n\n  return errors;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nlet boundPathDepth = 0;\n\n/**\n * The depth of the current path when evaluating a logic function.\n * Do not set this directly, it is a context variable managed by `setBoundPathDepthForResolution`.\n */\nexport function getBoundPathDepth() {\n  return boundPathDepth;\n}\n\n/**\n * Sets the bound path depth for the duration of the given logic function.\n * This is used to ensure that the field resolution algorithm walks far enough up the field tree to\n * reach the point where the root of the path we're bound to is applied. This normally isn't a big\n * concern, but matters when we're dealing with recursive structures.\n *\n * Consider this example:\n *\n * ```ts\n * const s = schema(p => {\n *   disabled(p.next, ({valueOf}) => valueOf(p.data));\n *   apply(p.next, s);\n * });\n * ```\n *\n * Here we need to know that the `disabled` logic was bound to a path of depth 1. Otherwise we'd\n * attempt to resolve `p.data` in the context of the field corresponding to `p.next`.\n * The resolution algorithm would start with the field for `p.next` and see that it *does* contain\n * the logic for `s` (due to the fact that its recursively applied.) It would then decide not to\n * walk up the field tree at all, and to immediately start walking down the keys for the target path\n * `p.data`, leading it to grab the field corresponding to `p.next.data`.\n *\n * We avoid the problem described above by keeping track of the depth (relative to Schema root) of\n * the path we were bound to. We then require the resolution algorithm to walk at least that far up\n * the tree before finding a node that contains the logic for `s`.\n *\n * @param fn A logic function that is bound to a particular path\n * @param depth The depth in the field tree of the field the logic is bound to\n * @returns A version of the logic function that is aware of its depth.\n */\nexport function setBoundPathDepthForResolution<A extends any[], R>(\n  fn: (...args: A) => R,\n  depth: number,\n): (...args: A) => R {\n  return (...args: A) => {\n    try {\n      boundPathDepth = depth;\n      return fn(...args);\n    } finally {\n      boundPathDepth = 0;\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {FieldNodeOptions} from './structure';\n\n/** A shortCircuit function for reduceChildren that short-circuits if the value is false. */\nexport function shortCircuitFalse(value: boolean): boolean {\n  return !value;\n}\n\n/** A shortCircuit function for reduceChildren that short-circuits if the value is true. */\nexport function shortCircuitTrue(value: boolean): boolean {\n  return value;\n}\n\n/** Recasts the given value as a new type. */\nexport function cast<T>(value: unknown): asserts value is T {}\n\n/**\n * A helper method allowing to get injector regardless of the options type.\n * @param options\n */\nexport function getInjectorFromOptions(options: FieldNodeOptions) {\n  if (options.kind === 'root') {\n    return options.fieldManager.injector;\n  }\n\n  return options.parent.structure.root.structure.injector;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * A version of `Array.isArray` that handles narrowing of readonly arrays properly.\n */\nexport function isArray(value: unknown): value is any[] | readonly any[] {\n  return Array.isArray(value);\n}\n\n/**\n * Checks if a value is an object.\n */\nexport function isObject(value: unknown): value is Record<PropertyKey, unknown> {\n  return (typeof value === 'object' || typeof value === 'function') && value != null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {untracked} from '@angular/core';\nimport type {MetadataKey} from '../api/rules/metadata';\nimport type {ValidationError} from '../api/rules/validation/validation_errors';\nimport {DisabledReason, type FieldContext, type LogicFn, type SchemaPath} from '../api/types';\nimport type {FieldNode} from '../field/node';\nimport {cast} from '../field/util';\nimport {isArray} from '../util/type_guards';\n\n/**\n * Special key which is used to represent a dynamic logic property in a `FieldPathNode` path.\n * This property is used to represent logic that applies to every element of some dynamic form data\n * (i.e. an array).\n *\n * For example, a rule like `applyEach(p.myArray, () => { ... })` will add logic to the `DYNAMIC`\n * property of `p.myArray`.\n */\nexport const DYNAMIC: unique symbol = Symbol();\n\n/** Represents a result that should be ignored because its predicate indicates it is not active. */\nconst IGNORED = Symbol();\n\n/**\n * A predicate that indicates whether an `AbstractLogic` instance is currently active, or should be\n * ignored.\n */\nexport interface Predicate {\n  /** A boolean logic function that returns true if the logic is considered active. */\n  readonly fn: LogicFn<any, boolean>;\n  /**\n   * The path which this predicate was created for. This is used to determine the correct\n   * `FieldContext` to pass to the predicate function.\n   */\n  readonly path: SchemaPath<any>;\n}\n\n/**\n * Represents a predicate that is bound to a particular depth in the field tree. This is needed for\n * recursively applied logic to ensure that the predicate is evaluated against the correct\n * application of that logic.\n *\n * Consider the following example:\n *\n * ```ts\n * const s = schema(p => {\n *   disabled(p.data);\n *   applyWhen(p.next, ({valueOf}) => valueOf(p.data) === 1, s);\n * });\n *\n * const f = form(signal({data: 0, next: {data: 1, next: {data: 2, next: undefined}}}), s);\n *\n * const isDisabled = f.next.next.data().disabled();\n * ```\n *\n * In order to determine `isDisabled` we need to evaluate the predicate from `applyWhen` *twice*.\n * Once to see if the schema should be applied to `f.next` and again to see if it should be applied\n * to `f.next.next`. The `depth` tells us which field we should be evaluating against each time.\n */\nexport interface BoundPredicate extends Predicate {\n  /** The depth in the field tree at which this predicate is bound. */\n  readonly depth: number;\n}\n\n/**\n * Base class for all logic. It is responsible for combining the results from multiple individual\n * logic functions registered in the schema, and using them to derive the value for some associated\n * piece of field state.\n */\nexport abstract class AbstractLogic<TReturn, TValue = TReturn> {\n  /** The set of logic functions that contribute to the value of the associated state. */\n  protected readonly fns: Array<LogicFn<any, TValue | typeof IGNORED>> = [];\n\n  constructor(\n    /**\n     * A list of predicates that conditionally enable all logic in this logic instance.\n     * The logic is only enabled when *all* of the predicates evaluate to true.\n     */\n    private predicates: ReadonlyArray<BoundPredicate>,\n  ) {}\n\n  /**\n   * Computes the value of the associated field state based on the logic functions and predicates\n   * registered with this logic instance.\n   */\n  abstract compute(arg: FieldContext<any>): TReturn;\n\n  /**\n   * The default value that the associated field state should assume if there are no logic functions\n   * registered by the schema (or if the logic is disabled by a predicate).\n   */\n  abstract get defaultValue(): TReturn;\n\n  /** Registers a logic function with this logic instance. */\n  push(logicFn: LogicFn<any, TValue>) {\n    this.fns.push(wrapWithPredicates(this.predicates, logicFn));\n  }\n\n  /**\n   * Merges in the logic from another logic instance, subject to the predicates of both the other\n   * instance and this instance.\n   */\n  mergeIn(other: AbstractLogic<TReturn, TValue>) {\n    const fns = this.predicates\n      ? other.fns.map((fn) => wrapWithPredicates(this.predicates, fn))\n      : other.fns;\n    this.fns.push(...fns);\n  }\n}\n\n/** Logic that combines its individual logic function results with logical OR. */\nexport class BooleanOrLogic extends AbstractLogic<boolean> {\n  override get defaultValue() {\n    return false;\n  }\n\n  override compute(arg: FieldContext<any>): boolean {\n    return this.fns.some((f) => {\n      const result = f(arg);\n      return result && result !== IGNORED;\n    });\n  }\n}\n\n/**\n * Logic that combines its individual logic function results by aggregating them in an array.\n * Depending on its `ignore` function it may ignore certain values, omitting them from the array.\n */\nexport class ArrayMergeIgnoreLogic<TElement, TIgnore = never> extends AbstractLogic<\n  readonly TElement[],\n  TElement | readonly (TElement | TIgnore)[] | TIgnore | undefined | void\n> {\n  /** Creates an instance of this class that ignores `null` values. */\n  static ignoreNull<TElement>(predicates: ReadonlyArray<BoundPredicate>) {\n    return new ArrayMergeIgnoreLogic<TElement, null>(predicates, (e: unknown) => e === null);\n  }\n\n  constructor(\n    predicates: ReadonlyArray<BoundPredicate>,\n    private ignore: undefined | ((e: TElement | undefined | TIgnore) => e is TIgnore),\n  ) {\n    super(predicates);\n  }\n\n  override get defaultValue() {\n    return [];\n  }\n\n  override compute(arg: FieldContext<any>): readonly TElement[] {\n    return this.fns.reduce((prev, f) => {\n      const value = f(arg);\n\n      if (value === undefined || value === IGNORED) {\n        return prev;\n      } else if (isArray(value)) {\n        return [...prev, ...(this.ignore ? value.filter((e) => !this.ignore!(e)) : value)];\n      } else {\n        if (this.ignore && this.ignore(value as TElement | TIgnore | undefined)) {\n          return prev;\n        }\n        return [...prev, value];\n      }\n    }, [] as TElement[]);\n  }\n}\n\n/** Logic that combines its individual logic function results by aggregating them in an array. */\nexport class ArrayMergeLogic<TElement> extends ArrayMergeIgnoreLogic<TElement, never> {\n  constructor(predicates: ReadonlyArray<BoundPredicate>) {\n    super(predicates, undefined);\n  }\n}\n\n/** Logic that combines metadata according to the keys's reduce function. */\nexport class MetadataMergeLogic<TAcc, TItem> extends AbstractLogic<TAcc, TItem> {\n  override get defaultValue() {\n    return this.key.reducer.getInitial();\n  }\n\n  constructor(\n    predicates: ReadonlyArray<BoundPredicate>,\n    private key: MetadataKey<any, TItem, TAcc>,\n  ) {\n    super(predicates);\n  }\n\n  override compute(ctx: FieldContext<any>): TAcc {\n    if (this.fns.length === 0) {\n      return this.key.reducer.getInitial();\n    }\n    let acc: TAcc = this.key.reducer.getInitial();\n    for (let i = 0; i < this.fns.length; i++) {\n      const item = this.fns[i](ctx);\n      if (item !== IGNORED) {\n        acc = this.key.reducer.reduce(acc, item);\n      }\n    }\n    return acc;\n  }\n}\n\n/**\n * Wraps a logic function such that it returns the special `IGNORED` sentinel value if any of the\n * given predicates evaluates to false.\n *\n * @param predicates A list of bound predicates to apply to the logic function\n * @param logicFn The logic function to wrap\n * @returns A wrapped version of the logic function that may return `IGNORED`.\n */\nfunction wrapWithPredicates<TValue, TReturn>(\n  predicates: ReadonlyArray<BoundPredicate>,\n  logicFn: LogicFn<TValue, TReturn>,\n): LogicFn<TValue, TReturn | typeof IGNORED> {\n  if (predicates.length === 0) {\n    return logicFn;\n  }\n  return (arg: FieldContext<any>): TReturn | typeof IGNORED => {\n    for (const predicate of predicates) {\n      let predicateField = arg.stateOf(predicate.path) as FieldNode;\n      // Check the depth of the current field vs the depth this predicate is supposed to be\n      // evaluated at. If necessary, walk up the field tree to grab the correct context field.\n      // We can check the pathKeys as an untracked read since we know the structure of our fields\n      // doesn't change.\n      const depthDiff = untracked(predicateField.structure.pathKeys).length - predicate.depth;\n      for (let i = 0; i < depthDiff; i++) {\n        predicateField = predicateField.structure.parent!;\n      }\n      // If any of the predicates don't match, don't actually run the logic function, just return\n      // the default value.\n      if (!predicate.fn(predicateField.context)) {\n        return IGNORED;\n      }\n    }\n    return logicFn(arg);\n  };\n}\n\n/**\n * Container for all the different types of logic that can be applied to a field\n * (disabled, hidden, errors, etc.)\n */\n\nexport class LogicContainer {\n  /** Logic that determines if the field is hidden. */\n  readonly hidden: BooleanOrLogic;\n  /** Logic that determines reasons for the field being disabled. */\n  readonly disabledReasons: ArrayMergeLogic<DisabledReason>;\n  /** Logic that determines if the field is read-only. */\n  readonly readonly: BooleanOrLogic;\n  /** Logic that produces synchronous validation errors for the field. */\n  readonly syncErrors: ArrayMergeIgnoreLogic<ValidationError.WithFieldTree, null>;\n  /** Logic that produces synchronous validation errors for the field's subtree. */\n  readonly syncTreeErrors: ArrayMergeIgnoreLogic<ValidationError.WithFieldTree, null>;\n  /** Logic that produces asynchronous validation results (errors or 'pending'). */\n  readonly asyncErrors: ArrayMergeIgnoreLogic<ValidationError.WithFieldTree | 'pending', null>;\n  /** A map of metadata keys to the `AbstractLogic` instances that compute their values. */\n  private readonly metadata = new Map<\n    MetadataKey<unknown, unknown, unknown>,\n    AbstractLogic<unknown>\n  >();\n\n  /**\n   * Constructs a new `Logic` container.\n   * @param predicates An array of predicates that must all be true for the logic\n   *   functions within this container to be active.\n   */\n  constructor(private predicates: ReadonlyArray<BoundPredicate>) {\n    this.hidden = new BooleanOrLogic(predicates);\n    this.disabledReasons = new ArrayMergeLogic(predicates);\n    this.readonly = new BooleanOrLogic(predicates);\n    this.syncErrors = ArrayMergeIgnoreLogic.ignoreNull<ValidationError.WithFieldTree>(predicates);\n    this.syncTreeErrors =\n      ArrayMergeIgnoreLogic.ignoreNull<ValidationError.WithFieldTree>(predicates);\n    this.asyncErrors = ArrayMergeIgnoreLogic.ignoreNull<ValidationError.WithFieldTree | 'pending'>(\n      predicates,\n    );\n  }\n\n  /** Checks whether there is logic for the given metadata key. */\n  hasMetadata(key: MetadataKey<any, any, any>) {\n    return this.metadata.has(key);\n  }\n\n  /**\n   * Gets an iterable of [metadata key, logic function] pairs.\n   * @returns An iterable of metadata keys.\n   */\n  getMetadataKeys() {\n    return this.metadata.keys();\n  }\n\n  /**\n   * Retrieves or creates the `AbstractLogic` for a given metadata key.\n   * @param key The `MetadataKey` for which to get the logic.\n   * @returns The `AbstractLogic` associated with the key.\n   */\n  getMetadata<T>(key: MetadataKey<any, T, any>): AbstractLogic<T> {\n    cast<MetadataKey<unknown, unknown, unknown>>(key);\n    if (!this.metadata.has(key)) {\n      this.metadata.set(key, new MetadataMergeLogic(this.predicates, key));\n    }\n    return this.metadata.get(key)! as AbstractLogic<T>;\n  }\n\n  /**\n   * Merges logic from another `Logic` instance into this one.\n   * @param other The `Logic` instance to merge from.\n   */\n  mergeIn(other: LogicContainer) {\n    this.hidden.mergeIn(other.hidden);\n    this.disabledReasons.mergeIn(other.disabledReasons);\n    this.readonly.mergeIn(other.readonly);\n    this.syncErrors.mergeIn(other.syncErrors);\n    this.syncTreeErrors.mergeIn(other.syncTreeErrors);\n    this.asyncErrors.mergeIn(other.asyncErrors);\n    for (const key of other.getMetadataKeys()) {\n      const metadataLogic = other.metadata.get(key)!;\n      this.getMetadata(key).mergeIn(metadataLogic);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {RuntimeErrorCode} from '../errors';\n\nimport type {MetadataKey, ValidationError} from '../api/rules';\nimport type {AsyncValidationResult, DisabledReason, LogicFn, ValidationResult} from '../api/types';\nimport {setBoundPathDepthForResolution} from '../field/resolution';\nimport {type BoundPredicate, DYNAMIC, LogicContainer, type Predicate} from './logic';\n\n/**\n * Abstract base class for building a `LogicNode`.\n * This class defines the interface for adding various logic rules (e.g., hidden, disabled)\n * and data factories to a node in the logic tree.\n * LogicNodeBuilders are 1:1 with nodes in the Schema tree.\n */\nexport abstract class AbstractLogicNodeBuilder {\n  constructor(\n    /** The depth of this node in the schema tree. */\n    protected readonly depth: number,\n  ) {}\n\n  /** Adds a rule to determine if a field should be hidden. */\n  abstract addHiddenRule(logic: LogicFn<any, boolean>): void;\n\n  /** Adds a rule to determine if a field should be disabled, and for what reason. */\n  abstract addDisabledReasonRule(logic: LogicFn<any, DisabledReason | undefined>): void;\n\n  /** Adds a rule to determine if a field should be read-only. */\n  abstract addReadonlyRule(logic: LogicFn<any, boolean>): void;\n\n  /** Adds a rule for synchronous validation errors for a field. */\n  abstract addSyncErrorRule(logic: LogicFn<any, ValidationResult>): void;\n\n  /** Adds a rule for synchronous validation errors that apply to a subtree. */\n  abstract addSyncTreeErrorRule(logic: LogicFn<any, ValidationResult>): void;\n\n  /** Adds a rule for asynchronous validation errors for a field. */\n  abstract addAsyncErrorRule(logic: LogicFn<any, AsyncValidationResult>): void;\n\n  /** Adds a rule to compute metadata for a field. */\n  abstract addMetadataRule<M>(key: MetadataKey<unknown, M, unknown>, logic: LogicFn<any, M>): void;\n\n  /**\n   * Gets a builder for a child node associated with the given property key.\n   * @param key The property key of the child.\n   * @returns A `LogicNodeBuilder` for the child.\n   */\n  abstract getChild(key: PropertyKey): LogicNodeBuilder;\n\n  /**\n   * Checks whether a particular `AbstractLogicNodeBuilder` has been merged into this one.\n   * @param builder The builder to check for.\n   * @returns True if the builder has been merged, false otherwise.\n   */\n  abstract hasLogic(builder: AbstractLogicNodeBuilder): boolean;\n\n  /**\n   * Builds the `LogicNode` from the accumulated rules and child builders.\n   * @returns The constructed `LogicNode`.\n   */\n  build(): LogicNode {\n    return new LeafLogicNode(this, [], 0);\n  }\n}\n\n/**\n * A builder for `LogicNode`. Used to add logic to the final `LogicNode` tree.\n * This builder supports merging multiple sources of logic, potentially with predicates,\n * preserving the order of rule application.\n */\nexport class LogicNodeBuilder extends AbstractLogicNodeBuilder {\n  constructor(depth: number) {\n    super(depth);\n  }\n\n  /**\n   * The current `NonMergeableLogicNodeBuilder` being used to add rules directly to this\n   * `LogicNodeBuilder`. Do not use this directly, call `getCurrent()` which will create a current\n   * builder if there is none.\n   */\n  private current: NonMergeableLogicNodeBuilder | undefined;\n  /**\n   * Stores all builders that contribute to this node, along with any predicates\n   * that gate their application.\n   */\n  readonly all: {builder: AbstractLogicNodeBuilder; predicate?: Predicate}[] = [];\n\n  override addHiddenRule(logic: LogicFn<any, boolean>): void {\n    this.getCurrent().addHiddenRule(logic);\n  }\n\n  override addDisabledReasonRule(logic: LogicFn<any, DisabledReason | undefined>): void {\n    this.getCurrent().addDisabledReasonRule(logic);\n  }\n\n  override addReadonlyRule(logic: LogicFn<any, boolean>): void {\n    this.getCurrent().addReadonlyRule(logic);\n  }\n\n  override addSyncErrorRule(\n    logic: LogicFn<any, ValidationResult<ValidationError.WithFieldTree>>,\n  ): void {\n    this.getCurrent().addSyncErrorRule(logic);\n  }\n\n  override addSyncTreeErrorRule(\n    logic: LogicFn<any, ValidationResult<ValidationError.WithFieldTree>>,\n  ): void {\n    this.getCurrent().addSyncTreeErrorRule(logic);\n  }\n\n  override addAsyncErrorRule(\n    logic: LogicFn<any, AsyncValidationResult<ValidationError.WithFieldTree>>,\n  ): void {\n    this.getCurrent().addAsyncErrorRule(logic);\n  }\n\n  override addMetadataRule<T>(key: MetadataKey<unknown, T, any>, logic: LogicFn<any, T>): void {\n    this.getCurrent().addMetadataRule(key, logic);\n  }\n\n  override getChild(key: PropertyKey): LogicNodeBuilder {\n    // Close off the current builder if the key is DYNAMIC and the current builder already has logic\n    // for some non-DYNAMIC key. This guarantees that all of the DYNAMIC logic always comes before\n    // all of the specific-key logic for any given instance of `NonMergeableLogicNodeBuilder`.\n    // We rely on this fact in `getAllChildBuilder` to know that we can return the DYNAMIC logic,\n    // followed by the property-specific logic, in that order.\n    if (key === DYNAMIC) {\n      const children = this.getCurrent().children;\n      // Use the children size to determine if there is logic registered for a property other than\n      // the DYNAMIC property.\n      // - If the children map doesn't have DYNAMIC logic, but the size is still >0 then we know it\n      //   has logic for some other property.\n      // - If the children map does have DYNAMIC logic then its size is going to be at least 1,\n      //   because it has the DYNAMIC key. However if it is >1, then we again know it contains other\n      //   keys.\n      if (children.size > (children.has(DYNAMIC) ? 1 : 0)) {\n        this.current = undefined;\n      }\n    }\n    return this.getCurrent().getChild(key);\n  }\n\n  override hasLogic(builder: AbstractLogicNodeBuilder): boolean {\n    if (this === builder) {\n      return true;\n    }\n    return this.all.some(({builder: subBuilder}) => subBuilder.hasLogic(builder));\n  }\n\n  /**\n   * Merges logic from another `LogicNodeBuilder` into this one.\n   * If a `predicate` is provided, all logic from the `other` builder will only apply\n   * when the predicate evaluates to true.\n   * @param other The `LogicNodeBuilder` to merge in.\n   * @param predicate An optional predicate to gate the merged logic.\n   */\n  mergeIn(other: LogicNodeBuilder, predicate?: Predicate): void {\n    // Add the other builder to our collection, we'll defer the actual merging of the logic until\n    // the logic node is requested to be created. In order to preserve the original ordering of the\n    // rules, we close off the current builder to any further edits. If additional logic is added,\n    // a new current builder will be created to capture it.\n    if (predicate) {\n      this.all.push({\n        builder: other,\n        predicate: {\n          fn: setBoundPathDepthForResolution(predicate.fn, this.depth),\n          path: predicate.path,\n        },\n      });\n    } else {\n      this.all.push({builder: other});\n    }\n    this.current = undefined;\n  }\n\n  /**\n   * Gets the current `NonMergeableLogicNodeBuilder` for adding rules directly to this\n   * `LogicNodeBuilder`. If no current builder exists, a new one is created.\n   * The current builder is cleared whenever `mergeIn` is called to preserve the order\n   * of rules when merging separate builder trees.\n   * @returns The current `NonMergeableLogicNodeBuilder`.\n   */\n  private getCurrent(): NonMergeableLogicNodeBuilder {\n    if (this.current === undefined) {\n      this.current = new NonMergeableLogicNodeBuilder(this.depth);\n      this.all.push({builder: this.current});\n    }\n    return this.current;\n  }\n\n  /**\n   * Creates a new root `LogicNodeBuilder`.\n   * @returns A new instance of `LogicNodeBuilder`.\n   */\n  static newRoot(): LogicNodeBuilder {\n    return new LogicNodeBuilder(0);\n  }\n}\n\n/**\n * A type of `AbstractLogicNodeBuilder` used internally by the `LogicNodeBuilder` to record \"pure\"\n * chunks of logic that do not require merging in other builders.\n */\nclass NonMergeableLogicNodeBuilder extends AbstractLogicNodeBuilder {\n  /** The collection of logic rules directly added to this builder. */\n  readonly logic = new LogicContainer([]);\n  /**\n   * A map of child property keys to their corresponding `LogicNodeBuilder` instances.\n   * This allows for building a tree of logic.\n   */\n  readonly children = new Map<PropertyKey, LogicNodeBuilder>();\n\n  constructor(depth: number) {\n    super(depth);\n  }\n\n  override addHiddenRule(logic: LogicFn<any, boolean>): void {\n    this.logic.hidden.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addDisabledReasonRule(logic: LogicFn<any, DisabledReason | undefined>): void {\n    this.logic.disabledReasons.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addReadonlyRule(logic: LogicFn<any, boolean>): void {\n    this.logic.readonly.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addSyncErrorRule(\n    logic: LogicFn<any, ValidationResult<ValidationError.WithFieldTree>>,\n  ): void {\n    this.logic.syncErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addSyncTreeErrorRule(\n    logic: LogicFn<any, ValidationResult<ValidationError.WithFieldTree>>,\n  ): void {\n    this.logic.syncTreeErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addAsyncErrorRule(\n    logic: LogicFn<any, AsyncValidationResult<ValidationError.WithFieldTree>>,\n  ): void {\n    this.logic.asyncErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addMetadataRule<T>(key: MetadataKey<unknown, T, unknown>, logic: LogicFn<any, T>): void {\n    this.logic.getMetadata(key).push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override getChild(key: PropertyKey): LogicNodeBuilder {\n    if (!this.children.has(key)) {\n      this.children.set(key, new LogicNodeBuilder(this.depth + 1));\n    }\n    return this.children.get(key)!;\n  }\n\n  override hasLogic(builder: AbstractLogicNodeBuilder): boolean {\n    return this === builder;\n  }\n}\n\n/**\n * Represents a node in the logic tree, containing all logic applicable\n * to a specific field or path in the form structure.\n * LogicNodes are 1:1 with nodes in the Field tree.\n */\nexport interface LogicNode {\n  /** The collection of logic rules (hidden, disabled, errors, etc.) for this node. */\n  readonly logic: LogicContainer;\n\n  /**\n   * Retrieves the `LogicNode` for a child identified by the given property key.\n   * @param key The property key of the child.\n   * @returns The `LogicNode` for the specified child.\n   */\n  getChild(key: PropertyKey): LogicNode;\n\n  /**\n   * Checks whether the logic from a particular `AbstractLogicNodeBuilder` has been merged into this\n   * node.\n   * @param builder The builder to check for.\n   * @returns True if the builder has been merged, false otherwise.\n   */\n  hasLogic(builder: AbstractLogicNodeBuilder): boolean;\n}\n\n/**\n * A tree structure of `Logic` corresponding to a tree of fields.\n * This implementation represents a leaf in the sense that its logic is derived\n * from a single builder.\n */\nclass LeafLogicNode implements LogicNode {\n  /** The computed logic for this node. */\n  readonly logic: LogicContainer;\n\n  /**\n   * Constructs a `LeafLogicNode`.\n   * @param builder The `AbstractLogicNodeBuilder` from which to derive the logic.\n   *   If undefined, an empty `Logic` instance is created.\n   * @param predicates An array of predicates that gate the logic from the builder.\n   */\n  constructor(\n    private builder: AbstractLogicNodeBuilder | undefined,\n    private predicates: BoundPredicate[],\n    /** The depth of this node in the field tree. */\n    private depth: number,\n  ) {\n    this.logic = builder ? createLogic(builder, predicates, depth) : new LogicContainer([]);\n  }\n\n  // TODO: cache here, or just rely on the user of this API to do caching?\n  /**\n   * Retrieves the `LogicNode` for a child identified by the given property key.\n   * @param key The property key of the child.\n   * @returns The `LogicNode` for the specified child.\n   */\n  getChild(key: PropertyKey): LogicNode {\n    // The logic for a particular child may be spread across multiple builders. We lazily combine\n    // this logic at the time the child logic node is requested to be created.\n    const childBuilders = this.builder ? getAllChildBuilders(this.builder, key) : [];\n    if (childBuilders.length === 0) {\n      return new LeafLogicNode(undefined, [], this.depth + 1);\n    } else if (childBuilders.length === 1) {\n      const {builder, predicates} = childBuilders[0];\n      return new LeafLogicNode(\n        builder,\n        [...this.predicates, ...predicates.map((p) => bindLevel(p, this.depth))],\n        this.depth + 1,\n      );\n    } else {\n      const builtNodes = childBuilders.map(\n        ({builder, predicates}) =>\n          new LeafLogicNode(\n            builder,\n            [...this.predicates, ...predicates.map((p) => bindLevel(p, this.depth))],\n            this.depth + 1,\n          ),\n      );\n      return new CompositeLogicNode(builtNodes);\n    }\n  }\n\n  /**\n   * Checks whether the logic from a particular `AbstractLogicNodeBuilder` has been merged into this\n   * node.\n   * @param builder The builder to check for.\n   * @returns True if the builder has been merged, false otherwise.\n   */\n  hasLogic(builder: AbstractLogicNodeBuilder): boolean {\n    return this.builder?.hasLogic(builder) ?? false;\n  }\n}\n\n/**\n * A `LogicNode` that represents the composition of multiple `LogicNode` instances.\n * This is used when logic for a particular path is contributed by several distinct\n * builder branches that need to be merged.\n */\nclass CompositeLogicNode implements LogicNode {\n  /** The merged logic from all composed nodes. */\n  readonly logic: LogicContainer;\n\n  /**\n   * Constructs a `CompositeLogicNode`.\n   * @param all An array of `LogicNode` instances to compose.\n   */\n  constructor(private all: LogicNode[]) {\n    this.logic = new LogicContainer([]);\n    for (const node of all) {\n      this.logic.mergeIn(node.logic);\n    }\n  }\n\n  /**\n   * Retrieves the child `LogicNode` by composing the results of `getChild` from all\n   * underlying `LogicNode` instances.\n   * @param key The property key of the child.\n   * @returns A `CompositeLogicNode` representing the composed child.\n   */\n  getChild(key: PropertyKey): LogicNode {\n    return new CompositeLogicNode(this.all.flatMap((child) => child.getChild(key)));\n  }\n\n  /**\n   * Checks whether the logic from a particular `AbstractLogicNodeBuilder` has been merged into this\n   * node.\n   * @param builder The builder to check for.\n   * @returns True if the builder has been merged, false otherwise.\n   */\n  hasLogic(builder: AbstractLogicNodeBuilder): boolean {\n    return this.all.some((node) => node.hasLogic(builder));\n  }\n}\n\n/**\n * Gets all of the builders that contribute logic to the given child of the parent builder.\n * This function recursively traverses the builder hierarchy.\n * @param builder The parent `AbstractLogicNodeBuilder`.\n * @param key The property key of the child.\n * @returns An array of objects, each containing a `LogicNodeBuilder` for the child and any associated predicates.\n */\nfunction getAllChildBuilders(\n  builder: AbstractLogicNodeBuilder,\n  key: PropertyKey,\n): {builder: LogicNodeBuilder; predicates: Predicate[]}[] {\n  if (builder instanceof LogicNodeBuilder) {\n    return builder.all.flatMap(({builder, predicate}) => {\n      const children = getAllChildBuilders(builder, key);\n      if (predicate) {\n        return children.map(({builder, predicates}) => ({\n          builder,\n          predicates: [...predicates, predicate],\n        }));\n      }\n      return children;\n    });\n  } else if (builder instanceof NonMergeableLogicNodeBuilder) {\n    return [\n      // DYNAMIC logic always comes first for any individual `NonMergeableLogicNodeBuilder`.\n      // This assumption is guaranteed by the behavior of `LogicNodeBuilder.getChild`.\n      // Therefore we can return all of the DYNAMIC logic, followed by all of the property-specific\n      // logic.\n      ...(key !== DYNAMIC && builder.children.has(DYNAMIC)\n        ? [{builder: builder.getChild(DYNAMIC), predicates: []}]\n        : []),\n      ...(builder.children.has(key) ? [{builder: builder.getChild(key), predicates: []}] : []),\n    ];\n  } else {\n    throw new RuntimeError(\n      RuntimeErrorCode.UNKNOWN_BUILDER_TYPE,\n      ngDevMode && 'Unknown LogicNodeBuilder type',\n    );\n  }\n}\n\n/**\n * Creates the full `Logic` for a given builder.\n * This function handles different types of builders (`LogicNodeBuilder`, `NonMergeableLogicNodeBuilder`)\n * and applies the provided predicates.\n * @param builder The `AbstractLogicNodeBuilder` to process.\n * @param predicates Predicates to apply to the logic derived from the builder.\n * @param depth The depth in the field tree of the field which this logic applies to.\n * @returns The `Logic` instance.\n */\nfunction createLogic(\n  builder: AbstractLogicNodeBuilder,\n  predicates: BoundPredicate[],\n  depth: number,\n): LogicContainer {\n  const logic = new LogicContainer(predicates);\n  if (builder instanceof LogicNodeBuilder) {\n    const builtNodes = builder.all.map(\n      ({builder, predicate}) =>\n        new LeafLogicNode(\n          builder,\n          predicate ? [...predicates, bindLevel(predicate, depth)] : predicates,\n          depth,\n        ),\n    );\n    for (const node of builtNodes) {\n      logic.mergeIn(node.logic);\n    }\n  } else if (builder instanceof NonMergeableLogicNodeBuilder) {\n    logic.mergeIn(builder.logic);\n  } else {\n    throw new RuntimeError(\n      RuntimeErrorCode.UNKNOWN_BUILDER_TYPE,\n      ngDevMode && 'Unknown LogicNodeBuilder type',\n    );\n  }\n  return logic;\n}\n\n/**\n * Create a bound version of the given predicate to a specific depth in the field tree.\n * This allows us to unambiguously know which `FieldContext` the predicate function should receive.\n *\n * This is of particular concern when a schema is applied recursively to itself. Since the schema is\n * only compiled once, each nested application adds the same predicate instance. We differentiate\n * these by recording the depth of the field they're bound to.\n *\n * @param predicate The unbound predicate\n * @param depth The depth of the field the predicate is bound to\n * @returns A bound predicate\n */\nfunction bindLevel(predicate: Predicate, depth: number): BoundPredicate {\n  return {...predicate, depth: depth};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport type {SchemaPath, SchemaPathRules} from '../api/types';\nimport type {Predicate} from './logic';\nimport {LogicNodeBuilder} from './logic_node';\nimport type {SchemaImpl} from './schema';\n\n/**\n * Special key which is used to retrieve the `FieldPathNode` instance from its `FieldPath` proxy wrapper.\n */\nconst PATH = Symbol('PATH');\n\n/**\n * A path in the schema on which logic is stored so that it can be added to the corresponding field\n * when the field is created.\n */\nexport class FieldPathNode {\n  /** The root path node from which this path node is descended. */\n  readonly root: FieldPathNode;\n\n  /**\n   * A map containing all child path nodes that have been created on this path.\n   * Child path nodes are created automatically on first access if they do not exist already.\n   */\n  private readonly children = new Map<PropertyKey, FieldPathNode>();\n\n  /**\n   * A proxy that wraps the path node, allowing navigation to its child paths via property access.\n   */\n  readonly fieldPathProxy: SchemaPath<any> = new Proxy(\n    this,\n    FIELD_PATH_PROXY_HANDLER,\n  ) as unknown as SchemaPath<any>;\n\n  /**\n   * For a root path node this will contain the root logic builder. For non-root nodes,\n   * they determine their logic builder from their parent so this is undefined.\n   */\n  private readonly logicBuilder: LogicNodeBuilder | undefined;\n\n  protected constructor(\n    /** The property keys used to navigate from the root path to this path. */\n    readonly keys: PropertyKey[],\n    root: FieldPathNode | undefined,\n    /** The parent of this path node. */\n    private readonly parent: FieldPathNode | undefined,\n    /** The key of this node in its parent. */\n    private readonly keyInParent: PropertyKey | undefined,\n  ) {\n    this.root = root ?? this;\n    if (!parent) {\n      this.logicBuilder = LogicNodeBuilder.newRoot();\n    }\n  }\n\n  /** The logic builder used to accumulate logic on this path node. */\n  get builder(): LogicNodeBuilder {\n    if (this.logicBuilder) {\n      return this.logicBuilder;\n    }\n    return this.parent!.builder.getChild(this.keyInParent!);\n  }\n\n  /**\n   * Gets the path node for the given child property key.\n   * Child paths are created automatically on first access if they do not exist already.\n   */\n  getChild(key: PropertyKey): FieldPathNode {\n    if (!this.children.has(key)) {\n      this.children.set(key, new FieldPathNode([...this.keys, key], this.root, this, key));\n    }\n    return this.children.get(key)!;\n  }\n\n  /**\n   * Merges in logic from another schema to this one.\n   * @param other The other schema to merge in the logic from\n   * @param predicate A predicate indicating when the merged in logic should be active.\n   */\n  mergeIn(other: SchemaImpl, predicate?: Predicate) {\n    const path = other.compile();\n    this.builder.mergeIn(path.builder, predicate);\n  }\n\n  /** Extracts the underlying path node from the given path proxy. */\n  static unwrapFieldPath(formPath: SchemaPath<unknown, SchemaPathRules>): FieldPathNode {\n    return (formPath as any)[PATH] as FieldPathNode;\n  }\n\n  /** Creates a new root path node to be passed in to a schema function. */\n  static newRoot() {\n    return new FieldPathNode([], undefined, undefined, undefined);\n  }\n}\n\n/** Proxy handler which implements `FieldPath` on top of a `FieldPathNode`. */\nexport const FIELD_PATH_PROXY_HANDLER: ProxyHandler<FieldPathNode> = {\n  get(node: FieldPathNode, property: string | symbol) {\n    if (property === PATH) {\n      return node;\n    }\n\n    return node.getChild(property).fieldPathProxy;\n  },\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ɵRuntimeError as RuntimeError} from '@angular/core';\nimport {RuntimeErrorCode} from '../errors';\n\nimport {SchemaPath, SchemaFn, SchemaOrSchemaFn} from '../api/types';\nimport {FieldPathNode} from './path_node';\n\n/**\n * Keeps track of the path node for the schema function that is currently being compiled. This is\n * used to detect erroneous references to a path node outside of the context of its schema function.\n * Do not set this directly, it is a context variable managed by `SchemaImpl.compile`.\n */\nlet currentCompilingNode: FieldPathNode | undefined = undefined;\n\n/**\n * A cache of all schemas compiled under the current root compilation. This is used to avoid doing\n * extra work when compiling a schema that reuses references to the same sub-schema. For example:\n *\n * ```ts\n * const sub = schema(p => ...);\n * const s = schema(p => {\n *   apply(p.a, sub);\n *   apply(p.b, sub);\n * });\n * ```\n *\n * This also ensures that we don't go into an infinite loop when compiling a schema that references\n * itself.\n *\n * Do not directly add or remove entries from this map, it is a context variable managed by\n * `SchemaImpl.compile` and `SchemaImpl.rootCompile`.\n */\nconst compiledSchemas = new Map<SchemaImpl, FieldPathNode>();\n\n/**\n * Implements the `Schema` concept.\n */\nexport class SchemaImpl {\n  constructor(private schemaFn: SchemaFn<unknown>) {}\n\n  /**\n   * Compiles this schema within the current root compilation context. If the schema was previously\n   * compiled within this context, we reuse the cached FieldPathNode, otherwise we create a new one\n   * and cache it in the compilation context.\n   */\n  compile(): FieldPathNode {\n    if (compiledSchemas.has(this)) {\n      return compiledSchemas.get(this)!;\n    }\n    const path = FieldPathNode.newRoot();\n    compiledSchemas.set(this, path);\n    let prevCompilingNode = currentCompilingNode;\n    try {\n      currentCompilingNode = path;\n      this.schemaFn(path.fieldPathProxy);\n    } finally {\n      // Use a try/finally to ensure we restore the previous root upon completion,\n      // even if there are errors while compiling the schema.\n      currentCompilingNode = prevCompilingNode;\n    }\n    return path;\n  }\n\n  /**\n   * Creates a SchemaImpl from the given SchemaOrSchemaFn.\n   */\n  static create(schema: SchemaImpl | SchemaOrSchemaFn<any>) {\n    if (schema instanceof SchemaImpl) {\n      return schema;\n    }\n    return new SchemaImpl(schema as SchemaFn<unknown>);\n  }\n\n  /**\n   * Compiles the given schema in a fresh compilation context. This clears the cached results of any\n   * previous compilations.\n   */\n  static rootCompile(schema: SchemaImpl | SchemaOrSchemaFn<any> | undefined): FieldPathNode {\n    try {\n      compiledSchemas.clear();\n      if (schema === undefined) {\n        return FieldPathNode.newRoot();\n      }\n      if (schema instanceof SchemaImpl) {\n        return schema.compile();\n      }\n      return new SchemaImpl(schema as SchemaFn<unknown>).compile();\n    } finally {\n      // Use a try/finally to ensure we properly reset the compilation context upon completion,\n      // even if there are errors while compiling the schema.\n      compiledSchemas.clear();\n    }\n  }\n}\n\n/** Checks if the given value is a schema or schema function. */\nexport function isSchemaOrSchemaFn(value: unknown): value is SchemaOrSchemaFn<unknown> {\n  return value instanceof SchemaImpl || typeof value === 'function';\n}\n\n/** Checks that a path node belongs to the schema function currently being compiled. */\nexport function assertPathIsCurrent(path: SchemaPath<unknown>): void {\n  if (currentCompilingNode !== FieldPathNode.unwrapFieldPath(path).root) {\n    throw new RuntimeError(\n      RuntimeErrorCode.PATH_OUTSIDE_SCHEMA,\n      ngDevMode &&\n        `A FieldPath can only be used directly within the Schema that owns it, **not** outside of it or within a sub-schema.`,\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {type Signal} from '@angular/core';\nimport {FieldPathNode} from '../../schema/path_node';\nimport {assertPathIsCurrent} from '../../schema/schema';\nimport type {LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../types';\n\n/**\n * Sets a value for the {@link MetadataKey} for this field.\n *\n * This value is combined via a reduce operation defined by the particular key,\n * since multiple rules in the schema might set values for it.\n *\n * @param path The target path to set the metadata for.\n * @param key The metadata key\n * @param logic A function that receives the `FieldContext` and returns a value for the metadata.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TKey The type of metadata key.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function metadata<\n  TValue,\n  TKey extends MetadataKey<any, any, any>,\n  TPathKind extends PathKind = PathKind.Root,\n>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  key: TKey,\n  logic: NoInfer<LogicFn<TValue, MetadataSetterType<TKey>, TPathKind>>,\n): TKey {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addMetadataRule(key, logic);\n  return key;\n}\n\n/**\n * A reducer that determines the accumulated value for a metadata key by reducing the individual\n * values contributed from `metadata()` rules.\n *\n * @template TAcc The accumulated type of the reduce operation.\n * @template TItem The type of the individual items that are reduced over.\n * @experimental 21.0.2\n */\nexport interface MetadataReducer<TAcc, TItem> {\n  /** The reduce function. */\n  reduce: (acc: TAcc, item: TItem) => TAcc;\n  /** Gets the initial accumulated value. */\n  getInitial: () => TAcc;\n}\nexport const MetadataReducer = {\n  /** Creates a reducer that accumulates a list of its individual item values. */\n  list<TItem>(): MetadataReducer<TItem[], TItem | undefined> {\n    return {\n      reduce: (acc, item) => (item === undefined ? acc : [...acc, item]),\n      getInitial: () => [],\n    };\n  },\n\n  /** Creates a reducer that accumulates the min of its individual item values. */\n  min(): MetadataReducer<number | undefined, number | undefined> {\n    return {\n      reduce: (acc, item) => {\n        if (acc === undefined || item === undefined) {\n          return acc ?? item;\n        }\n        return Math.min(acc, item);\n      },\n      getInitial: () => undefined,\n    };\n  },\n\n  /** Creates a reducer that accumulates a the max of its individual item values. */\n  max(): MetadataReducer<number | undefined, number | undefined> {\n    return {\n      reduce: (prev, next) => {\n        if (prev === undefined || next === undefined) {\n          return prev ?? next;\n        }\n        return Math.max(prev, next);\n      },\n      getInitial: () => undefined,\n    };\n  },\n\n  /** Creates a reducer that logically or's its accumulated value with each individual item value. */\n  or(): MetadataReducer<boolean, boolean> {\n    return {\n      reduce: (prev, next) => prev || next,\n      getInitial: () => false,\n    };\n  },\n\n  /** Creates a reducer that logically and's its accumulated value with each individual item value. */\n  and(): MetadataReducer<boolean, boolean> {\n    return {\n      reduce: (prev, next) => prev && next,\n      getInitial: () => true,\n    };\n  },\n\n  /** Creates a reducer that always takes the next individual item value as the accumulated value. */\n  override,\n} as const;\n\nfunction override<T>(): MetadataReducer<T | undefined, T>;\nfunction override<T>(getInitial: () => T): MetadataReducer<T, T>;\nfunction override<T>(getInitial?: () => T): MetadataReducer<T | undefined, T> {\n  return {\n    reduce: (_, item) => item,\n    getInitial: () => getInitial?.(),\n  };\n}\n\n/**\n * Represents metadata that is aggregated from multiple parts according to the key's reducer\n * function. A value can be contributed to the aggregated value for a field using an\n * `metadata` rule in the schema. There may be multiple rules in a schema that contribute\n * values to the same `MetadataKey` of the same field.\n *\n * @template TRead The type read from the `FieldState` for this key\n * @template TWrite The type written to this key using the `metadata()` rule\n * @template TAcc The type of the reducer's accumulated value.\n *\n * @experimental 21.0.0\n */\nexport class MetadataKey<TRead, TWrite, TAcc> {\n  private brand!: [TRead, TWrite, TAcc];\n\n  /** Use {@link reducedMetadataKey}. */\n  protected constructor(\n    readonly reducer: MetadataReducer<TAcc, TWrite>,\n    readonly create: ((s: Signal<TAcc>) => TRead) | undefined,\n  ) {}\n}\n\n/**\n * Extracts the the type that can be set into the given metadata key type using the `metadata()` rule.\n *\n * @template TKey The `MetadataKey` type\n *\n * @experimental 21.0.0\n */\nexport type MetadataSetterType<TKey> =\n  TKey extends MetadataKey<any, infer TWrite, any> ? TWrite : never;\n\n/**\n * Creates a metadata key used to contain a computed value.\n * The last value set on a given field tree node overrides any previously set values.\n *\n * @template TWrite The type written to this key using the `metadata()` rule\n *\n * @experimental 21.0.0\n */\nexport function createMetadataKey<TWrite>(): MetadataKey<\n  Signal<TWrite | undefined>,\n  TWrite,\n  TWrite | undefined\n>;\n/**\n * Creates a metadata key used to contain a computed value.\n *\n * @param reducer The reducer used to combine individually set values into the final computed value.\n * @template TWrite The type written to this key using the `metadata()` rule\n * @template TAcc The type of the reducer's accumulated value.\n *\n * @experimental 21.0.0\n */\nexport function createMetadataKey<TWrite, TAcc>(\n  reducer: MetadataReducer<TAcc, TWrite>,\n): MetadataKey<Signal<TAcc>, TWrite, TAcc>;\nexport function createMetadataKey<TWrite, TAcc>(\n  reducer?: MetadataReducer<TAcc, TWrite>,\n): MetadataKey<Signal<TAcc>, TWrite, TAcc> {\n  return new (MetadataKey as new (\n    reducer: MetadataReducer<TAcc, TWrite>,\n  ) => MetadataKey<Signal<TAcc>, TWrite, TAcc>)(reducer ?? MetadataReducer.override<any>());\n}\n\n/**\n * Creates a metadata key that exposes a managed value based on the accumulated result of the values\n * written to the key. The accumulated value takes the last value set on a given field tree node,\n * overriding any previously set values.\n *\n * @param create A function that receives a signal of the accumulated value and returns the managed\n *   value based on it. This function runs during the construction of the `FieldTree` node,\n *   and runs in the injection context of that node.\n * @template TRead The type read from the `FieldState` for this key\n * @template TWrite The type written to this key using the `metadata()` rule\n *\n * @experimental 21.0.0\n */\nexport function createManagedMetadataKey<TRead, TWrite>(\n  create: (s: Signal<TWrite | undefined>) => TRead,\n): MetadataKey<TRead, TWrite, TWrite | undefined>;\n/**\n * Creates a metadata key that exposes a managed value based on the accumulated result of the values\n * written to the key.\n *\n * @param create A function that receives a signal of the accumulated value and returns the managed\n *   value based on it. This function runs during the construction of the `FieldTree` node,\n *   and runs in the injection context of that node.\n * @param reducer The reducer used to combine individual value written to the key,\n *   this will determine the accumulated value that the create function receives.\n * @template TRead The type read from the `FieldState` for this key\n * @template TWrite The type written to this key using the `metadata()` rule\n * @template TAcc The type of the reducer's accumulated value.\n *\n * @experimental 21.0.0\n */\nexport function createManagedMetadataKey<TRead, TWrite, TAcc>(\n  create: (s: Signal<TAcc>) => TRead,\n  reducer: MetadataReducer<TAcc, TWrite>,\n): MetadataKey<TRead, TWrite, TAcc>;\nexport function createManagedMetadataKey<TRead, TWrite, TAcc>(\n  create: (s: Signal<TAcc>) => TRead,\n  reducer?: MetadataReducer<TAcc, TWrite>,\n): MetadataKey<TRead, TWrite, TAcc> {\n  return new (MetadataKey as new (\n    reducer: MetadataReducer<TAcc, TWrite>,\n    create: (s: Signal<TAcc>) => TRead,\n  ) => MetadataKey<TRead, TWrite, TAcc>)(reducer ?? MetadataReducer.override<any>(), create);\n}\n\n/**\n * A {@link MetadataKey} representing whether the field is required.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const REQUIRED: MetadataKey<Signal<boolean>, boolean, boolean> = createMetadataKey(\n  MetadataReducer.or(),\n);\n\n/**\n * A {@link MetadataKey} representing the min value of the field.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const MIN: MetadataKey<\n  Signal<number | undefined>,\n  number | undefined,\n  number | undefined\n> = createMetadataKey(MetadataReducer.max());\n\n/**\n * A {@link MetadataKey} representing the max value of the field.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const MAX: MetadataKey<\n  Signal<number | undefined>,\n  number | undefined,\n  number | undefined\n> = createMetadataKey(MetadataReducer.min());\n\n/**\n * A {@link MetadataKey} representing the min length of the field.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const MIN_LENGTH: MetadataKey<\n  Signal<number | undefined>,\n  number | undefined,\n  number | undefined\n> = createMetadataKey(MetadataReducer.max());\n\n/**\n * A {@link MetadataKey} representing the max length of the field.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const MAX_LENGTH: MetadataKey<\n  Signal<number | undefined>,\n  number | undefined,\n  number | undefined\n> = createMetadataKey(MetadataReducer.min());\n\n/**\n * A {@link MetadataKey} representing the patterns the field must match.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const PATTERN: MetadataKey<\n  Signal<RegExp[]>,\n  RegExp | undefined,\n  RegExp[]\n> = createMetadataKey(MetadataReducer.list<RegExp>());\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, Signal, untracked, ɵWritable} from '@angular/core';\nimport type {ValidationError} from '../api/rules/validation/validation_errors';\nimport type {FieldTree, TreeValidationResult, ValidationResult} from '../api/types';\nimport {isArray} from '../util/type_guards';\nimport type {FieldNode} from './node';\nimport {shortCircuitFalse} from './util';\n\n/**\n * Helper function taking validation state, and returning own state of the node.\n * @param state\n */\nexport function calculateValidationSelfStatus(\n  state: ValidationState,\n): 'invalid' | 'unknown' | 'valid' {\n  if (state.errors().length > 0) {\n    return 'invalid';\n  }\n  if (state.pending()) {\n    return 'unknown';\n  }\n\n  return 'valid';\n}\n\nexport interface ValidationState {\n  /**\n   * The full set of synchronous tree errors visible to this field. This includes ones that are\n   * targeted at a descendant field rather than at this field.\n   */\n  rawSyncTreeErrors: Signal<ValidationError.WithFieldTree[]>;\n\n  /**\n   * The full set of synchronous errors for this field, including synchronous tree errors and submission\n   * errors. Submission errors are considered \"synchronous\" because they are imperatively added. From\n   * the perspective of the field state they are either there or not, they are never in a pending\n   * state.\n   */\n  syncErrors: Signal<ValidationError.WithFieldTree[]>;\n\n  /**\n   * Whether the field is considered valid according solely to its synchronous validators.\n   * Errors resulting from a previous submit attempt are also considered for this state.\n   */\n  syncValid: Signal<boolean>;\n\n  /**\n   * The full set of asynchronous tree errors visible to this field. This includes ones that are\n   * targeted at a descendant field rather than at this field, as well as sentinel 'pending' values\n   * indicating that the validator is still running and an error could still occur.\n   */\n  rawAsyncErrors: Signal<(ValidationError.WithFieldTree | 'pending')[]>;\n\n  /**\n   * The asynchronous tree errors visible to this field that are specifically targeted at this field\n   * rather than a descendant. This also includes all 'pending' sentinel values, since those could\n   * theoretically result in errors for this field.\n   */\n  asyncErrors: Signal<(ValidationError.WithFieldTree | 'pending')[]>;\n\n  /**\n   * The combined set of all errors that currently apply to this field.\n   */\n  errors: Signal<ValidationError.WithFieldTree[]>;\n\n  parseErrors: Signal<ValidationError.WithFormField[]>;\n\n  /**\n   * The combined set of all errors that currently apply to this field and its descendants.\n   */\n  errorSummary: Signal<ValidationError.WithFieldTree[]>;\n\n  /**\n   * Whether this field has any asynchronous validators still pending.\n   */\n  pending: Signal<boolean>;\n\n  /**\n   * The validation status of the field.\n   * - The status is 'valid' if neither the field nor any of its children has any errors or pending\n   *   validators.\n   * - The status is 'invalid' if the field or any of its children has an error\n   *   (regardless of pending validators)\n   * - The status is 'unknown' if neither the field nor any of its children has any errors,\n   *   but the field or any of its children does have a pending validator.\n   *\n   * A field is considered valid if *all* of the following are true:\n   *  - It has no errors or pending validators\n   *  - All of its children are considered valid\n   * A field is considered invalid if *any* of the following are true:\n   *  - It has an error\n   *  - Any of its children is considered invalid\n   * A field is considered to have unknown validity status if it is not valid or invalid.\n   */\n  status: Signal<'valid' | 'invalid' | 'unknown'>;\n  /**\n   * Whether the field is considered valid.\n   *\n   * A field is considered valid if *all* of the following are true:\n   *  - It has no errors or pending validators\n   *  - All of its children are considered valid\n   *\n   * Note: `!valid()` is *not* the same as `invalid()`. Both `valid()` and `invalid()` can be false\n   * if there are currently no errors, but validators are still pending.\n   */\n  valid: Signal<boolean>;\n\n  /**\n   * Whether the field is considered invalid.\n   *\n   * A field is considered invalid if *any* of the following are true:\n   *  - It has an error\n   *  - Any of its children is considered invalid\n   *\n   * Note: `!invalid()` is *not* the same as `valid()`. Both `valid()` and `invalid()` can be false\n   * if there are currently no errors, but validators are still pending.\n   */\n  invalid: Signal<boolean>;\n\n  /**\n   * Indicates whether validation should be skipped for this field because it is hidden, disabled,\n   * or readonly.\n   */\n  shouldSkipValidation: Signal<boolean>;\n}\n\n/**\n * The validation state associated with a `FieldNode`.\n *\n * This class collects together various types of errors to represent the full validation state of\n * the field. There are 4 types of errors that need to be combined to determine validity:\n * 1. The synchronous errors produced by the schema logic.\n * 2. The synchronous tree errors produced by the schema logic. Tree errors may apply to a different\n *    field than the one that the logic that produced them is bound to. They support targeting the\n *    error at an arbitrary descendant field.\n * 3. The asynchronous tree errors produced by the schema logic. These work like synchronous tree\n *    errors, except the error list may also contain a special sentinel value indicating that a\n *    validator is still running.\n * 4. Server errors are not produced by the schema logic, but instead get imperatively added when a\n *    form submit fails with errors.\n */\nexport class FieldValidationState implements ValidationState {\n  constructor(readonly node: FieldNode) {}\n\n  /**\n   * The full set of synchronous tree errors visible to this field. This includes ones that are\n   * targeted at a descendant field rather than at this field.\n   */\n  readonly rawSyncTreeErrors: Signal<ValidationError.WithFieldTree[]> = computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n\n    return [\n      ...this.node.logicNode.logic.syncTreeErrors.compute(this.node.context),\n      ...(this.node.structure.parent?.validationState.rawSyncTreeErrors() ?? []),\n    ];\n  });\n\n  /**\n   * The full set of synchronous errors for this field, including synchronous tree errors and\n   * submission errors. Submission errors are considered \"synchronous\" because they are imperatively\n   * added. From the perspective of the field state they are either there or not, they are never in a\n   * pending state.\n   */\n  readonly syncErrors: Signal<ValidationError.WithFieldTree[]> = computed(() => {\n    // Short-circuit running validators if validation doesn't apply to this field.\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n\n    return [\n      ...this.node.logicNode.logic.syncErrors.compute(this.node.context),\n      ...this.syncTreeErrors(),\n      ...normalizeErrors(this.node.submitState.submissionErrors()),\n    ];\n  });\n\n  /**\n   * Whether the field is considered valid according solely to its synchronous validators.\n   * Errors resulting from a previous submit attempt are also considered for this state.\n   */\n  readonly syncValid: Signal<boolean> = computed(() => {\n    // Short-circuit checking children if validation doesn't apply to this field.\n    if (this.shouldSkipValidation()) {\n      return true;\n    }\n\n    return this.node.structure.reduceChildren(\n      this.syncErrors().length === 0,\n      (child, value) => value && child.validationState.syncValid(),\n      shortCircuitFalse,\n    );\n  });\n\n  /**\n   * The synchronous tree errors visible to this field that are specifically targeted at this field\n   * rather than a descendant.\n   */\n  readonly syncTreeErrors: Signal<ValidationError.WithFieldTree[]> = computed(() =>\n    this.rawSyncTreeErrors().filter((err) => err.fieldTree === this.node.fieldProxy),\n  );\n\n  /**\n   * The full set of asynchronous tree errors visible to this field. This includes ones that are\n   * targeted at a descendant field rather than at this field, as well as sentinel 'pending' values\n   * indicating that the validator is still running and an error could still occur.\n   */\n  readonly rawAsyncErrors: Signal<(ValidationError.WithFieldTree | 'pending')[]> = computed(() => {\n    // Short-circuit running validators if validation doesn't apply to this field.\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n\n    return [\n      // TODO: add field in `validateAsync` and remove this map\n      ...this.node.logicNode.logic.asyncErrors.compute(this.node.context),\n      // TODO: does it make sense to filter this to errors in this subtree?\n      ...(this.node.structure.parent?.validationState.rawAsyncErrors() ?? []),\n    ];\n  });\n\n  /**\n   * The asynchronous tree errors visible to this field that are specifically targeted at this field\n   * rather than a descendant. This also includes all 'pending' sentinel values, since those could\n   * theoretically result in errors for this field.\n   */\n  readonly asyncErrors: Signal<(ValidationError.WithFieldTree | 'pending')[]> = computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n    return this.rawAsyncErrors().filter(\n      (err) => err === 'pending' || err.fieldTree === this.node.fieldProxy,\n    );\n  });\n\n  readonly parseErrors: Signal<ValidationError.WithFormField[]> = computed(() =>\n    this.node.formFieldBindings().flatMap((field) => field.parseErrors()),\n  );\n\n  /**\n   * The combined set of all errors that currently apply to this field.\n   */\n  readonly errors = computed(() => [\n    ...this.parseErrors(),\n    ...this.syncErrors(),\n    ...this.asyncErrors().filter((err) => err !== 'pending'),\n  ]);\n\n  readonly errorSummary = computed(() => {\n    const errors = this.node.structure.reduceChildren(this.errors(), (child, result) => [\n      ...result,\n      ...child.errorSummary(),\n    ]);\n    // Sort by DOM order on client-side only.\n    if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n      untracked(() => errors.sort(compareErrorPosition));\n    }\n    return errors;\n  });\n\n  /**\n   * Whether this field has any asynchronous validators still pending.\n   */\n  readonly pending = computed(() =>\n    this.node.structure.reduceChildren(\n      this.asyncErrors().includes('pending'),\n      (child, value) => value || child.validationState.asyncErrors().includes('pending'),\n    ),\n  );\n\n  /**\n   * The validation status of the field.\n   * - The status is 'valid' if neither the field nor any of its children has any errors or pending\n   *   validators.\n   * - The status is 'invalid' if the field or any of its children has an error\n   *   (regardless of pending validators)\n   * - The status is 'unknown' if neither the field nor any of its children has any errors,\n   *   but the field or any of its children does have a pending validator.\n   *\n   * A field is considered valid if *all* of the following are true:\n   *  - It has no errors or pending validators\n   *  - All of its children are considered valid\n   * A field is considered invalid if *any* of the following are true:\n   *  - It has an error\n   *  - Any of its children is considered invalid\n   * A field is considered to have unknown validity status if it is not valid or invalid.\n   */\n  readonly status: Signal<'valid' | 'invalid' | 'unknown'> = computed(() => {\n    // Short-circuit checking children if validation doesn't apply to this field.\n    if (this.shouldSkipValidation()) {\n      return 'valid';\n    }\n    let ownStatus = calculateValidationSelfStatus(this);\n\n    return this.node.structure.reduceChildren<'valid' | 'invalid' | 'unknown'>(\n      ownStatus,\n      (child, value) => {\n        if (value === 'invalid' || child.validationState.status() === 'invalid') {\n          return 'invalid';\n        } else if (value === 'unknown' || child.validationState.status() === 'unknown') {\n          return 'unknown';\n        }\n        return 'valid';\n      },\n      (v) => v === 'invalid', // short-circuit on 'invalid'\n    );\n  });\n\n  /**\n   * Whether the field is considered valid.\n   *\n   * A field is considered valid if *all* of the following are true:\n   *  - It has no errors or pending validators\n   *  - All of its children are considered valid\n   *\n   * Note: `!valid()` is *not* the same as `invalid()`. Both `valid()` and `invalid()` can be false\n   * if there are currently no errors, but validators are still pending.\n   */\n  readonly valid = computed(() => this.status() === 'valid');\n\n  /**\n   * Whether the field is considered invalid.\n   *\n   * A field is considered invalid if *any* of the following are true:\n   *  - It has an error\n   *  - Any of its children is considered invalid\n   *\n   * Note: `!invalid()` is *not* the same as `valid()`. Both `valid()` and `invalid()` can be false\n   * if there are currently no errors, but validators are still pending.\n   */\n  readonly invalid = computed(() => this.status() === 'invalid');\n\n  /**\n   * Indicates whether validation should be skipped for this field because it is hidden, disabled,\n   * or readonly.\n   */\n  readonly shouldSkipValidation = computed(\n    () => this.node.hidden() || this.node.disabled() || this.node.readonly(),\n  );\n}\n\n/** Normalizes a validation result to a list of validation errors. */\nfunction normalizeErrors<T extends ValidationResult>(error: T | readonly T[]): readonly T[] {\n  if (error === undefined) {\n    return [];\n  }\n\n  if (isArray(error)) {\n    return error as readonly T[];\n  }\n\n  return [error as T];\n}\n\n/**\n * Sets the given field on the given error(s) if it does not already have a field.\n * @param error The error(s) to add the field to\n * @param fieldTree The default field to add\n * @returns The passed in error(s), with its field set.\n */\nexport function addDefaultField<E extends ValidationError.WithOptionalFieldTree>(\n  error: E,\n  fieldTree: FieldTree<unknown>,\n): E & {fieldTree: FieldTree<unknown>};\nexport function addDefaultField<E extends ValidationError>(\n  errors: TreeValidationResult<E>,\n  fieldTree: FieldTree<unknown>,\n): ValidationResult<E & {fieldTree: FieldTree<unknown>}>;\nexport function addDefaultField<E extends ValidationError>(\n  errors: TreeValidationResult<E>,\n  fieldTree: FieldTree<unknown>,\n): ValidationResult<E & {fieldTree: FieldTree<unknown>}> {\n  if (isArray(errors)) {\n    for (const error of errors) {\n      (error as ɵWritable<ValidationError.WithOptionalFieldTree>).fieldTree ??= fieldTree;\n    }\n  } else if (errors) {\n    (errors as ɵWritable<ValidationError.WithOptionalFieldTree>).fieldTree ??= fieldTree;\n  }\n  return errors as ValidationResult<E & {fieldTree: FieldTree<unknown>}>;\n}\n\nfunction getFirstBoundElement(error: ValidationError.WithFieldTree) {\n  if (error.formField) return error.formField.element;\n  return error\n    .fieldTree()\n    .formFieldBindings()\n    .reduce<HTMLElement | undefined>((el: HTMLElement | undefined, binding) => {\n      if (!el || !binding.element) return el ?? binding.element;\n      return el.compareDocumentPosition(binding.element) & Node.DOCUMENT_POSITION_PRECEDING\n        ? binding.element\n        : el;\n    }, undefined);\n}\n\n/**\n * Compares the position of two validation errors by the position of their corresponding field\n * binding directive in the DOM.\n * - For errors with multiple field bindings, the earliest one in the DOM will be used for comparison.\n * - For errors that have no field bindings, they will be considered to come after all other errors.\n */\nfunction compareErrorPosition(\n  a: ValidationError.WithFieldTree,\n  b: ValidationError.WithFieldTree,\n): number {\n  const aEl = getFirstBoundElement(a);\n  const bEl = getFirstBoundElement(b);\n  if (aEl === bEl) return 0;\n  if (aEl === undefined || bEl === undefined) return aEl === undefined ? 1 : -1;\n  return aEl.compareDocumentPosition(bEl) & Node.DOCUMENT_POSITION_PRECEDING ? 1 : -1;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {Signal} from '@angular/core';\nimport {createMetadataKey, MetadataKey} from '../api/rules/metadata';\nimport {Debouncer} from '../api/types';\n\n/**\n * A private {@link MetadataKey} used to aggregate `debounce()` rules.\n *\n * This will pick the last `debounce()` rule on a field that is currently applied, if conditional.\n */\nexport const DEBOUNCER: MetadataKey<\n  Signal<Debouncer<any> | undefined> | undefined,\n  Debouncer<any> | undefined,\n  Debouncer<any> | undefined\n> = createMetadataKey();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  computed,\n  Signal,\n  untracked,\n  WritableSignal,\n  ɵRuntimeError as RuntimeError,\n} from '@angular/core';\nimport {RuntimeErrorCode} from '../errors';\nimport {AbstractControl} from '@angular/forms';\nimport {\n  FieldContext,\n  FieldState,\n  FieldTree,\n  SchemaPath,\n  SchemaPathRules,\n  SchemaPathTree,\n} from '../api/types';\nimport {FieldPathNode} from '../schema/path_node';\nimport {isArray} from '../util/type_guards';\nimport type {FieldNode} from './node';\nimport {getBoundPathDepth} from './resolution';\n\n/**\n * `FieldContext` implementation, backed by a `FieldNode`.\n */\nexport class FieldNodeContext implements FieldContext<unknown> {\n  /**\n   * Cache of paths that have been resolved for this context.\n   *\n   * For each resolved path we keep track of a signal of field that it maps to rather than a static\n   * field, since it theoretically could change. In practice for the current system it should not\n   * actually change, as they only place we currently track fields moving within the parent\n   * structure is for arrays, and paths do not currently support array indexing.\n   */\n  private readonly cache = new WeakMap<\n    SchemaPath<unknown, SchemaPathRules>,\n    Signal<FieldTree<unknown>>\n  >();\n\n  constructor(\n    /** The field node this context corresponds to. */\n    private readonly node: FieldNode,\n  ) {}\n\n  /**\n   * Resolves a target path relative to this context.\n   * @param target The path to resolve\n   * @returns The field corresponding to the target path.\n   */\n  private resolve<U>(target: SchemaPath<U, SchemaPathRules>): FieldTree<U> {\n    if (!this.cache.has(target)) {\n      const resolver = computed<FieldTree<unknown>>(() => {\n        const targetPathNode = FieldPathNode.unwrapFieldPath(target);\n\n        // First, find the field where the root our target path was merged in.\n        // We determine this by walking up the field tree from the current field and looking for\n        // the place where the LogicNodeBuilder from the target path's root was merged in.\n        // We always make sure to walk up at least as far as the depth of the path we were bound to.\n        // This ensures that we do not accidentally match on the wrong application of a recursively\n        // applied schema.\n        let field: FieldNode | undefined = this.node;\n        let stepsRemaining = getBoundPathDepth();\n        while (stepsRemaining > 0 || !field.structure.logic.hasLogic(targetPathNode.root.builder)) {\n          stepsRemaining--;\n          field = field.structure.parent;\n          if (field === undefined) {\n            throw new RuntimeError(\n              RuntimeErrorCode.PATH_NOT_IN_FIELD_TREE,\n              ngDevMode && 'Path is not part of this field tree.',\n            );\n          }\n        }\n\n        // Now, we can navigate to the target field using the relative path in the target path node\n        // to traverse down from the field we just found.\n        for (let key of targetPathNode.keys) {\n          field = field.structure.getChild(key);\n          if (field === undefined) {\n            throw new RuntimeError(\n              RuntimeErrorCode.PATH_RESOLUTION_FAILED,\n              ngDevMode &&\n                `Cannot resolve path .${targetPathNode.keys.join('.')} relative to field ${[\n                  '<root>',\n                  ...this.node.structure.pathKeys(),\n                ].join('.')}.`,\n            );\n          }\n        }\n\n        return field.fieldProxy;\n      });\n\n      this.cache.set(target, resolver);\n    }\n    return this.cache.get(target)!() as FieldTree<U>;\n  }\n\n  get fieldTree(): FieldTree<unknown> {\n    return this.node.fieldProxy;\n  }\n\n  get state(): FieldState<unknown> {\n    return this.node;\n  }\n\n  get value(): WritableSignal<unknown> {\n    return this.node.structure.value;\n  }\n\n  get key(): Signal<string> {\n    return this.node.structure.keyInParent;\n  }\n\n  get pathKeys(): Signal<readonly string[]> {\n    return this.node.structure.pathKeys;\n  }\n\n  readonly index = computed(() => {\n    // Attempt to read the key first, this will throw an error if we're on a root field.\n    const key = this.key();\n    // Assert that the parent is actually an array.\n    if (!isArray(untracked(this.node.structure.parent!.value))) {\n      throw new RuntimeError(\n        RuntimeErrorCode.PARENT_NOT_ARRAY,\n        ngDevMode && 'Cannot access index, parent field is not an array.',\n      );\n    }\n    // Return the key as a number if we are indeed inside an array field.\n    return Number(key);\n  });\n\n  readonly fieldTreeOf = <TModel>(p: SchemaPathTree<TModel>) => this.resolve<TModel>(p);\n  readonly stateOf = <TModel>(p: SchemaPath<TModel, SchemaPathRules>) => this.resolve<TModel>(p)();\n  readonly valueOf = <TValue>(p: SchemaPath<TValue, SchemaPathRules>) => {\n    const result = this.resolve(p)().value();\n\n    if (result instanceof AbstractControl) {\n      throw new RuntimeError(\n        RuntimeErrorCode.ABSTRACT_CONTROL_IN_FORM,\n        ngDevMode &&\n          `Tried to read an 'AbstractControl' value from a 'form()'. Did you mean to use 'compatForm()' instead?`,\n      );\n    }\n    return result;\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  computed,\n  runInInjectionContext,\n  untracked,\n  ɵRuntimeError as RuntimeError,\n} from '@angular/core';\nimport {MetadataKey} from '../api/rules/metadata';\nimport {RuntimeErrorCode} from '../errors';\nimport type {FieldNode} from './node';\n\n/**\n * Tracks custom metadata associated with a `FieldNode`.\n */\nexport class FieldMetadataState {\n  /** A map of all `MetadataKey` that have been defined for this field. */\n  private readonly metadata = new Map<MetadataKey<unknown, unknown, unknown>, unknown>();\n\n  constructor(private readonly node: FieldNode) {\n    // Force eager creation of managed keys,\n    // as managed keys have a `create` function that needs to run during construction.\n    for (const key of this.node.logicNode.logic.getMetadataKeys()) {\n      if (key.create) {\n        const logic = this.node.logicNode.logic.getMetadata(key);\n        const result = untracked(() =>\n          runInInjectionContext(this.node.structure.injector, () =>\n            key.create!(computed(() => logic.compute(this.node.context))),\n          ),\n        );\n        this.metadata.set(key, result);\n      }\n    }\n  }\n\n  /** Gets the value of an `MetadataKey` for the field. */\n  get<T>(key: MetadataKey<T, unknown, unknown>): T | undefined {\n    // We create non-managed metadata lazily, the first time they are accessed.\n    if (this.has(key)) {\n      if (!this.metadata.has(key)) {\n        if (key.create) {\n          throw new RuntimeError(\n            RuntimeErrorCode.MANAGED_METADATA_LAZY_CREATION,\n            ngDevMode && 'Managed metadata cannot be created lazily',\n          );\n        }\n        const logic = this.node.logicNode.logic.getMetadata(key);\n        this.metadata.set(\n          key,\n          computed(() => logic.compute(this.node.context)),\n        );\n      }\n    }\n    return this.metadata.get(key) as T | undefined;\n  }\n\n  /** Checks whether the current metadata state has the given metadata key. */\n  has(key: MetadataKey<any, any, any>): boolean {\n    // Metadata keys get added to the map lazily, on first access,\n    // so we can't rely on checking presence in the metadata map.\n    // Instead we check if there is any logic for the given metadata key.\n    return this.node.logicNode.logic.hasMetadata(key);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {untracked} from '@angular/core';\nimport {isArray, isObject} from '../util/type_guards';\nimport type {FieldNode} from './node';\n\n/**\n * Proxy handler which implements `FieldTree<T>` on top of `FieldNode`.\n */\nexport const FIELD_PROXY_HANDLER: ProxyHandler<() => FieldNode> = {\n  get(getTgt: () => FieldNode, p: string | symbol, receiver: {[key: string]: unknown}) {\n    const tgt = getTgt();\n\n    // First, check whether the requested property is a defined child node of this node.\n    const child = tgt.structure.getChild(p);\n    if (child !== undefined) {\n      // If so, return the child node's `FieldTree` proxy, allowing the developer to continue\n      // navigating the form structure.\n      return child.fieldProxy;\n    }\n\n    // Otherwise, we need to consider whether the properties they're accessing are related to array\n    // iteration. We're specifically interested in `length`, but we only want to pass this through\n    // if the value is actually an array.\n    //\n    // We untrack the value here to avoid spurious reactive notifications. In reality, we've already\n    // incurred a dependency on the value via `tgt.getChild()` above.\n    const value = untracked(tgt.value);\n\n    if (isArray(value)) {\n      // Allow access to the length for field arrays, it should be the same as the length of the data.\n      if (p === 'length') {\n        return (tgt.value() as Array<unknown>).length;\n      }\n      // Allow access to the iterator. This allows the user to spread the field array into a\n      // standard array in order to call methods like `filter`, `map`, etc.\n      if (p === Symbol.iterator) {\n        return () => {\n          // When creating an iterator, we need to account for reactivity. The iterator itself will\n          // read things each time `.next()` is called, but that may happen outside of the context\n          // where the iterator was created (e.g. with `@for`, actual diffing happens outside the\n          // reactive context of the template).\n          //\n          // Instead, side-effectfully read the value here to ensure iterator creation is reactive.\n          tgt.value();\n          return Array.prototype[Symbol.iterator].apply(tgt.fieldProxy);\n        };\n      }\n      // Note: We can consider supporting additional array methods if we want in the future,\n      // but they should be thoroughly tested. Just forwarding the method directly from the\n      // `Array` prototype results in broken behavior for some methods like `map`.\n    }\n\n    if (isObject(value)) {\n      // For object fields, allow iteration over their entries for convenience of use with `@for`.\n      if (p === Symbol.iterator) {\n        return function* () {\n          for (const key in receiver) {\n            yield [key, receiver[key]];\n          }\n        };\n      }\n    }\n\n    // Otherwise, this property doesn't exist.\n    return undefined;\n  },\n\n  getOwnPropertyDescriptor(getTgt, prop) {\n    const value = untracked(getTgt().value) as Object;\n    const desc = Reflect.getOwnPropertyDescriptor(value, prop);\n    // In order for `Object.keys` to function properly, keys must be reported as configurable.\n    if (desc && !desc.configurable) {\n      desc.configurable = true;\n    }\n    return desc;\n  },\n\n  ownKeys(getTgt: () => FieldNode) {\n    const value = untracked(getTgt().value);\n    return typeof value === 'object' && value !== null ? Reflect.ownKeys(value) : [];\n  },\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, Signal, untracked, WritableSignal} from '@angular/core';\nimport {SIGNAL} from '@angular/core/primitives/signals';\nimport {isArray} from './type_guards';\n\n/**\n * Creates a writable signal for a specific property on a source writeable signal.\n * @param source A writeable signal to derive from\n * @param prop A signal of a property key of the source value\n * @returns A writeable signal for the given property of the source value.\n * @template S The source value type\n * @template K The key type for S\n */\nexport function deepSignal<S, K extends keyof S>(\n  source: WritableSignal<S>,\n  prop: Signal<K>,\n): WritableSignal<S[K]> {\n  // Memoize the property.\n  const read = computed(() => source()[prop()]) as WritableSignal<S[K]>;\n\n  read[SIGNAL] = source[SIGNAL];\n  read.set = (value: S[K]) => {\n    source.update((current) => valueForWrite(current, value, prop()) as S);\n  };\n\n  read.update = (fn: (current: S[K]) => S[K]) => {\n    read.set(fn(untracked(read)));\n  };\n  read.asReadonly = () => read;\n\n  return read;\n}\n\n/**\n * Gets an updated root value to use when setting a value on a deepSignal with the given path.\n * @param sourceValue The current value of the deepSignal's source.\n * @param newPropValue The value being written to the deepSignal's property\n * @param prop The deepSignal's property key\n * @returns An updated value for the deepSignal's source\n */\nfunction valueForWrite(sourceValue: unknown, newPropValue: unknown, prop: PropertyKey): unknown {\n  if (isArray(sourceValue)) {\n    const newValue = [...sourceValue];\n    newValue[prop as number] = newPropValue;\n    return newValue;\n  } else {\n    return {...(sourceValue as object), [prop]: newPropValue};\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  computed,\n  DestroyableInjector,\n  Injector,\n  linkedSignal,\n  ɵRuntimeError as RuntimeError,\n  Signal,\n  untracked,\n  WritableSignal,\n} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nimport {LogicNode} from '../schema/logic_node';\nimport type {FieldPathNode} from '../schema/path_node';\nimport {deepSignal} from '../util/deep_signal';\nimport {isArray, isObject} from '../util/type_guards';\nimport type {FieldAdapter} from './field_adapter';\nimport type {FormFieldManager} from './manager';\nimport type {FieldNode, ParentFieldNode} from './node';\n\n/**\n * Key by which a parent `FieldNode` tracks its children.\n *\n * Often this is the actual property key of the child, but in the case of arrays it could be a\n * tracking key allocated for the object.\n */\nexport type TrackingKey = PropertyKey & {__brand: 'FieldIdentity'};\nexport type ChildNodeCtor = (\n  key: string,\n  trackingKey: TrackingKey | undefined,\n  isArray: boolean,\n) => FieldNode;\n\n/** Structural component of a `FieldNode` which tracks its path, parent, and children. */\nexport abstract class FieldNodeStructure {\n  /**\n   * Computed map of child fields, based on the current value of this field.\n   *\n   * This structure reacts to `this.value` and produces a new `ChildrenData` when the\n   * value changes structurally (fields added/removed/moved).\n   */\n  protected abstract readonly childrenMap: Signal<ChildrenData | undefined>;\n\n  /** The field's value. */\n  abstract readonly value: WritableSignal<unknown>;\n\n  /**\n   * The key of this field in its parent field.\n   * Attempting to read this for the root field will result in an error being thrown.\n   */\n  abstract readonly keyInParent: Signal<string>;\n\n  /** The field manager responsible for managing this field. */\n  abstract readonly fieldManager: FormFieldManager;\n\n  /** The root field that this field descends from. */\n  abstract readonly root: FieldNode;\n\n  /** The list of property keys to follow to get from the `root` to this field. */\n  abstract readonly pathKeys: Signal<readonly string[]>;\n\n  /** The parent field of this field. */\n  abstract readonly parent: FieldNode | undefined;\n\n  readonly logic: LogicNode;\n  readonly node: FieldNode;\n\n  readonly createChildNode: ChildNodeCtor;\n\n  /** Added to array elements for tracking purposes. */\n  // TODO: given that we don't ever let a field move between parents, is it safe to just extract\n  // this to a shared symbol for all fields, rather than having a separate one per parent?\n  readonly identitySymbol = Symbol();\n\n  /** Lazily initialized injector. Do not access directly, access via `injector` getter instead. */\n  private _injector: DestroyableInjector | undefined = undefined;\n\n  /** Lazily initialized injector. */\n  get injector(): DestroyableInjector {\n    this._injector ??= Injector.create({\n      providers: [],\n      parent: this.fieldManager.injector,\n    }) as DestroyableInjector;\n    return this._injector;\n  }\n\n  constructor(logic: LogicNode, node: FieldNode, createChildNode: ChildNodeCtor) {\n    this.logic = logic;\n    this.node = node;\n    this.createChildNode = createChildNode;\n  }\n\n  /** Gets the child fields of this field. */\n  children(): readonly FieldNode[] {\n    const map = this.childrenMap();\n    if (map === undefined) {\n      return [];\n    }\n    return Array.from(map.byPropertyKey.values()).map((child) => untracked(child.reader)!);\n  }\n\n  /** Retrieve a child `FieldNode` of this node by property key. */\n  getChild(key: PropertyKey): FieldNode | undefined {\n    const strKey = key.toString();\n\n    // Lookup the computed reader for this key in `childrenMap`. This lookup doesn't need to be\n    // reactive since `childrenMap` guarantees it will always return the same `reader` for the same\n    // `key`, so long as that key exists.\n    let reader = untracked(this.childrenMap)?.byPropertyKey.get(strKey)?.reader;\n\n    if (!reader) {\n      // The key doesn't exist / doesn't have a child field associated with it. In this case, we\n      // need to be clever. We want to return `undefined`, but also be notified by reactivity if the\n      // field _does_ pop into existence later. Basically, we want to depend on a reader for a key\n      // that doesn't exist.\n      //\n      // We do precisely that by creating an ephemeral reader which will be read and then dropped.\n      // If we're in a reactive context, the ephemeral reader will live on in the dependencies of\n      // that context and notify it if the field is later created. When the reactive context reruns,\n      // it will again attempt the read which will call `getChild()`, which will then find the real\n      // reader for that key.\n      reader = this.createReader(strKey);\n    }\n\n    return reader();\n  }\n\n  /**\n   * Perform a reduction over a field's children (if any) and return the result.\n   *\n   * Optionally, the reduction is short circuited based on the provided `shortCircuit` function.\n   */\n  reduceChildren<T>(\n    initialValue: T,\n    fn: (child: FieldNode, value: T) => T,\n    shortCircuit?: (value: T) => boolean,\n  ): T {\n    const map = this.childrenMap();\n    if (!map) {\n      return initialValue;\n    }\n\n    let value = initialValue;\n    for (const child of map.byPropertyKey.values()) {\n      if (shortCircuit?.(value)) {\n        break;\n      }\n      value = fn(untracked(child.reader)!, value);\n    }\n    return value;\n  }\n\n  /** Destroys the field when it is no longer needed. */\n  destroy(): void {\n    this.injector.destroy();\n  }\n\n  /**\n   * Creates a keyInParent signal for a field node.\n   *\n   * For root nodes, returns ROOT_KEY_IN_PARENT which throws when accessed.\n   * For child nodes, creates a computed that tracks the field's current key in its parent,\n   * with special handling for tracked array elements.\n   *\n   * @param options The field node options\n   * @param identityInParent The tracking identity (only for tracked array children)\n   * @param initialKeyInParent The initial key in parent (only for child nodes)\n   * @returns A signal representing the field's key in its parent\n   */\n  protected createKeyInParent(\n    options: FieldNodeOptions,\n    identityInParent: TrackingKey | undefined,\n    initialKeyInParent: string | undefined,\n  ): Signal<string> {\n    if (options.kind === 'root') {\n      return ROOT_KEY_IN_PARENT;\n    }\n\n    if (identityInParent === undefined) {\n      const key = initialKeyInParent!;\n      return computed(() => {\n        if (this.parent!.structure.getChild(key) !== this.node) {\n          throw new RuntimeError(\n            RuntimeErrorCode.ORPHAN_FIELD_PROPERTY,\n            ngDevMode &&\n              `Orphan field, looking for property '${key}' of ${getDebugName(this.parent!)}`,\n          );\n        }\n        return key;\n      });\n    } else {\n      let lastKnownKey = initialKeyInParent!;\n      return computed(() => {\n        // TODO(alxhub): future perf optimization: here we depend on the parent's value, but most\n        // changes to the value aren't structural - they aren't moving around objects and thus\n        // shouldn't affect `keyInParent`. We currently mitigate this issue via `lastKnownKey`\n        // which avoids a search.\n        const parentValue = this.parent!.structure.value();\n        if (!isArray(parentValue)) {\n          // It should not be possible to encounter this error. It would require the parent to\n          // change from an array field to non-array field. However, in the current implementation\n          // a field's parent can never change.\n          throw new RuntimeError(\n            RuntimeErrorCode.ORPHAN_FIELD_ARRAY,\n            ngDevMode && `Orphan field, expected ${getDebugName(this.parent!)} to be an array`,\n          );\n        }\n\n        // Check the parent value at the last known key to avoid a scan.\n        // Note: lastKnownKey is a string, but we pretend to typescript like its a number,\n        // since accessing someArray['1'] is the same as accessing someArray[1]\n        const data = parentValue[lastKnownKey as unknown as number];\n        if (\n          isObject(data) &&\n          data.hasOwnProperty(this.parent!.structure.identitySymbol) &&\n          data[this.parent!.structure.identitySymbol] === identityInParent\n        ) {\n          return lastKnownKey;\n        }\n\n        // Otherwise, we need to check all the keys in the parent.\n        for (let i = 0; i < parentValue.length; i++) {\n          const data = parentValue[i];\n          if (\n            isObject(data) &&\n            data.hasOwnProperty(this.parent!.structure.identitySymbol) &&\n            data[this.parent!.structure.identitySymbol] === identityInParent\n          ) {\n            return (lastKnownKey = i.toString());\n          }\n        }\n\n        throw new RuntimeError(\n          RuntimeErrorCode.ORPHAN_FIELD_NOT_FOUND,\n          ngDevMode && `Orphan field, can't find element in array ${getDebugName(this.parent!)}`,\n        );\n      });\n    }\n  }\n\n  protected createChildrenMap(): Signal<ChildrenData | undefined> {\n    return linkedSignal({\n      source: this.value,\n      computation: (\n        value: unknown,\n        previous: {source: unknown; value: ChildrenData | undefined} | undefined,\n      ): ChildrenData | undefined => {\n        if (!isObject(value)) {\n          // Non-object values have no children. This short-circuit path makes `childrenMap` fast\n          // for primitive-valued fields.\n          return undefined;\n        }\n\n        // Previous `ChildrenData` (immutable). This is also where we first initialize our map if\n        // needed.\n        const prevData: ChildrenData = previous?.value ?? {\n          byPropertyKey: new Map(),\n        };\n\n        // The next `ChildrenData` object to be returned. Initialized lazily when we know there's\n        // been a structural change to the model.\n        let data: MutableChildrenData | undefined;\n\n        const parentIsArray = isArray(value);\n\n        // Remove fields that have disappeared since the last time this map was computed.\n        if (prevData !== undefined) {\n          if (parentIsArray) {\n            data = maybeRemoveStaleArrayFields(prevData, value, this.identitySymbol);\n          } else {\n            data = maybeRemoveStaleObjectFields(prevData, value);\n          }\n        }\n\n        // Now, go through the values and add any new ones.\n        for (const key of Object.keys(value)) {\n          let trackingKey: TrackingKey | undefined = undefined;\n          const childValue = value[key] as unknown;\n\n          // Fields explicitly set to `undefined` are treated as if they don't exist.\n          // This ensures that `{value: undefined}` and `{}` have the same behavior for their `value`\n          // field.\n          if (childValue === undefined) {\n            // The value might have _become_ `undefined`, so we need to delete it here.\n            if (prevData.byPropertyKey.has(key)) {\n              data ??= {...(prevData as MutableChildrenData)};\n              data.byPropertyKey.delete(key);\n            }\n            continue;\n          }\n\n          if (parentIsArray && isObject(childValue) && !isArray(childValue)) {\n            // For object values in arrays, assign a synthetic identity. This will be used to\n            // preserve the field instance even as this object moves around in the parent array.\n            trackingKey = (childValue[this.identitySymbol] as TrackingKey) ??= Symbol(\n              ngDevMode ? `id:${globalId++}` : '',\n            ) as TrackingKey;\n          }\n\n          let childNode: FieldNode | undefined;\n\n          if (trackingKey) {\n            // If tracking is in use, then the `FieldNode` instance is always managed via its\n            // tracking key. Create the instance if needed, or look it up otherwise.\n            if (!prevData.byTrackingKey?.has(trackingKey)) {\n              data ??= {...(prevData as MutableChildrenData)};\n              data.byTrackingKey ??= new Map();\n\n              data.byTrackingKey.set(\n                trackingKey,\n                this.createChildNode(key, trackingKey, parentIsArray),\n              );\n            }\n\n            // Note: data ?? prevData is needed because we might have freshly instantiated\n            // `byTrackingKey` only in `data` above.\n            childNode = (data ?? prevData).byTrackingKey!.get(trackingKey)!;\n          }\n\n          // Next, make sure the `ChildData` for this key in `byPropertyKey` is up to date. We need\n          // to consider two cases:\n          //\n          // 1. No record exists for this field (yet).\n          // 2. A record does exist, but the field identity at this key has changed (only possible\n          //    when fields are tracked).\n          const child = prevData.byPropertyKey.get(key);\n          if (child === undefined) {\n            // No record exists yet - create one.\n            data ??= {...(prevData as MutableChildrenData)};\n\n            data.byPropertyKey.set(key, {\n              // TODO: creating a computed per-key is overkill when the field at a key can't change\n              // (e.g. the value is not an array). Maybe this can be optimized?\n              reader: this.createReader(key),\n              // If tracking is in use, then it already created/found the `childNode` for this key.\n              // Otherwise we create the child field here.\n              node: childNode ?? this.createChildNode(key, trackingKey, parentIsArray),\n            });\n          } else if (childNode && childNode !== child.node) {\n            // A record exists, but records the wrong `FieldNode`. Update it.\n            data ??= {...(prevData as MutableChildrenData)};\n            child.node = childNode;\n          }\n        }\n\n        return data ?? prevData;\n      },\n    });\n  }\n\n  /**\n   * Creates a \"reader\" computed for the given key.\n   *\n   * A reader is a computed signal that memoizes the access of the `FieldNode` stored at this key\n   * (or returns `undefined` if no such field exists). Accessing fields via the reader ensures that\n   * reactive consumers aren't notified unless the field at a key actually changes.\n   */\n  private createReader(key: string): Signal<FieldNode | undefined> {\n    return computed(() => this.childrenMap()?.byPropertyKey.get(key)?.node);\n  }\n}\n\n/** The structural component of a `FieldNode` that is the root of its field tree. */\nexport class RootFieldNodeStructure extends FieldNodeStructure {\n  override get parent(): undefined {\n    return undefined;\n  }\n\n  override get root(): FieldNode {\n    return this.node;\n  }\n\n  override get pathKeys(): Signal<readonly string[]> {\n    return ROOT_PATH_KEYS;\n  }\n\n  override get keyInParent(): Signal<string> {\n    return ROOT_KEY_IN_PARENT;\n  }\n\n  protected override readonly childrenMap: Signal<ChildrenData | undefined>;\n\n  /**\n   * Creates the structure for the root node of a field tree.\n   *\n   * @param node The full field node that this structure belongs to\n   * @param pathNode The path corresponding to this node in the schema\n   * @param logic The logic to apply to this field\n   * @param fieldManager The field manager for this field\n   * @param value The value signal for this field\n   * @param adapter Adapter that knows how to create new fields and appropriate state.\n   * @param createChildNode A factory function to create child nodes for this field.\n   */\n  constructor(\n    /** The full field node that corresponds to this structure. */\n    node: FieldNode,\n    logic: LogicNode,\n    override readonly fieldManager: FormFieldManager,\n    override readonly value: WritableSignal<unknown>,\n    createChildNode: ChildNodeCtor,\n  ) {\n    super(logic, node, createChildNode);\n    this.childrenMap = this.createChildrenMap();\n  }\n}\n\n/** The structural component of a child `FieldNode` within a field tree. */\nexport class ChildFieldNodeStructure extends FieldNodeStructure {\n  override readonly root: FieldNode;\n  override readonly pathKeys: Signal<readonly string[]>;\n  override readonly keyInParent: Signal<string>;\n  override readonly value: WritableSignal<unknown>;\n  override readonly childrenMap: Signal<ChildrenData | undefined>;\n\n  override get fieldManager(): FormFieldManager {\n    return this.root.structure.fieldManager;\n  }\n\n  /**\n   * Creates the structure for a child field node in a field tree.\n   *\n   * @param node The full field node that this structure belongs to\n   * @param pathNode The path corresponding to this node in the schema\n   * @param logic The logic to apply to this field\n   * @param parent The parent field node for this node\n   * @param identityInParent The identity used to track this field in its parent\n   * @param initialKeyInParent The key of this field in its parent at the time of creation\n   * @param adapter Adapter that knows how to create new fields and appropriate state.\n   * @param createChildNode A factory function to create child nodes for this field.\n   */\n  constructor(\n    node: FieldNode,\n    override readonly logic: LogicNode,\n    override readonly parent: ParentFieldNode,\n    identityInParent: TrackingKey | undefined,\n    initialKeyInParent: string,\n    createChildNode: ChildNodeCtor,\n  ) {\n    super(logic, node, createChildNode);\n\n    this.root = this.parent.structure.root;\n\n    this.keyInParent = this.createKeyInParent(\n      {\n        kind: 'child',\n        parent,\n        pathNode: undefined!,\n        logic,\n        initialKeyInParent,\n        identityInParent,\n        fieldAdapter: undefined!,\n      },\n      identityInParent,\n      initialKeyInParent,\n    );\n\n    this.pathKeys = computed(() => [...parent.structure.pathKeys(), this.keyInParent()]);\n\n    this.value = deepSignal(this.parent.structure.value, this.keyInParent);\n    this.childrenMap = this.createChildrenMap();\n    this.fieldManager.structures.add(this);\n  }\n}\n\n/** Global id used for tracking keys. */\nlet globalId = 0;\n\n/** Options passed when constructing a root field node. */\nexport interface RootFieldNodeOptions {\n  /** Kind of node, used to differentiate root node options from child node options. */\n  readonly kind: 'root';\n  /** The path node corresponding to this field in the schema. */\n  readonly pathNode: FieldPathNode;\n  /** The logic to apply to this field. */\n  readonly logic: LogicNode;\n  /** The value signal for this field. */\n  readonly value: WritableSignal<unknown>;\n  /** The field manager for this field. */\n  readonly fieldManager: FormFieldManager;\n  /** This allows for more granular field and state management, and is currently used for compat. */\n  readonly fieldAdapter: FieldAdapter;\n}\n\n/** Options passed when constructing a child field node. */\nexport interface ChildFieldNodeOptions {\n  /** Kind of node, used to differentiate root node options from child node options. */\n  readonly kind: 'child';\n  /** The parent field node of this field. */\n  readonly parent: ParentFieldNode;\n  /** The path node corresponding to this field in the schema. */\n  readonly pathNode: FieldPathNode;\n  /** The logic to apply to this field. */\n  readonly logic: LogicNode;\n  /** The key of this field in its parent at the time of creation. */\n  readonly initialKeyInParent: string;\n  /** The identity used to track this field in its parent. */\n  readonly identityInParent: TrackingKey | undefined;\n  /** This allows for more granular field and state management, and is currently used for compat. */\n  readonly fieldAdapter: FieldAdapter;\n}\n\n/** Options passed when constructing a field node. */\nexport type FieldNodeOptions = RootFieldNodeOptions | ChildFieldNodeOptions;\n\n/** A signal representing an empty list of path keys, used for root fields. */\nconst ROOT_PATH_KEYS = computed<readonly string[]>(() => []);\n\n/**\n * A signal representing a non-existent key of the field in its parent, used for root fields which\n * do not have a parent. This signal will throw if it is read.\n */\nconst ROOT_KEY_IN_PARENT = computed(() => {\n  throw new RuntimeError(\n    RuntimeErrorCode.ROOT_FIELD_NO_PARENT,\n    ngDevMode && 'The top-level field in the form has no parent.',\n  );\n});\n\n/** Gets a human readable name for a field node for use in error messages. */\nfunction getDebugName(node: FieldNode) {\n  return `<root>.${node.structure.pathKeys().join('.')}`;\n}\n\ninterface MutableChildrenData {\n  readonly byPropertyKey: Map<string, ChildData>;\n  byTrackingKey?: Map<TrackingKey, FieldNode>;\n}\n\n/**\n * Derived data regarding child fields for a specific parent field.\n */\ninterface ChildrenData {\n  /**\n   * Tracks `ChildData` for each property key within the parent.\n   */\n  readonly byPropertyKey: ReadonlyMap<string, ChildData>;\n\n  /**\n   * Tracks the instance of child `FieldNode`s by their tracking key, which is always 1:1 with the\n   * fields, even if they move around in the parent.\n   */\n  readonly byTrackingKey?: ReadonlyMap<TrackingKey, FieldNode>;\n}\n\n/**\n * Data for a specific child within a parent.\n */\ninterface ChildData {\n  /**\n   * A computed signal to access the `FieldNode` currently stored at a specific key.\n   *\n   * Because this is a computed, it only updates whenever the `FieldNode` at that key changes.\n   * Because `ChildData` is always associated with a specific key via `ChildrenData.byPropertyKey`,\n   * this computed gives a stable way to watch the field stored for a given property and only\n   * receives notifications when that field changes.\n   */\n  readonly reader: Signal<FieldNode | undefined>;\n\n  /**\n   * The child `FieldNode` currently stored at this key.\n   */\n  node: FieldNode;\n}\n\nfunction maybeRemoveStaleArrayFields(\n  prevData: ChildrenData,\n  value: ReadonlyArray<unknown>,\n  identitySymbol: PropertyKey,\n): MutableChildrenData | undefined {\n  let data: MutableChildrenData | undefined;\n\n  // TODO: we should be able to optimize this diff away in the fast case where nothing has\n  // actually changed structurally.\n  const oldKeys = new Set(prevData.byPropertyKey.keys());\n  const oldTracking = new Set(prevData.byTrackingKey?.keys());\n\n  for (let i = 0; i < value.length; i++) {\n    const childValue = value[i];\n    oldKeys.delete(i.toString());\n    if (isObject(childValue) && childValue.hasOwnProperty(identitySymbol)) {\n      oldTracking.delete(childValue[identitySymbol] as TrackingKey);\n    }\n  }\n\n  // `oldKeys` and `oldTracking` now contain stale keys and tracking keys, respectively.\n  // Remove them from their corresponding maps.\n\n  if (oldKeys.size > 0) {\n    data ??= {...(prevData as MutableChildrenData)};\n    for (const key of oldKeys) {\n      data.byPropertyKey.delete(key);\n    }\n  }\n  if (oldTracking.size > 0) {\n    data ??= {...(prevData as MutableChildrenData)};\n    for (const id of oldTracking) {\n      data.byTrackingKey?.delete(id);\n    }\n  }\n\n  return data;\n}\n\nfunction maybeRemoveStaleObjectFields(\n  prevData: ChildrenData,\n  value: Record<PropertyKey, unknown>,\n): MutableChildrenData | undefined {\n  let data: MutableChildrenData | undefined;\n\n  // For objects, we diff a bit differently, and use the value to check whether an old\n  // property still exists on the object value.\n  for (const key of prevData.byPropertyKey.keys()) {\n    if (!value.hasOwnProperty(key)) {\n      data ??= {...(prevData as MutableChildrenData)};\n      data.byPropertyKey.delete(key);\n    }\n  }\n\n  return data;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, linkedSignal, Signal, signal, WritableSignal} from '@angular/core';\nimport {ValidationError} from '../api/rules/validation/validation_errors';\nimport type {FieldNode} from './node';\n\n/**\n * State of a `FieldNode` that's associated with form submission.\n */\nexport class FieldSubmitState {\n  /**\n   * Whether this field was directly submitted (as opposed to indirectly by a parent field being submitted)\n   * and is still in the process of submitting.\n   */\n  readonly selfSubmitting = signal<boolean>(false);\n\n  /** Submission errors that are associated with this field. */\n  readonly submissionErrors: WritableSignal<readonly ValidationError.WithFieldTree[]>;\n\n  constructor(private readonly node: FieldNode) {\n    this.submissionErrors = linkedSignal({\n      source: this.node.structure.value,\n      computation: () => [] as readonly ValidationError.WithFieldTree[],\n    });\n  }\n\n  /**\n   * Whether this form is currently in the process of being submitted.\n   * Either because the field was submitted directly, or because a parent field was submitted.\n   */\n  readonly submitting: Signal<boolean> = computed(() => {\n    return this.selfSubmitting() || (this.node.structure.parent?.submitting() ?? false);\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, linkedSignal, type Signal, untracked, type WritableSignal} from '@angular/core';\nimport type {FormField} from '../directive/form_field_directive';\nimport {\n  MAX,\n  MAX_LENGTH,\n  type MetadataKey,\n  MIN,\n  MIN_LENGTH,\n  PATTERN,\n  REQUIRED,\n} from '../api/rules/metadata';\nimport type {ValidationError} from '../api/rules/validation/validation_errors';\nimport type {DisabledReason, FieldContext, FieldState, FieldTree} from '../api/types';\nimport {DYNAMIC} from '../schema/logic';\nimport {LogicNode} from '../schema/logic_node';\nimport {FieldPathNode} from '../schema/path_node';\nimport {FieldNodeContext} from './context';\nimport type {FieldAdapter} from './field_adapter';\nimport type {FormFieldManager} from './manager';\nimport {FieldMetadataState} from './metadata';\nimport {FIELD_PROXY_HANDLER} from './proxy';\nimport {FieldNodeState} from './state';\nimport {\n  ChildFieldNodeStructure,\n  type FieldNodeOptions,\n  type FieldNodeStructure,\n  RootFieldNodeStructure,\n  type TrackingKey,\n} from './structure';\nimport {FieldSubmitState} from './submit';\nimport {ValidationState} from './validation';\n\n/**\n * Internal node in the form tree for a given field.\n *\n * Field nodes have several responsibilities:\n *  - They track instance state for the particular field (touched)\n *  - They compute signals for derived state (valid, disabled, etc) based on their associated\n *    `LogicNode`\n *  - They act as the public API for the field (they implement the `FieldState` interface)\n *  - They implement navigation of the form tree via `.parent` and `.getChild()`.\n *\n * This class is largely a wrapper that aggregates several smaller pieces that each manage a subset of\n * the responsibilities.\n */\nexport class FieldNode implements FieldState<unknown> {\n  readonly structure: FieldNodeStructure;\n  readonly validationState: ValidationState;\n  readonly metadataState: FieldMetadataState;\n  readonly nodeState: FieldNodeState;\n  readonly submitState: FieldSubmitState;\n  readonly fieldAdapter: FieldAdapter;\n  readonly controlValue: WritableSignal<unknown>;\n\n  private _context: FieldContext<unknown> | undefined = undefined;\n  get context(): FieldContext<unknown> {\n    return (this._context ??= new FieldNodeContext(this));\n  }\n\n  /**\n   * Proxy to this node which allows navigation of the form graph below it.\n   */\n  readonly fieldProxy = new Proxy(() => this, FIELD_PROXY_HANDLER) as unknown as FieldTree<any>;\n  private readonly pathNode: FieldPathNode;\n\n  constructor(options: FieldNodeOptions) {\n    this.pathNode = options.pathNode;\n    this.fieldAdapter = options.fieldAdapter;\n    this.structure = this.fieldAdapter.createStructure(this, options);\n    this.validationState = this.fieldAdapter.createValidationState(this, options);\n    this.nodeState = this.fieldAdapter.createNodeState(this, options);\n    this.metadataState = new FieldMetadataState(this);\n    this.submitState = new FieldSubmitState(this);\n    this.controlValue = this.controlValueSignal();\n  }\n\n  focusBoundControl(options?: FocusOptions): void {\n    this.getBindingForFocus()?.focus(options);\n  }\n\n  /**\n   * Gets the Field directive binding that should be focused when the developer calls\n   * `focusBoundControl` on this node.\n   *\n   * This will prioritize focusable bindings to this node, and if multiple exist, it will return\n   * the first one in the DOM. If no focusable bindings exist on this node, it will return the\n   * first focusable binding in the DOM for any descendant node of this one.\n   */\n  private getBindingForFocus():\n    | (FormField<unknown> & {focus: (options?: FocusOptions) => void})\n    | undefined {\n    // First try to focus one of our own bindings.\n    const own = this.formFieldBindings()\n      .filter(\n        (b): b is FormField<unknown> & {focus: (options?: FocusOptions) => void} =>\n          b.focus !== undefined,\n      )\n      .reduce(\n        firstInDom<FormField<unknown> & {focus: (options?: FocusOptions) => void}>,\n        undefined,\n      );\n    if (own) return own;\n    // Fallback to focusing the bound control for one of our children.\n    return this.structure\n      .children()\n      .map((child) => child.getBindingForFocus())\n      .reduce(firstInDom, undefined);\n  }\n\n  /**\n   * The `AbortController` for the currently debounced sync, or `undefined` if there is none.\n   *\n   * This is used to cancel a pending debounced sync when {@link setControlValue} is called again\n   * before the pending debounced sync resolves. It will also cancel any pending debounced sync\n   * automatically when recomputed due to `value` being set directly from others sources.\n   */\n  private readonly pendingSync: WritableSignal<AbortController | undefined> = linkedSignal({\n    source: () => this.value(),\n    computation: (_source, previous) => {\n      previous?.value?.abort();\n      return undefined;\n    },\n  });\n\n  get logicNode(): LogicNode {\n    return this.structure.logic;\n  }\n\n  get value(): WritableSignal<unknown> {\n    return this.structure.value;\n  }\n\n  get keyInParent(): Signal<string | number> {\n    return this.structure.keyInParent;\n  }\n\n  get errors(): Signal<ValidationError.WithFieldTree[]> {\n    return this.validationState.errors;\n  }\n\n  get parseErrors(): Signal<ValidationError.WithFormField[]> {\n    return this.validationState.parseErrors;\n  }\n\n  get errorSummary(): Signal<ValidationError.WithFieldTree[]> {\n    return this.validationState.errorSummary;\n  }\n\n  get pending(): Signal<boolean> {\n    return this.validationState.pending;\n  }\n\n  get valid(): Signal<boolean> {\n    return this.validationState.valid;\n  }\n\n  get invalid(): Signal<boolean> {\n    return this.validationState.invalid;\n  }\n\n  get dirty(): Signal<boolean> {\n    return this.nodeState.dirty;\n  }\n\n  get touched(): Signal<boolean> {\n    return this.nodeState.touched;\n  }\n\n  get disabled(): Signal<boolean> {\n    return this.nodeState.disabled;\n  }\n\n  get disabledReasons(): Signal<readonly DisabledReason[]> {\n    return this.nodeState.disabledReasons;\n  }\n\n  get hidden(): Signal<boolean> {\n    return this.nodeState.hidden;\n  }\n\n  get readonly(): Signal<boolean> {\n    return this.nodeState.readonly;\n  }\n\n  get formFieldBindings(): Signal<readonly FormField<unknown>[]> {\n    return this.nodeState.formFieldBindings;\n  }\n\n  get submitting(): Signal<boolean> {\n    return this.submitState.submitting;\n  }\n\n  get name(): Signal<string> {\n    return this.nodeState.name;\n  }\n\n  get max(): Signal<number | undefined> | undefined {\n    return this.metadata(MAX);\n  }\n\n  get maxLength(): Signal<number | undefined> | undefined {\n    return this.metadata(MAX_LENGTH);\n  }\n\n  get min(): Signal<number | undefined> | undefined {\n    return this.metadata(MIN);\n  }\n\n  get minLength(): Signal<number | undefined> | undefined {\n    return this.metadata(MIN_LENGTH);\n  }\n\n  get pattern(): Signal<readonly RegExp[]> {\n    return this.metadata(PATTERN) ?? EMPTY;\n  }\n\n  get required(): Signal<boolean> {\n    return this.metadata(REQUIRED) ?? FALSE;\n  }\n\n  metadata<M>(key: MetadataKey<M, any, any>): M | undefined {\n    return this.metadataState.get(key);\n  }\n\n  hasMetadata(key: MetadataKey<any, any, any>): boolean {\n    return this.metadataState.has(key);\n  }\n\n  /**\n   * Marks this specific field as touched.\n   */\n  markAsTouched(): void {\n    untracked(() => {\n      this.nodeState.markAsTouched();\n      this.flushSync();\n    });\n  }\n\n  /**\n   * Marks this specific field as dirty.\n   */\n  markAsDirty(): void {\n    this.nodeState.markAsDirty();\n  }\n\n  /**\n   * Marks this specific field as pristine.\n   */\n  markAsPristine(): void {\n    this.nodeState.markAsPristine();\n  }\n\n  /**\n   * Marks this specific field as untouched.\n   */\n  markAsUntouched(): void {\n    this.nodeState.markAsUntouched();\n  }\n\n  /**\n   * Resets the {@link touched} and {@link dirty} state of the field and its descendants.\n   *\n   * Note this does not change the data model, which can be reset directly if desired.\n   *\n   * @param value Optional value to set to the form. If not passed, the value will not be changed.\n   */\n  reset(value?: unknown): void {\n    untracked(() => this._reset(value));\n  }\n\n  private _reset(value?: unknown) {\n    if (value !== undefined) {\n      this.value.set(value);\n    }\n\n    this.nodeState.markAsUntouched();\n    this.nodeState.markAsPristine();\n\n    for (const child of this.structure.children()) {\n      child._reset();\n    }\n  }\n\n  /**\n   * Creates a linked signal that initiates a {@link debounceSync} when set.\n   */\n  private controlValueSignal(): WritableSignal<unknown> {\n    const controlValue = linkedSignal(this.value);\n    const {set, update} = controlValue;\n\n    controlValue.set = (newValue) => {\n      set(newValue);\n      this.markAsDirty();\n      this.debounceSync();\n    };\n    controlValue.update = (updateFn) => {\n      update(updateFn);\n      this.markAsDirty();\n      this.debounceSync();\n    };\n\n    return controlValue;\n  }\n\n  /**\n   * Synchronizes the {@link controlValue} with the {@link value} signal immediately.\n   */\n  private sync() {\n    this.value.set(this.controlValue());\n  }\n\n  /**\n   * If there is a pending sync, abort it and sync immediately.\n   */\n  private flushSync() {\n    const pending = this.pendingSync();\n    if (pending && !pending.signal.aborted) {\n      pending.abort();\n      this.sync();\n    }\n  }\n\n  /**\n   * Initiates a debounced {@link sync}.\n   *\n   * If a debouncer is configured, the synchronization will occur after the debouncer resolves. If\n   * no debouncer is configured, the synchronization happens immediately. If {@link controlValue} is\n   * updated again while a debounce is pending, the previous debounce operation is aborted in favor\n   * of the new one.\n   */\n  private async debounceSync() {\n    const debouncer = untracked(() => {\n      this.pendingSync()?.abort();\n      return this.nodeState.debouncer();\n    });\n\n    if (debouncer) {\n      const controller = new AbortController();\n      const promise = debouncer(controller.signal);\n      if (promise) {\n        this.pendingSync.set(controller);\n        await promise;\n        if (controller.signal.aborted) {\n          return; // Do not sync if the debounce was aborted.\n        }\n      }\n    }\n\n    this.sync();\n  }\n\n  /**\n   * Creates a new root field node for a new form.\n   */\n  static newRoot<T>(\n    fieldManager: FormFieldManager,\n    value: WritableSignal<T>,\n    pathNode: FieldPathNode,\n    adapter: FieldAdapter,\n  ): FieldNode {\n    return adapter.newRoot(fieldManager, value, pathNode, adapter);\n  }\n\n  createStructure(options: FieldNodeOptions) {\n    return options.kind === 'root'\n      ? new RootFieldNodeStructure(\n          this,\n          options.logic,\n          options.fieldManager,\n          options.value,\n          this.newChild.bind(this),\n        )\n      : new ChildFieldNodeStructure(\n          this,\n          options.logic,\n          options.parent,\n          options.identityInParent,\n          options.initialKeyInParent,\n          this.newChild.bind(this),\n        );\n  }\n\n  private newChild(key: string, trackingId: TrackingKey | undefined, isArray: boolean): FieldNode {\n    // Determine the logic for the field that we're defining.\n    let childPath: FieldPathNode | undefined;\n    let childLogic: LogicNode;\n    if (isArray) {\n      // Fields for array elements have their logic defined by the `element` mechanism.\n      // TODO: other dynamic data\n      childPath = this.pathNode.getChild(DYNAMIC);\n      childLogic = this.structure.logic.getChild(DYNAMIC);\n    } else {\n      // Fields for plain properties exist in our logic node's child map.\n      childPath = this.pathNode.getChild(key);\n      childLogic = this.structure.logic.getChild(key);\n    }\n\n    return this.fieldAdapter.newChild({\n      kind: 'child',\n      parent: this as ParentFieldNode,\n      pathNode: childPath,\n      logic: childLogic,\n      initialKeyInParent: key,\n      identityInParent: trackingId,\n      fieldAdapter: this.fieldAdapter,\n    });\n  }\n}\n\nconst EMPTY = computed(() => []);\nconst FALSE = computed(() => false);\n\n/**\n * Field node of a field that has children.\n * This simplifies and makes certain types cleaner.\n */\nexport interface ParentFieldNode extends FieldNode {\n  readonly value: WritableSignal<Record<string, unknown>>;\n  readonly structure: FieldNodeStructure & {value: WritableSignal<Record<string, unknown>>};\n}\n\n/** Given two elements, returns the one that appears earlier in the DOM. */\nfunction firstInDom<T extends FormField<unknown>>(\n  a: T | undefined,\n  b: T | undefined,\n): T | undefined {\n  if (!a) return b;\n  if (!b) return a;\n  const position = a.element.compareDocumentPosition(b.element);\n  return position & Node.DOCUMENT_POSITION_PRECEDING ? b : a;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal, Signal} from '@angular/core';\nimport type {FormField} from '../directive/form_field_directive';\nimport type {Debouncer, DisabledReason} from '../api/types';\nimport {DEBOUNCER} from './debounce';\nimport type {FieldNode} from './node';\nimport {shortCircuitTrue} from './util';\n\n/**\n * The non-validation and non-submit state associated with a `FieldNode`, such as touched and dirty\n * status, as well as derived logical state.\n */\nexport class FieldNodeState {\n  /**\n   * Indicates whether this field has been touched directly by the user (as opposed to indirectly by\n   * touching a child field).\n   *\n   * A field is considered directly touched when a user stops editing it for the first time (i.e. on blur)\n   */\n  private readonly selfTouched = signal(false);\n\n  /**\n   * Indicates whether this field has been dirtied directly by the user (as opposed to indirectly by\n   * dirtying a child field).\n   *\n   * A field is considered directly dirtied if a user changed the value of the field at least once.\n   */\n  private readonly selfDirty = signal(false);\n\n  /**\n   * Marks this specific field as touched.\n   */\n  markAsTouched(): void {\n    this.selfTouched.set(true);\n  }\n\n  /**\n   * Marks this specific field as dirty.\n   */\n  markAsDirty(): void {\n    this.selfDirty.set(true);\n  }\n\n  /**\n   * Marks this specific field as not dirty.\n   */\n  markAsPristine(): void {\n    this.selfDirty.set(false);\n  }\n\n  /**\n   * Marks this specific field as not touched.\n   */\n  markAsUntouched(): void {\n    this.selfTouched.set(false);\n  }\n\n  /** The {@link FormField} directives that bind this field to a UI control. */\n  readonly formFieldBindings = signal<readonly FormField<unknown>[]>([]);\n\n  constructor(private readonly node: FieldNode) {}\n\n  /**\n   * Whether this field is considered dirty.\n   *\n   * A field is considered dirty if one of the following is true:\n   *  - It was directly dirtied and is interactive\n   *  - One of its children is considered dirty\n   */\n  readonly dirty: Signal<boolean> = computed(() => {\n    const selfDirtyValue = this.selfDirty() && !this.isNonInteractive();\n    return this.node.structure.reduceChildren(\n      selfDirtyValue,\n      (child, value) => value || child.nodeState.dirty(),\n      shortCircuitTrue,\n    );\n  });\n\n  /**\n   * Whether this field is considered touched.\n   *\n   * A field is considered touched if one of the following is true:\n   *  - It was directly touched and is interactive\n   *  - One of its children is considered touched\n   */\n  readonly touched: Signal<boolean> = computed(() => {\n    const selfTouchedValue = this.selfTouched() && !this.isNonInteractive();\n    return this.node.structure.reduceChildren(\n      selfTouchedValue,\n      (child, value) => value || child.nodeState.touched(),\n      shortCircuitTrue,\n    );\n  });\n\n  /**\n   * The reasons for this field's disablement. This includes disabled reasons for any parent field\n   * that may have been disabled, indirectly causing this field to be disabled as well.\n   * The `field` property of the `DisabledReason` can be used to determine which field ultimately\n   * caused the disablement.\n   */\n  readonly disabledReasons: Signal<readonly DisabledReason[]> = computed(() => [\n    ...(this.node.structure.parent?.nodeState.disabledReasons() ?? []),\n    ...this.node.logicNode.logic.disabledReasons.compute(this.node.context),\n  ]);\n\n  /**\n   * Whether this field is considered disabled.\n   *\n   * A field is considered disabled if one of the following is true:\n   * - The schema contains logic that directly disabled it\n   * - Its parent field is considered disabled\n   */\n  readonly disabled: Signal<boolean> = computed(() => !!this.disabledReasons().length);\n\n  /**\n   * Whether this field is considered readonly.\n   *\n   * A field is considered readonly if one of the following is true:\n   * - The schema contains logic that directly made it readonly\n   * - Its parent field is considered readonly\n   */\n  readonly readonly: Signal<boolean> = computed(\n    () =>\n      (this.node.structure.parent?.nodeState.readonly() ||\n        this.node.logicNode.logic.readonly.compute(this.node.context)) ??\n      false,\n  );\n\n  /**\n   * Whether this field is considered hidden.\n   *\n   * A field is considered hidden if one of the following is true:\n   * - The schema contains logic that directly hides it\n   * - Its parent field is considered hidden\n   */\n  readonly hidden: Signal<boolean> = computed(\n    () =>\n      (this.node.structure.parent?.nodeState.hidden() ||\n        this.node.logicNode.logic.hidden.compute(this.node.context)) ??\n      false,\n  );\n\n  readonly name: Signal<string> = computed(() => {\n    const parent = this.node.structure.parent;\n    if (!parent) {\n      return this.node.structure.fieldManager.rootName;\n    }\n\n    return `${parent.name()}.${this.node.structure.keyInParent()}`;\n  });\n\n  /**\n   * An optional {@link Debouncer} factory for this field.\n   */\n  readonly debouncer: Signal<((signal: AbortSignal) => Promise<void> | void) | undefined> =\n    computed(() => {\n      if (this.node.logicNode.logic.hasMetadata(DEBOUNCER)) {\n        const debouncerLogic = this.node.logicNode.logic.getMetadata(DEBOUNCER);\n        const debouncer = debouncerLogic.compute(this.node.context);\n\n        // Even if this field has a `debounce()` rule, it could be applied conditionally and currently\n        // inactive, in which case `compute()` will return undefined.\n        if (debouncer) {\n          return (signal) => debouncer(this.node.context, signal);\n        }\n      }\n\n      // Fallback to the parent's debouncer, if any. If there is no debouncer configured all the way\n      // up to the root field, this simply returns `undefined` indicating that the operation should\n      // not be debounced.\n      return this.node.structure.parent?.nodeState.debouncer?.();\n    });\n\n  /** Whether this field is considered non-interactive.\n   *\n   * A field is considered non-interactive if one of the following is true:\n   * - It is hidden\n   * - It is disabled\n   * - It is readonly\n   */\n  private readonly isNonInteractive = computed(\n    () => this.hidden() || this.disabled() || this.readonly(),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {FieldPathNode} from '../schema/path_node';\n\nimport {WritableSignal} from '@angular/core';\nimport {FormFieldManager} from './manager';\nimport {FieldNode} from './node';\nimport {FieldNodeState} from './state';\nimport {ChildFieldNodeOptions, FieldNodeOptions, FieldNodeStructure} from './structure';\nimport {FieldValidationState, ValidationState} from './validation';\n\n/**\n * Adapter allowing customization of the creation logic for a field and its associated\n * structure and state.\n */\nexport interface FieldAdapter {\n  /**\n   * Creates a node structure.\n   * @param node\n   * @param options\n   */\n  createStructure(node: FieldNode, options: FieldNodeOptions): FieldNodeStructure;\n\n  /**\n   * Creates node validation state\n   * @param param\n   * @param options\n   */\n  createValidationState(param: FieldNode, options: FieldNodeOptions): ValidationState;\n\n  /**\n   * Creates node state.\n   * @param param\n   * @param options\n   */\n  createNodeState(param: FieldNode, options: FieldNodeOptions): FieldNodeState;\n\n  /**\n   * Creates a custom child node.\n   * @param options\n   */\n  newChild(options: ChildFieldNodeOptions): FieldNode;\n\n  /**\n   * Creates a custom root node.\n   * @param fieldManager\n   * @param model\n   * @param pathNode\n   * @param adapter\n   */\n  newRoot<TValue>(\n    fieldManager: FormFieldManager,\n    model: WritableSignal<TValue>,\n    pathNode: FieldPathNode,\n    adapter: FieldAdapter,\n  ): FieldNode;\n}\n\n/**\n * Basic adapter supporting standard form behavior.\n */\nexport class BasicFieldAdapter implements FieldAdapter {\n  /**\n   * Creates a new Root field node.\n   * @param fieldManager\n   * @param value\n   * @param pathNode\n   * @param adapter\n   */\n  newRoot<TValue>(\n    fieldManager: FormFieldManager,\n    value: WritableSignal<TValue>,\n    pathNode: FieldPathNode,\n    adapter: FieldAdapter,\n  ): FieldNode {\n    return new FieldNode({\n      kind: 'root',\n      fieldManager,\n      value,\n      pathNode,\n      logic: pathNode.builder.build(),\n      fieldAdapter: adapter,\n    });\n  }\n\n  /**\n   * Creates a new child field node.\n   * @param options\n   */\n  newChild(options: ChildFieldNodeOptions): FieldNode {\n    return new FieldNode(options);\n  }\n\n  /**\n   * Creates a node state.\n   * @param node\n   */\n  createNodeState(node: FieldNode): FieldNodeState {\n    return new FieldNodeState(node);\n  }\n\n  /**\n   * Creates a validation state.\n   * @param node\n   */\n  createValidationState(node: FieldNode): ValidationState {\n    return new FieldValidationState(node);\n  }\n\n  /**\n   * Creates a node structure.\n   * @param node\n   * @param options\n   */\n  createStructure(node: FieldNode, options: FieldNodeOptions): FieldNodeStructure {\n    return node.createStructure(options);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {APP_ID, effect, Injector, untracked} from '@angular/core';\nimport type {FieldNodeStructure} from './structure';\n\n/**\n * Manages the collection of fields associated with a given `form`.\n *\n * Fields are created implicitly, through reactivity, and may create \"owned\" entities like effects\n * or resources. When a field is no longer connected to the form, these owned entities should be\n * destroyed, which is the job of the `FormFieldManager`.\n */\nexport class FormFieldManager {\n  readonly rootName: string;\n  constructor(\n    readonly injector: Injector,\n    rootName: string | undefined,\n  ) {\n    this.rootName = rootName ?? `${this.injector.get(APP_ID)}.form${nextFormId++}`;\n  }\n\n  /**\n   * Contains all child field structures that have been created as part of the current form.\n   * New child structures are automatically added when they are created.\n   * Structures are destroyed and removed when they are no longer reachable from the root.\n   */\n  readonly structures = new Set<FieldNodeStructure>();\n\n  /**\n   * Creates an effect that runs when the form's structure changes and checks for structures that\n   * have become unreachable to clean up.\n   *\n   * For example, consider a form wrapped around the following model: `signal([0, 1, 2])`.\n   * This form would have 4 nodes as part of its structure tree.\n   * One structure for the root array, and one structure for each element of the array.\n   * Now imagine the data is updated: `model.set([0])`. In this case the structure for the first\n   * element can still be reached from the root, but the structures for the second and third\n   * elements are now orphaned and not connected to the root. Thus they will be destroyed.\n   *\n   * @param root The root field structure.\n   */\n  createFieldManagementEffect(root: FieldNodeStructure): void {\n    effect(\n      () => {\n        const liveStructures = new Set<FieldNodeStructure>();\n        this.markStructuresLive(root, liveStructures);\n\n        // Destroy all nodes that are no longer live.\n        for (const structure of this.structures) {\n          if (!liveStructures.has(structure)) {\n            this.structures.delete(structure);\n            untracked(() => structure.destroy());\n          }\n        }\n      },\n      {injector: this.injector},\n    );\n  }\n\n  /**\n   * Collects all structures reachable from the given structure into the given set.\n   *\n   * @param structure The root structure\n   * @param liveStructures The set of reachable structures to populate\n   */\n  private markStructuresLive(\n    structure: FieldNodeStructure,\n    liveStructures: Set<FieldNodeStructure>,\n  ): void {\n    liveStructures.add(structure);\n    for (const child of structure.children()) {\n      this.markStructuresLive(child.structure, liveStructures);\n    }\n  }\n}\n\nlet nextFormId = 0;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {WritableSignal} from '@angular/core';\nimport type {SchemaOrSchemaFn} from '../api/types';\nimport type {FormOptions} from '../api/structure';\nimport {isSchemaOrSchemaFn} from '../schema/schema';\n\n/**\n * Extracts the model, schema, and options from the arguments passed to `form()`.\n */\nexport function normalizeFormArgs<TModel>(\n  args: any[],\n): [WritableSignal<TModel>, SchemaOrSchemaFn<TModel> | undefined, FormOptions | undefined] {\n  let model: WritableSignal<TModel>;\n  let schema: SchemaOrSchemaFn<TModel> | undefined;\n  let options: FormOptions | undefined;\n\n  if (args.length === 3) {\n    [model, schema, options] = args;\n  } else if (args.length === 2) {\n    if (isSchemaOrSchemaFn(args[1])) {\n      [model, schema] = args;\n    } else {\n      [model, options] = args;\n    }\n  } else {\n    [model] = args;\n  }\n\n  return [model, schema, options];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injector, runInInjectionContext, untracked, WritableSignal} from '@angular/core';\n\nimport {BasicFieldAdapter, FieldAdapter} from '../field/field_adapter';\nimport {FormFieldManager} from '../field/manager';\nimport {FieldNode} from '../field/node';\nimport {addDefaultField} from '../field/validation';\nimport {DYNAMIC} from '../schema/logic';\nimport {FieldPathNode} from '../schema/path_node';\nimport {assertPathIsCurrent, SchemaImpl} from '../schema/schema';\nimport {normalizeFormArgs} from '../util/normalize_form_args';\nimport {isArray} from '../util/type_guards';\nimport type {ValidationError} from './rules/validation/validation_errors';\nimport type {\n  FieldTree,\n  ItemType,\n  LogicFn,\n  OneOrMany,\n  PathKind,\n  Schema,\n  SchemaFn,\n  SchemaOrSchemaFn,\n  SchemaPath,\n  TreeValidationResult,\n} from './types';\n\n/**\n * Options that may be specified when creating a form.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport interface FormOptions {\n  /**\n   * The injector to use for dependency injection. If this is not provided, the injector for the\n   * current [injection context](guide/di/dependency-injection-context), will be used.\n   */\n  injector?: Injector;\n  name?: string;\n\n  /**\n   * Adapter allows managing fields in a more flexible way.\n   * Currently this is used to support interop with reactive forms.\n   */\n  adapter?: FieldAdapter;\n}\n\n/**\n * Creates a form wrapped around the given model data. A form is represented as simply a `FieldTree`\n * of the model data.\n *\n * `form` uses the given model as the source of truth and *does not* maintain its own copy of the\n * data. This means that updating the value on a `FieldState` updates the originally passed in model\n * as well.\n *\n * @example\n * ```ts\n * const nameModel = signal({first: '', last: ''});\n * const nameForm = form(nameModel);\n * nameForm.first().value.set('John');\n * nameForm().value(); // {first: 'John', last: ''}\n * nameModel(); // {first: 'John', last: ''}\n * ```\n *\n * @param model A writable signal that contains the model data for the form. The resulting field\n * structure will match the shape of the model and any changes to the form data will be written to\n * the model.\n * @return A `FieldTree` representing a form around the data model.\n * @template TModel The type of the data model.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function form<TModel>(model: WritableSignal<TModel>): FieldTree<TModel>;\n\n/**\n * Creates a form wrapped around the given model data. A form is represented as simply a `FieldTree`\n * of the model data.\n *\n * `form` uses the given model as the source of truth and *does not* maintain its own copy of the\n * data. This means that updating the value on a `FieldState` updates the originally passed in model\n * as well.\n *\n * @example\n * ```ts\n * const nameModel = signal({first: '', last: ''});\n * const nameForm = form(nameModel);\n * nameForm.first().value.set('John');\n * nameForm().value(); // {first: 'John', last: ''}\n * nameModel(); // {first: 'John', last: ''}\n * ```\n *\n * The form can also be created with a schema, which is a set of rules that define the logic for the\n * form. The schema can be either a pre-defined schema created with the `schema` function, or a\n * function that builds the schema by binding logic to a parts of the field structure.\n *\n * @example\n * ```ts\n * const nameForm = form(signal({first: '', last: ''}), (name) => {\n *   required(name.first);\n *   pattern(name.last, /^[a-z]+$/i, {message: 'Alphabet characters only'});\n * });\n * nameForm().valid(); // false\n * nameForm().value.set({first: 'John', last: 'Doe'});\n * nameForm().valid(); // true\n * ```\n *\n * @param model A writable signal that contains the model data for the form. The resulting field\n * structure will match the shape of the model and any changes to the form data will be written to\n * the model.\n * @param schemaOrOptions The second argument can be either\n *   1. A schema or a function used to specify logic for the form (e.g. validation, disabled fields, etc.).\n *      When passing a schema, the form options can be passed as a third argument if needed.\n *   2. The form options\n * @return A `FieldTree` representing a form around the data model\n * @template TValue The type of the data model.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function form<TModel>(\n  model: WritableSignal<TModel>,\n  schemaOrOptions: SchemaOrSchemaFn<TModel> | FormOptions,\n): FieldTree<TModel>;\n\n/**\n * Creates a form wrapped around the given model data. A form is represented as simply a `FieldTree`\n * of the model data.\n *\n * `form` uses the given model as the source of truth and *does not* maintain its own copy of the\n * data. This means that updating the value on a `FieldState` updates the originally passed in model\n * as well.\n *\n * @example\n * ```ts\n * const nameModel = signal({first: '', last: ''});\n * const nameForm = form(nameModel);\n * nameForm.first().value.set('John');\n * nameForm().value(); // {first: 'John', last: ''}\n * nameModel(); // {first: 'John', last: ''}\n * ```\n *\n * The form can also be created with a schema, which is a set of rules that define the logic for the\n * form. The schema can be either a pre-defined schema created with the `schema` function, or a\n * function that builds the schema by binding logic to a parts of the field structure.\n *\n * @example\n * ```ts\n * const nameForm = form(signal({first: '', last: ''}), (name) => {\n *   required(name.first);\n *   validate(name.last, ({value}) => !/^[a-z]+$/i.test(value()) ? {kind: 'alphabet-only'} : undefined);\n * });\n * nameForm().valid(); // false\n * nameForm().value.set({first: 'John', last: 'Doe'});\n * nameForm().valid(); // true\n * ```\n *\n * @param model A writable signal that contains the model data for the form. The resulting field\n * structure will match the shape of the model and any changes to the form data will be written to\n * the model.\n * @param schema A schema or a function used to specify logic for the form (e.g. validation, disabled fields, etc.)\n * @param options The form options\n * @return A `FieldTree` representing a form around the data model.\n * @template TModel The type of the data model.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function form<TModel>(\n  model: WritableSignal<TModel>,\n  schema: SchemaOrSchemaFn<TModel>,\n  options: FormOptions,\n): FieldTree<TModel>;\n\nexport function form<TModel>(...args: any[]): FieldTree<TModel> {\n  const [model, schema, options] = normalizeFormArgs<TModel>(args);\n  const injector = options?.injector ?? inject(Injector);\n  const pathNode = runInInjectionContext(injector, () => SchemaImpl.rootCompile(schema));\n  const fieldManager = new FormFieldManager(injector, options?.name);\n  const adapter = options?.adapter ?? new BasicFieldAdapter();\n  const fieldRoot = FieldNode.newRoot(fieldManager, model, pathNode, adapter);\n  fieldManager.createFieldManagementEffect(fieldRoot.structure);\n\n  return fieldRoot.fieldProxy as FieldTree<TModel>;\n}\n\n/**\n * Applies a schema to each item of an array.\n *\n * @example\n * ```ts\n * const nameSchema = schema<{first: string, last: string}>((name) => {\n *   required(name.first);\n *   required(name.last);\n * });\n * const namesForm = form(signal([{first: '', last: ''}]), (names) => {\n *   applyEach(names, nameSchema);\n * });\n * ```\n *\n * @param path The target path for an array field whose items the schema will be applied to.\n * @param schema A schema for an element of the array, or function that binds logic to an\n * element of the array.\n * @template TValue The data type of the item field to apply the schema to.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function applyEach<TValue extends ReadonlyArray<any>>(\n  path: SchemaPath<TValue>,\n  schema: NoInfer<SchemaOrSchemaFn<TValue[number], PathKind.Item>>,\n): void;\nexport function applyEach<TValue extends Object>(\n  path: SchemaPath<TValue>,\n  schema: NoInfer<SchemaOrSchemaFn<ItemType<TValue>, PathKind.Child>>,\n): void;\nexport function applyEach<TValue extends Object>(\n  path: SchemaPath<TValue>,\n  schema: NoInfer<SchemaOrSchemaFn<ItemType<TValue>, PathKind.Item>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const elementPath = FieldPathNode.unwrapFieldPath(path).getChild(DYNAMIC).fieldPathProxy;\n  apply(elementPath, schema as Schema<TValue>);\n}\n\n/**\n * Applies a predefined schema to a given `FieldPath`.\n *\n * @example\n * ```ts\n * const nameSchema = schema<{first: string, last: string}>((name) => {\n *   required(name.first);\n *   required(name.last);\n * });\n * const profileForm = form(signal({name: {first: '', last: ''}, age: 0}), (profile) => {\n *   apply(profile.name, nameSchema);\n * });\n * ```\n *\n * @param path The target path to apply the schema to.\n * @param schema The schema to apply to the property\n * @template TValue The data type of the field to apply the schema to.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function apply<TValue>(\n  path: SchemaPath<TValue>,\n  schema: NoInfer<SchemaOrSchemaFn<TValue>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.mergeIn(SchemaImpl.create(schema));\n}\n\n/**\n * Conditionally applies a predefined schema to a given `FieldPath`.\n *\n * @param path The target path to apply the schema to.\n * @param logic A `LogicFn<T, boolean>` that returns `true` when the schema should be applied.\n * @param schema The schema to apply to the field when the `logic` function returns `true`.\n * @template TValue The data type of the field to apply the schema to.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function applyWhen<TValue>(\n  path: SchemaPath<TValue>,\n  logic: LogicFn<TValue, boolean>,\n  schema: NoInfer<SchemaOrSchemaFn<TValue>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.mergeIn(SchemaImpl.create(schema), {fn: logic, path});\n}\n\n/**\n * Conditionally applies a predefined schema to a given `FieldPath`.\n *\n * @param path The target path to apply the schema to.\n * @param predicate A type guard that accepts a value `T` and returns `true` if `T` is of type\n *   `TNarrowed`.\n * @param schema The schema to apply to the field when `predicate` returns `true`.\n * @template TValue The data type of the field to apply the schema to.\n * @template TNarrowed The data type of the schema (a narrowed type of TValue).\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function applyWhenValue<TValue, TNarrowed extends TValue>(\n  path: SchemaPath<TValue>,\n  predicate: (value: TValue) => value is TNarrowed,\n  schema: SchemaOrSchemaFn<TNarrowed>,\n): void;\n\n/**\n * Conditionally applies a predefined schema to a given `FieldPath`.\n *\n * @param path The target path to apply the schema to.\n * @param predicate A function that accepts a value `T` and returns `true` when the schema\n *   should be applied.\n * @param schema The schema to apply to the field when `predicate` returns `true`.\n * @template TValue The data type of the field to apply the schema to.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function applyWhenValue<TValue>(\n  path: SchemaPath<TValue>,\n  predicate: (value: TValue) => boolean,\n  schema: NoInfer<SchemaOrSchemaFn<TValue>>,\n): void;\n\nexport function applyWhenValue(\n  path: SchemaPath<unknown>,\n  predicate: (value: unknown) => boolean,\n  schema: SchemaOrSchemaFn<unknown>,\n) {\n  applyWhen(path, ({value}) => predicate(value()), schema);\n}\n\n/**\n * Submits a given `FieldTree` using the given action function and applies any submission errors\n * resulting from the action to the field. Submission errors returned by the `action` will be integrated\n * into the field as a `ValidationError` on the sub-field indicated by the `fieldTree` property of the\n * submission error.\n *\n * @example\n * ```ts\n * async function registerNewUser(registrationForm: FieldTree<{username: string, password: string}>) {\n *   const result = await myClient.registerNewUser(registrationForm().value());\n *   if (result.errorCode === myClient.ErrorCode.USERNAME_TAKEN) {\n *     return [{\n *       fieldTree: registrationForm.username,\n *       kind: 'server',\n *       message: 'Username already taken'\n *     }];\n *   }\n *   return undefined;\n * }\n *\n * const registrationForm = form(signal({username: 'god', password: ''}));\n * submit(registrationForm, async (f) => {\n *   return registerNewUser(registrationForm);\n * });\n * registrationForm.username().errors(); // [{kind: 'server', message: 'Username already taken'}]\n * ```\n *\n * @param form The field to submit.\n * @param action An asynchronous action used to submit the field. The action may return submission\n * errors.\n * @template TModel The data type of the field being submitted.\n *\n * @category submission\n * @experimental 21.0.0\n */\nexport async function submit<TModel>(\n  form: FieldTree<TModel>,\n  action: (form: FieldTree<TModel>) => Promise<TreeValidationResult>,\n) {\n  const node = form() as unknown as FieldNode;\n  const invalid = untracked(() => {\n    markAllAsTouched(node);\n    return node.invalid();\n  });\n\n  // Fail fast if the form is already invalid.\n  if (invalid) {\n    return;\n  }\n\n  node.submitState.selfSubmitting.set(true);\n  try {\n    const errors = await action(form);\n    errors && setSubmissionErrors(node, errors);\n  } finally {\n    node.submitState.selfSubmitting.set(false);\n  }\n}\n\n/**\n * Sets a list of submission errors to their individual fields.\n *\n * @param submittedField The field that was submitted, resulting in the errors.\n * @param errors The errors to set.\n */\nfunction setSubmissionErrors(\n  submittedField: FieldNode,\n  errors: OneOrMany<ValidationError.WithOptionalFieldTree>,\n) {\n  if (!isArray(errors)) {\n    errors = [errors];\n  }\n  const errorsByField = new Map<FieldNode, ValidationError.WithFieldTree[]>();\n  for (const error of errors) {\n    const errorWithField = addDefaultField(error, submittedField.fieldProxy);\n    const field = errorWithField.fieldTree() as FieldNode;\n    let fieldErrors = errorsByField.get(field);\n    if (!fieldErrors) {\n      fieldErrors = [];\n      errorsByField.set(field, fieldErrors);\n    }\n    fieldErrors.push(errorWithField);\n  }\n  for (const [field, fieldErrors] of errorsByField) {\n    field.submitState.submissionErrors.set(fieldErrors);\n  }\n}\n\n/**\n * Creates a `Schema` that adds logic rules to a form.\n * @param fn A **non-reactive** function that sets up reactive logic rules for the form.\n * @returns A schema object that implements the given logic.\n * @template TValue The value type of a `FieldTree` that this schema binds to.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function schema<TValue>(fn: SchemaFn<TValue>): Schema<TValue> {\n  return SchemaImpl.create(fn) as unknown as Schema<TValue>;\n}\n\n/** Marks a {@link node} and its descendants as touched. */\nfunction markAllAsTouched(node: FieldNode) {\n  // Don't mark hidden, disabled, or readonly fields as touched since they don't contribute to the\n  // form's validity. This also prevents errors from appearing immediately if they're later made\n  // interactive.\n  if (node.validationState.shouldSkipValidation()) {\n    return;\n  }\n  node.markAsTouched();\n  for (const child of node.structure.children()) {\n    markAllAsTouched(child);\n  }\n}\n"],"names":["CompatValidationError","kind","control","fieldTree","context","message","constructor","signalErrorsToValidationErrors","errors","length","errObj","error","reactiveErrorsToSignalErrors","Object","entries","map","extractNestedReactiveErrors","push","FormGroup","FormArray","c","values","controls","boundPathDepth","getBoundPathDepth","setBoundPathDepthForResolution","fn","depth","args","shortCircuitFalse","value","shortCircuitTrue","getInjectorFromOptions","options","fieldManager","injector","parent","structure","root","isArray","Array","isObject","DYNAMIC","Symbol","IGNORED","AbstractLogic","predicates","fns","logicFn","wrapWithPredicates","mergeIn","other","BooleanOrLogic","defaultValue","compute","arg","some","f","result","ArrayMergeIgnoreLogic","ignore","ignoreNull","e","reduce","prev","undefined","filter","ArrayMergeLogic","MetadataMergeLogic","key","reducer","getInitial","ctx","acc","i","item","predicate","predicateField","stateOf","path","depthDiff","untracked","pathKeys","LogicContainer","hidden","disabledReasons","readonly","syncErrors","syncTreeErrors","asyncErrors","metadata","Map","hasMetadata","has","getMetadataKeys","keys","getMetadata","set","get","metadataLogic","AbstractLogicNodeBuilder","build","LeafLogicNode","LogicNodeBuilder","current","all","addHiddenRule","logic","getCurrent","addDisabledReasonRule","addReadonlyRule","addSyncErrorRule","addSyncTreeErrorRule","addAsyncErrorRule","addMetadataRule","getChild","children","size","hasLogic","builder","subBuilder","NonMergeableLogicNodeBuilder","newRoot","createLogic","childBuilders","getAllChildBuilders","p","bindLevel","builtNodes","CompositeLogicNode","node","flatMap","child","RuntimeError","ngDevMode","PATH","FieldPathNode","keyInParent","fieldPathProxy","Proxy","FIELD_PATH_PROXY_HANDLER","logicBuilder","compile","unwrapFieldPath","formPath","property","currentCompilingNode","compiledSchemas","SchemaImpl","schemaFn","prevCompilingNode","create","schema","rootCompile","clear","isSchemaOrSchemaFn","assertPathIsCurrent","pathNode","MetadataReducer","list","min","Math","max","next","or","and","override","_","MetadataKey","brand","createMetadataKey","createManagedMetadataKey","REQUIRED","MIN","MAX","MIN_LENGTH","MAX_LENGTH","PATTERN","calculateValidationSelfStatus","state","pending","FieldValidationState","rawSyncTreeErrors","computed","shouldSkipValidation","logicNode","validationState","normalizeErrors","submitState","submissionErrors","syncValid","reduceChildren","err","fieldProxy","rawAsyncErrors","parseErrors","formFieldBindings","field","debugName","errorSummary","ngServerMode","sort","compareErrorPosition","includes","status","ownStatus","v","valid","invalid","disabled","addDefaultField","getFirstBoundElement","formField","element","el","binding","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","a","b","aEl","bEl","DEBOUNCER","FieldNodeContext","cache","WeakMap","resolve","target","resolver","targetPathNode","stepsRemaining","join","index","Number","fieldTreeOf","valueOf","AbstractControl","FieldMetadataState","runInInjectionContext","FIELD_PROXY_HANDLER","getTgt","receiver","tgt","iterator","prototype","apply","getOwnPropertyDescriptor","prop","desc","Reflect","configurable","ownKeys","deepSignal","source","read","SIGNAL","update","valueForWrite","asReadonly","sourceValue","newPropValue","newValue","FieldNodeStructure","createChildNode","identitySymbol","_injector","Injector","providers","childrenMap","from","byPropertyKey","reader","strKey","toString","createReader","initialValue","shortCircuit","destroy","createKeyInParent","identityInParent","initialKeyInParent","ROOT_KEY_IN_PARENT","getDebugName","lastKnownKey","parentValue","data","hasOwnProperty","createChildrenMap","linkedSignal","computation","previous","prevData","parentIsArray","maybeRemoveStaleArrayFields","maybeRemoveStaleObjectFields","trackingKey","childValue","delete","globalId","childNode","byTrackingKey","RootFieldNodeStructure","ROOT_PATH_KEYS","ChildFieldNodeStructure","fieldAdapter","structures","add","oldKeys","Set","oldTracking","id","FieldSubmitState","selfSubmitting","signal","submitting","FieldNode","metadataState","nodeState","controlValue","_context","createStructure","createValidationState","createNodeState","controlValueSignal","focusBoundControl","getBindingForFocus","focus","own","firstInDom","pendingSync","_source","abort","dirty","touched","name","maxLength","minLength","pattern","EMPTY","required","FALSE","markAsTouched","flushSync","markAsDirty","markAsPristine","markAsUntouched","reset","_reset","debounceSync","updateFn","sync","aborted","debouncer","controller","AbortController","promise","adapter","newChild","bind","trackingId","childPath","childLogic","position","FieldNodeState","selfTouched","selfDirty","selfDirtyValue","isNonInteractive","selfTouchedValue","rootName","debouncerLogic","BasicFieldAdapter","FormFieldManager","APP_ID","nextFormId","createFieldManagementEffect","effect","liveStructures","markStructuresLive","normalizeFormArgs","model","form","inject","fieldRoot","applyEach","elementPath","applyWhen","applyWhenValue","submit","action","markAllAsTouched","setSubmissionErrors","submittedField","errorsByField","errorWithField","fieldErrors"],"mappings":"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"}
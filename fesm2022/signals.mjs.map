{"version":3,"file":"signals.mjs","sources":["../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/field/di.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/di.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/disabled.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/hidden.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/readonly.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/util.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/validate.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/validation_errors.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/email.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/max.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/max_length.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/min.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/min_length.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/pattern.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/required.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/validate_async.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/validate_tree.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/standard_schema.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/validation/validate_http.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/rules/debounce.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/directive/parse_errors.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/util/parser.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/api/transformed_value.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/controls/interop_ng_control.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/directive/bindings.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/directive/native.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/directive/control_custom.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/directive/control_cva.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/directive/select.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/directive/control_native.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/directive/form_field_directive.ts","../../../../../k8-fastbuild-ST-fdfa778d11ba/bin/packages/forms/signals/src/directive/ng_signal_form.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from '@angular/core';\nimport type {SignalFormsConfig} from '../api/di';\n\n/** Injection token for the signal forms configuration. */\nexport const SIGNAL_FORMS_CONFIG = new InjectionToken<SignalFormsConfig>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'SIGNAL_FORMS_CONFIG' : '',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {type Provider} from '@angular/core';\nimport {SIGNAL_FORMS_CONFIG} from '../field/di';\nimport type {FormField} from '../directive/form_field_directive';\n\n/**\n * Configuration options for signal forms.\n *\n * @experimental 21.0.1\n */\nexport interface SignalFormsConfig {\n  /** A map of CSS class names to predicate functions that determine when to apply them. */\n  classes?: {[className: string]: (state: FormField<unknown>) => boolean};\n}\n\n/**\n * Provides configuration options for signal forms.\n *\n * @experimental 21.0.1\n */\nexport function provideSignalFormsConfig(config: SignalFormsConfig): Provider[] {\n  return [{provide: SIGNAL_FORMS_CONFIG, useValue: config}];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {FieldPathNode} from '../../schema/path_node';\nimport {assertPathIsCurrent} from '../../schema/schema';\nimport type {FieldContext, LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../types';\n\n/**\n * Adds logic to a field to conditionally disable it. A disabled field does not contribute to the\n * validation, touched/dirty, or other state of its parent field.\n *\n * @param path The target path to add the disabled logic to.\n * @param logic A reactive function that returns `true` (or a string reason) when the field is disabled,\n *   and `false` when it is not disabled.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function disabled<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  logic?: string | NoInfer<LogicFn<TValue, boolean | string, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addDisabledReasonRule((ctx) => {\n    let result: boolean | string = true;\n    if (typeof logic === 'string') {\n      result = logic;\n    } else if (logic) {\n      result = logic(ctx as FieldContext<TValue, TPathKind>);\n    }\n    if (typeof result === 'string') {\n      return {fieldTree: ctx.fieldTree, message: result};\n    }\n    return result ? {fieldTree: ctx.fieldTree} : undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {FieldPathNode} from '../../schema/path_node';\nimport {assertPathIsCurrent} from '../../schema/schema';\nimport type {LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../types';\n\n/**\n * Adds logic to a field to conditionally hide it. A hidden field does not contribute to the\n * validation, touched/dirty, or other state of its parent field.\n *\n * If a field may be hidden it is recommended to guard it with an `@if` in the template:\n * ```\n * @if (!email().hidden()) {\n *   <label for=\"email\">Email</label>\n *   <input id=\"email\" type=\"email\" [control]=\"email\" />\n * }\n * ```\n *\n * @param path The target path to add the hidden logic to.\n * @param logic A reactive function that returns `true` when the field is hidden.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function hidden<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  logic: NoInfer<LogicFn<TValue, boolean, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addHiddenRule(logic);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {FieldPathNode} from '../../schema/path_node';\nimport {assertPathIsCurrent} from '../../schema/schema';\nimport type {LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../types';\n\n/**\n * Adds logic to a field to conditionally make it readonly. A readonly field does not contribute to\n * the validation, touched/dirty, or other state of its parent field.\n *\n * @param path The target path to make readonly.\n * @param logic A reactive function that returns `true` when the field is readonly.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function readonly<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  logic: NoInfer<LogicFn<TValue, boolean, TPathKind>> = () => true,\n) {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addReadonlyRule(logic);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LogicFn, OneOrMany, PathKind, type FieldContext} from '../../types';\nimport {ValidationError} from './validation_errors';\n\n/** Represents a value that has a length or size, such as an array or string, or set. */\nexport type ValueWithLengthOrSize = {length: number} | {size: number};\n\n/** Common options available on the standard validators. */\nexport type BaseValidatorConfig<TValue, TPathKind extends PathKind = PathKind.Root> =\n  | {\n      /** A user-facing error message to include with the error. */\n      message?: string | LogicFn<TValue, string, TPathKind>;\n      error?: never;\n    }\n  | {\n      /**\n       * Custom validation error(s) to report instead of the default,\n       * or a function that receives the `FieldContext` and returns custom validation error(s).\n       */\n      error?: OneOrMany<ValidationError> | LogicFn<TValue, OneOrMany<ValidationError>, TPathKind>;\n      message?: never;\n    };\n\n/** Gets the length or size of the given value. */\nexport function getLengthOrSize(value: ValueWithLengthOrSize) {\n  const v = value as {length: number; size: number};\n  return typeof v.length === 'number' ? v.length : v.size;\n}\n\n/**\n * Gets the value for an option that may be either a static value or a logic function that produces\n * the option value.\n *\n * @param opt The option from BaseValidatorConfig.\n * @param ctx The current FieldContext.\n * @returns The value for the option.\n */\nexport function getOption<TOption, TValue, TPathKind extends PathKind = PathKind.Root>(\n  opt: Exclude<TOption, Function> | LogicFn<TValue, TOption, TPathKind> | undefined,\n  ctx: FieldContext<TValue, TPathKind>,\n): TOption | undefined {\n  return opt instanceof Function ? opt(ctx) : opt;\n}\n\n/**\n * Checks if the given value is considered empty. Empty values are: null, undefined, '', false, NaN.\n */\nexport function isEmpty(value: unknown): boolean {\n  if (typeof value === 'number') {\n    return isNaN(value);\n  }\n  return value === '' || value === false || value == null;\n}\n\n/**\n * Normalizes validation errors (which can be a single error, an array of errors, or undefined)\n * into a list of errors.\n */\nexport function normalizeErrors<T>(error: OneOrMany<T> | undefined): readonly T[] {\n  if (error === undefined) {\n    return [];\n  }\n  if (Array.isArray(error)) {\n    return error as readonly T[];\n  }\n  return [error as T];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {addDefaultField} from '../../../field/validation';\nimport {FieldPathNode} from '../../../schema/path_node';\nimport {assertPathIsCurrent} from '../../../schema/schema';\nimport type {\n  FieldContext,\n  FieldValidator,\n  PathKind,\n  SchemaPath,\n  SchemaPathRules,\n} from '../../types';\n\n/**\n * Adds logic to a field to determine if the field has validation errors.\n *\n * @param path The target path to add the validation logic to.\n * @param logic A `Validator` that returns the current validation errors.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function validate<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  logic: NoInfer<FieldValidator<TValue, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addSyncErrorRule((ctx) => {\n    return addDefaultField(logic(ctx as FieldContext<TValue, TPathKind>), ctx.fieldTree);\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {FormField} from '../../../directive/form_field_directive';\nimport type {FieldTree} from '../../types';\nimport type {StandardSchemaValidationError} from './standard_schema';\n\n/**\n * Options used to create a `ValidationError`.\n */\nexport interface ValidationErrorOptions {\n  /** Human readable error message. */\n  message?: string;\n}\n\n/**\n * A type that requires the given type `T` to have a `field` property.\n * @template T The type to add a `field` to.\n *\n * @experimental 21.0.0\n */\nexport type WithFieldTree<T> = T & {fieldTree: FieldTree<unknown>};\n/** @deprecated Use `WithFieldTree` instead  */\nexport type WithField<T> = WithFieldTree<T>;\n\n/**\n * A type that allows the given type `T` to optionally have a `field` property.\n * @template T The type to optionally add a `field` to.\n *\n * @experimental 21.0.0\n */\nexport type WithOptionalFieldTree<T> = Omit<T, 'fieldTree'> & {fieldTree?: FieldTree<unknown>};\n/** @deprecated Use `WithOptionalFieldTree` instead  */\nexport type WithOptionalField<T> = WithOptionalFieldTree<T>;\n\n/**\n * A type that ensures the given type `T` does not have a `field` property.\n * @template T The type to remove the `field` from.\n *\n * @experimental 21.0.0\n */\nexport type WithoutFieldTree<T> = T & {fieldTree: never};\n/** @deprecated Use `WithoutFieldTree` instead  */\nexport type WithoutField<T> = WithoutFieldTree<T>;\n\n/**\n * Create a required error associated with the target field\n * @param options The validation error options\n *\n * @experimental 21.0.0\n */\nexport function requiredError(\n  options: WithFieldTree<ValidationErrorOptions>,\n): RequiredValidationError;\n/**\n * Create a required error\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function requiredError(\n  options?: ValidationErrorOptions,\n): WithoutFieldTree<RequiredValidationError>;\nexport function requiredError(\n  options?: ValidationErrorOptions,\n): WithOptionalFieldTree<RequiredValidationError> {\n  return new RequiredValidationError(options);\n}\n\n/**\n * Create a min value error associated with the target field\n * @param min The min value constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minError(\n  min: number,\n  options: WithFieldTree<ValidationErrorOptions>,\n): MinValidationError;\n/**\n * Create a min value error\n * @param min The min value constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minError(\n  min: number,\n  options?: ValidationErrorOptions,\n): WithoutFieldTree<MinValidationError>;\nexport function minError(\n  min: number,\n  options?: ValidationErrorOptions,\n): WithOptionalFieldTree<MinValidationError> {\n  return new MinValidationError(min, options);\n}\n\n/**\n * Create a max value error associated with the target field\n * @param max The max value constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxError(\n  max: number,\n  options: WithFieldTree<ValidationErrorOptions>,\n): MaxValidationError;\n/**\n * Create a max value error\n * @param max The max value constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxError(\n  max: number,\n  options?: ValidationErrorOptions,\n): WithoutFieldTree<MaxValidationError>;\nexport function maxError(\n  max: number,\n  options?: ValidationErrorOptions,\n): WithOptionalFieldTree<MaxValidationError> {\n  return new MaxValidationError(max, options);\n}\n\n/**\n * Create a minLength error associated with the target field\n * @param minLength The minLength constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minLengthError(\n  minLength: number,\n  options: WithFieldTree<ValidationErrorOptions>,\n): MinLengthValidationError;\n/**\n * Create a minLength error\n * @param minLength The minLength constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minLengthError(\n  minLength: number,\n  options?: ValidationErrorOptions,\n): WithoutFieldTree<MinLengthValidationError>;\nexport function minLengthError(\n  minLength: number,\n  options?: ValidationErrorOptions,\n): WithOptionalFieldTree<MinLengthValidationError> {\n  return new MinLengthValidationError(minLength, options);\n}\n\n/**\n * Create a maxLength error associated with the target field\n * @param maxLength The maxLength constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxLengthError(\n  maxLength: number,\n  options: WithFieldTree<ValidationErrorOptions>,\n): MaxLengthValidationError;\n/**\n * Create a maxLength error\n * @param maxLength The maxLength constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxLengthError(\n  maxLength: number,\n  options?: ValidationErrorOptions,\n): WithoutFieldTree<MaxLengthValidationError>;\nexport function maxLengthError(\n  maxLength: number,\n  options?: ValidationErrorOptions,\n): WithOptionalFieldTree<MaxLengthValidationError> {\n  return new MaxLengthValidationError(maxLength, options);\n}\n\n/**\n * Create a pattern matching error associated with the target field\n * @param pattern The violated pattern\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function patternError(\n  pattern: RegExp,\n  options: WithFieldTree<ValidationErrorOptions>,\n): PatternValidationError;\n/**\n * Create a pattern matching error\n * @param pattern The violated pattern\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function patternError(\n  pattern: RegExp,\n  options?: ValidationErrorOptions,\n): WithoutFieldTree<PatternValidationError>;\nexport function patternError(\n  pattern: RegExp,\n  options?: ValidationErrorOptions,\n): WithOptionalFieldTree<PatternValidationError> {\n  return new PatternValidationError(pattern, options);\n}\n\n/**\n * Create an email format error associated with the target field\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function emailError(options: WithFieldTree<ValidationErrorOptions>): EmailValidationError;\n/**\n * Create an email format error\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function emailError(\n  options?: ValidationErrorOptions,\n): WithoutFieldTree<EmailValidationError>;\nexport function emailError(\n  options?: ValidationErrorOptions,\n): WithOptionalFieldTree<EmailValidationError> {\n  return new EmailValidationError(options);\n}\n\n/**\n * Common interface for all validation errors.\n *\n * This can be returned from validators.\n *\n * It's also used by the creation functions to create an instance\n * (e.g. `requiredError`, `minError`, etc.).\n *\n * @see [Signal Form Validation](guide/forms/signals/validation)\n * @see [Signal Form Validation Errors](guide/forms/signals/validation#validation-errors)\n * @category validation\n * @experimental 21.0.0\n */\nexport interface ValidationError {\n  /** Identifies the kind of error. */\n  readonly kind: string;\n  /** Human readable error message. */\n  readonly message?: string;\n}\n\nexport declare namespace ValidationError {\n  /**\n   * Validation error with an associated field tree.\n   *\n   * This is returned from field state, e.g., catField.errors() would be of a list of errors with\n   * `field: catField` bound to state.\n   */\n  export interface WithFieldTree extends ValidationError {\n    /** The field associated with this error. */\n    readonly fieldTree: FieldTree<unknown>;\n    readonly formField?: FormField<unknown>;\n  }\n  /** @deprecated Use `ValidationError.WithFieldTree` instead  */\n  export type WithField = WithFieldTree;\n\n  /**\n   * Validation error with an associated field tree and specific form field binding.\n   */\n  export interface WithFormField extends WithFieldTree {\n    readonly formField: FormField<unknown>;\n  }\n\n  /**\n   * Validation error with optional field.\n   *\n   * This is generally used in places where the result might have a field.\n   * e.g., as a result of a `validateTree`, or when handling form submission.\n   */\n  export interface WithOptionalFieldTree extends ValidationError {\n    /** The field associated with this error. */\n    readonly fieldTree?: FieldTree<unknown>;\n  }\n  /** @deprecated Use `ValidationError.WithOptionalFieldTree` instead  */\n  export type WithOptionalField = WithOptionalFieldTree;\n\n  /**\n   * Validation error with no field.\n   *\n   * This is used to strongly enforce that fields are not allowed in validation result.\n   */\n  export interface WithoutFieldTree extends ValidationError {\n    /** The field associated with this error. */\n    readonly fieldTree?: never;\n    readonly formField?: never;\n  }\n  /** @deprecated Use `ValidationError.WithoutFieldTree` instead  */\n  export type WithoutField = WithoutFieldTree;\n}\n\n/**\n * Internal version of `NgValidationError`, we create this separately so we can change its type on\n * the exported version to a type union of the possible sub-classes.\n *\n * @experimental 21.0.0\n */\nexport abstract class BaseNgValidationError implements ValidationError {\n  /** Brand the class to avoid Typescript structural matching */\n  private __brand = undefined;\n\n  /** Identifies the kind of error. */\n  readonly kind: string = '';\n\n  /** The field associated with this error. */\n  readonly fieldTree!: FieldTree<unknown>;\n\n  /** Human readable error message. */\n  readonly message?: string;\n\n  constructor(options?: ValidationErrorOptions) {\n    if (options) {\n      Object.assign(this, options);\n    }\n  }\n}\n\n/**\n * An error used to indicate that a required field is empty.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class RequiredValidationError extends BaseNgValidationError {\n  override readonly kind = 'required';\n}\n\n/**\n * An error used to indicate that a value is lower than the minimum allowed.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MinValidationError extends BaseNgValidationError {\n  override readonly kind = 'min';\n\n  constructor(\n    readonly min: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is higher than the maximum allowed.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MaxValidationError extends BaseNgValidationError {\n  override readonly kind = 'max';\n\n  constructor(\n    readonly max: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is shorter than the minimum allowed length.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MinLengthValidationError extends BaseNgValidationError {\n  override readonly kind = 'minLength';\n\n  constructor(\n    readonly minLength: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is longer than the maximum allowed length.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MaxLengthValidationError extends BaseNgValidationError {\n  override readonly kind = 'maxLength';\n\n  constructor(\n    readonly maxLength: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value does not match the required pattern.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class PatternValidationError extends BaseNgValidationError {\n  override readonly kind = 'pattern';\n\n  constructor(\n    readonly pattern: RegExp,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is not a valid email.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class EmailValidationError extends BaseNgValidationError {\n  override readonly kind = 'email';\n}\n\n/**\n * An error used to indicate that a value entered in a native input does not parse.\n *\n * @category validation\n * @experimental 21.2.0\n */\nexport class NativeInputParseError extends BaseNgValidationError {\n  override readonly kind = 'parse';\n}\n\n/**\n * The base class for all built-in, non-custom errors. This class can be used to check if an error\n * is one of the standard kinds, allowing you to switch on the kind to further narrow the type.\n *\n * @example\n * ```ts\n * const f = form(...);\n * for (const e of form().errors()) {\n *   if (e instanceof NgValidationError) {\n *     switch(e.kind) {\n *       case 'required':\n *         console.log('This is required!');\n *         break;\n *       case 'min':\n *         console.log(`Must be at least ${e.min}`);\n *         break;\n *       ...\n *     }\n *   }\n * }\n * ```\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const NgValidationError: abstract new () => NgValidationError = BaseNgValidationError as any;\nexport type NgValidationError =\n  | RequiredValidationError\n  | MinValidationError\n  | MaxValidationError\n  | MinLengthValidationError\n  | MaxLengthValidationError\n  | PatternValidationError\n  | EmailValidationError\n  | StandardSchemaValidationError\n  | NativeInputParseError;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {PathKind, SchemaPath, SchemaPathRules} from '../../types';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\nimport {validate} from './validate';\nimport {emailError} from './validation_errors';\n\n/**\n * A regular expression that matches valid e-mail addresses.\n *\n * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:\n * - `local-part` consists of one or more of the allowed characters (alphanumeric and some\n *   punctuation symbols).\n * - `local-part` cannot begin or end with a period (`.`).\n * - `local-part` cannot be longer than 64 characters.\n * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or\n *   `foo.com`.\n * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and\n *   periods (`.`)).\n * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).\n * - A `label` cannot be longer than 63 characters.\n * - The whole address cannot be longer than 254 characters.\n *\n * ## Implementation background\n *\n * This regexp was ported over from AngularJS (see there for git history):\n * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27\n * It is based on the\n * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n * lengths of different parts of the address). The main differences from the WHATWG version are:\n *   - Disallow `local-part` to begin or end with a period (`.`).\n *   - Disallow `local-part` length to exceed 64 characters.\n *   - Disallow total address length to exceed 254 characters.\n *\n * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.\n */\nconst EMAIL_REGEXP =\n  /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\n/**\n * Binds a validator to the given path that requires the value to match the standard email format.\n * This function can only be called on string paths.\n *\n * @param path Path of the field to validate\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.email()`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @see [Signal Form Email Validation](guide/forms/signals/validation#email)\n * @category validation\n * @experimental 21.0.0\n */\nexport function email<TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<string, SchemaPathRules.Supported, TPathKind>,\n  config?: BaseValidatorConfig<string, TPathKind>,\n) {\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    if (!EMAIL_REGEXP.test(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return emailError({message: getOption(config?.message, ctx)});\n      }\n    }\n\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../../types';\nimport {createMetadataKey, MAX, metadata} from '../metadata';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\nimport {validate} from './validate';\nimport {maxError} from './validation_errors';\n\n/**\n * Binds a validator to the given path that requires the value to be less than or equal to the\n * given `maxValue`.\n * This function can only be called on number paths.\n * In addition to binding a validator, this function adds `MAX` property to the field.\n *\n * @param path Path of the field to validate\n * @param maxValue The maximum value, or a LogicFn that returns the maximum value.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.max(maxValue)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @see [Signal Form Max Validation](guide/forms/signals/validation#min-and-max)\n * @category validation\n * @experimental 21.0.0\n */\nexport function max<TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<number | string | null, SchemaPathRules.Supported, TPathKind>,\n  maxValue: number | LogicFn<number | string | null, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<number | string | null, TPathKind>,\n) {\n  const MAX_MEMO = metadata(path, createMetadataKey<number | undefined>(), (ctx) =>\n    typeof maxValue === 'number' ? maxValue : maxValue(ctx),\n  );\n  metadata(path, MAX, ({state}) => state.metadata(MAX_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const max = ctx.state.metadata(MAX_MEMO)!();\n    if (max === undefined || Number.isNaN(max)) {\n      return undefined;\n    }\n    const value = ctx.value();\n    const numValue = !value && value !== 0 ? NaN : Number(value); // Treat `''` and `null` as `NaN`\n    if (numValue > max) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return maxError(max, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../../types';\nimport {createMetadataKey, MAX_LENGTH, metadata} from '../metadata';\nimport {\n  BaseValidatorConfig,\n  getLengthOrSize,\n  getOption,\n  isEmpty,\n  ValueWithLengthOrSize,\n} from './util';\nimport {validate} from './validate';\nimport {maxLengthError} from './validation_errors';\n\n/**\n * Binds a validator to the given path that requires the length of the value to be less than or\n * equal to the given `maxLength`.\n * This function can only be called on string or array paths.\n * In addition to binding a validator, this function adds `MAX_LENGTH` property to the field.\n *\n * @param path Path of the field to validate\n * @param maxLength The maximum length, or a LogicFn that returns the maximum length.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.maxLength(maxLength)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @see [Signal Form Max Length Validation](guide/forms/signals/validation#minlength-and-maxlength)\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxLength<\n  TValue extends ValueWithLengthOrSize,\n  TPathKind extends PathKind = PathKind.Root,\n>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  maxLength: number | LogicFn<TValue, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<TValue, TPathKind>,\n) {\n  const MAX_LENGTH_MEMO = metadata(path, createMetadataKey<number | undefined>(), (ctx) =>\n    typeof maxLength === 'number' ? maxLength : maxLength(ctx),\n  );\n  metadata(path, MAX_LENGTH, ({state}) => state.metadata(MAX_LENGTH_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const maxLength = ctx.state.metadata(MAX_LENGTH_MEMO)!();\n    if (maxLength === undefined) {\n      return undefined;\n    }\n    if (getLengthOrSize(ctx.value()) > maxLength) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return maxLengthError(maxLength, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../../types';\nimport {createMetadataKey, metadata, MIN} from '../metadata';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\nimport {validate} from './validate';\nimport {minError} from './validation_errors';\n\n/**\n * Binds a validator to the given path that requires the value to be greater than or equal to\n * the given `minValue`.\n * This function can only be called on number paths.\n * In addition to binding a validator, this function adds `MIN` property to the field.\n *\n * @param path Path of the field to validate\n * @param minValue The minimum value, or a LogicFn that returns the minimum value.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.min(minValue)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @see [Signal Form Min Validation](guide/forms/signals/validation#min-and-max)\n * @category validation\n * @experimental 21.0.0\n */\nexport function min<\n  TValue extends number | string | null,\n  TPathKind extends PathKind = PathKind.Root,\n>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  minValue: number | LogicFn<TValue, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<TValue, TPathKind>,\n) {\n  const MIN_MEMO = metadata(path, createMetadataKey<number | undefined>(), (ctx) =>\n    typeof minValue === 'number' ? minValue : minValue(ctx),\n  );\n  metadata(path, MIN, ({state}) => state.metadata(MIN_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const min = ctx.state.metadata(MIN_MEMO)!();\n    if (min === undefined || Number.isNaN(min)) {\n      return undefined;\n    }\n    const value = ctx.value();\n    const numValue = !value && value !== 0 ? NaN : Number(value); // Treat `''` and `null` as `NaN`\n    if (numValue < min) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return minError(min, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../../types';\nimport {createMetadataKey, metadata, MIN_LENGTH} from '../metadata';\nimport {\n  BaseValidatorConfig,\n  getLengthOrSize,\n  getOption,\n  isEmpty,\n  ValueWithLengthOrSize,\n} from './util';\nimport {validate} from './validate';\nimport {minLengthError} from './validation_errors';\n\n/**\n * Binds a validator to the given path that requires the length of the value to be greater than or\n * equal to the given `minLength`.\n * This function can only be called on string or array paths.\n * In addition to binding a validator, this function adds `MIN_LENGTH` property to the field.\n *\n * @param path Path of the field to validate\n * @param minLength The minimum length, or a LogicFn that returns the minimum length.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.minLength(minLength)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @see [Signal Form Min Length Validation](guide/forms/signals/validation#minlength-and-maxlength)\n * @category validation\n * @experimental 21.0.0\n */\nexport function minLength<\n  TValue extends ValueWithLengthOrSize,\n  TPathKind extends PathKind = PathKind.Root,\n>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  minLength: number | LogicFn<TValue, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<TValue, TPathKind>,\n) {\n  const MIN_LENGTH_MEMO = metadata(path, createMetadataKey<number | undefined>(), (ctx) =>\n    typeof minLength === 'number' ? minLength : minLength(ctx),\n  );\n  metadata(path, MIN_LENGTH, ({state}) => state.metadata(MIN_LENGTH_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const minLength = ctx.state.metadata(MIN_LENGTH_MEMO)!();\n    if (minLength === undefined) {\n      return undefined;\n    }\n    if (getLengthOrSize(ctx.value()) < minLength) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return minLengthError(minLength, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../../types';\nimport {createMetadataKey, metadata, PATTERN} from '../metadata';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\nimport {validate} from './validate';\nimport {patternError} from './validation_errors';\n\n/**\n * Binds a validator to the given path that requires the value to match a specific regex pattern.\n * This function can only be called on string paths.\n * In addition to binding a validator, this function adds `PATTERN` property to the field.\n *\n * @param path Path of the field to validate\n * @param pattern The RegExp pattern to match, or a LogicFn that returns the RegExp pattern.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.pattern(pattern)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @see [Signal Form Pattern Validation](guide/forms/signals/validation#pattern)\n * @category validation\n * @experimental 21.0.0\n */\nexport function pattern<TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<string, SchemaPathRules.Supported, TPathKind>,\n  pattern: RegExp | LogicFn<string | undefined, RegExp | undefined, TPathKind>,\n  config?: BaseValidatorConfig<string, TPathKind>,\n) {\n  const PATTERN_MEMO = metadata(path, createMetadataKey<RegExp | undefined>(), (ctx) =>\n    pattern instanceof RegExp ? pattern : pattern(ctx),\n  );\n  metadata(path, PATTERN, ({state}) => state.metadata(PATTERN_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const pattern = ctx.state.metadata(PATTERN_MEMO)!();\n    if (pattern === undefined) {\n      return undefined;\n    }\n    if (!pattern.test(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return patternError(pattern, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../../types';\nimport {createMetadataKey, metadata, REQUIRED} from '../metadata';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\nimport {validate} from './validate';\nimport {requiredError} from './validation_errors';\n\n/**\n * Binds a validator to the given path that requires the value to be non-empty.\n * This function can only be called on any type of path.\n * In addition to binding a validator, this function adds `REQUIRED` property to the field.\n *\n * @param path Path of the field to validate\n * @param config Optional, allows providing any of the following options:\n *  - `message`: A user-facing message for the error.\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.required()`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n *  - `when`: A function that receives the `FieldContext` and returns true if the field is required\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @see [Signal Form Required Validation](guide/forms/signals/validation#required)\n * @category validation\n * @experimental 21.0.0\n */\nexport function required<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  config?: BaseValidatorConfig<TValue, TPathKind> & {\n    when?: NoInfer<LogicFn<TValue, boolean, TPathKind>>;\n  },\n): void {\n  const REQUIRED_MEMO = metadata(path, createMetadataKey<boolean>(), (ctx) =>\n    config?.when ? config.when(ctx) : true,\n  );\n  metadata(path, REQUIRED, ({state}) => state.metadata(REQUIRED_MEMO)!()!);\n  validate(path, (ctx) => {\n    if (ctx.state.metadata(REQUIRED_MEMO)!() && isEmpty(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return requiredError({message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {ResourceRef, Signal} from '@angular/core';\nimport {FieldNode} from '../../../field/node';\nimport {addDefaultField} from '../../../field/validation';\nimport {FieldPathNode} from '../../../schema/path_node';\nimport {assertPathIsCurrent} from '../../../schema/schema';\nimport {\n  FieldContext,\n  PathKind,\n  SchemaPath,\n  SchemaPathRules,\n  TreeValidationResult,\n} from '../../types';\nimport {createManagedMetadataKey, metadata} from '../metadata';\n\n/**\n * A function that takes the result of an async operation and the current field context, and maps it\n * to a list of validation errors.\n *\n * @param result The result of the async operation.\n * @param ctx The context for the field the validator is attached to.\n * @return A validation error, or list of validation errors to report based on the result of the async operation.\n *   The returned errors can optionally specify a field that the error should be targeted to.\n *   A targeted error will show up as an error on its target field rather than the field being validated.\n *   If a field is not given, the error is assumed to apply to the field being validated.\n * @template TValue The type of value stored in the field being validated.\n * @template TResult The type of result returned by the async operation\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @experimental 21.0.0\n */\nexport type MapToErrorsFn<TValue, TResult, TPathKind extends PathKind = PathKind.Root> = (\n  result: TResult,\n  ctx: FieldContext<TValue, TPathKind>,\n) => TreeValidationResult;\n\n/**\n * Options that indicate how to create a resource for async validation for a field,\n * and map its result to validation errors.\n *\n * @template TValue The type of value stored in the field being validated.\n * @template TParams The type of parameters to the resource.\n * @template TResult The type of result returned by the resource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n * @see [Signal Form Async Validation](guide/forms/signals/validation#async-validation)\n * @category validation\n * @experimental 21.0.0\n */\nexport interface AsyncValidatorOptions<\n  TValue,\n  TParams,\n  TResult,\n  TPathKind extends PathKind = PathKind.Root,\n> {\n  /**\n   * A function that receives the field context and returns the params for the resource.\n   *\n   * @param ctx The field context for the field being validated.\n   * @returns The params for the resource.\n   */\n  readonly params: (ctx: FieldContext<TValue, TPathKind>) => TParams;\n\n  /**\n   * A function that receives the resource params and returns a resource of the given params.\n   * The given params should be used as is to create the resource.\n   * The forms system will report the params as `undefined` when this validation doesn't need to be run.\n   *\n   * @param params The params to use for constructing the resource\n   * @returns A reference to the constructed resource.\n   */\n  readonly factory: (params: Signal<TParams | undefined>) => ResourceRef<TResult | undefined>;\n  /**\n   * A function to handle errors thrown by httpResource (HTTP errors, network errors, etc.).\n   * Receives the error and the field context, returns a list of validation errors.\n   */\n  readonly onError: (error: unknown, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;\n  /**\n   * A function that takes the resource result, and the current field context and maps it to a list\n   * of validation errors.\n   *\n   * @param result The resource result.\n   * @param ctx The context for the field the validator is attached to.\n   * @return A validation error, or list of validation errors to report based on the resource result.\n   *   The returned errors can optionally specify a field that the error should be targeted to.\n   *   A targeted error will show up as an error on its target field rather than the field being validated.\n   *   If a field is not given, the error is assumed to apply to the field being validated.\n   */\n  readonly onSuccess: MapToErrorsFn<TValue, TResult, TPathKind>;\n}\n\n/**\n * Adds async validation to the field corresponding to the given path based on a resource.\n * Async validation for a field only runs once all synchronous validation is passing.\n *\n * @param path A path indicating the field to bind the async validation logic to.\n * @param opts The async validation options.\n * @template TValue The type of value stored in the field being validated.\n * @template TParams The type of parameters to the resource.\n * @template TResult The type of result returned by the resource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @see [Signal Form Async Validation](guide/forms/signals/validation#async-validation)\n * @category validation\n * @experimental 21.0.0\n */\nexport function validateAsync<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  opts: AsyncValidatorOptions<TValue, TParams, TResult, TPathKind>,\n): void {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n\n  const RESOURCE = createManagedMetadataKey<ReturnType<typeof opts.factory>, TParams | undefined>(\n    opts.factory,\n  );\n  metadata(path, RESOURCE, (ctx) => {\n    const node = ctx.stateOf(path) as FieldNode;\n    const validationState = node.validationState;\n    if (validationState.shouldSkipValidation() || !validationState.syncValid()) {\n      return undefined;\n    }\n    return opts.params(ctx);\n  });\n\n  pathNode.builder.addAsyncErrorRule((ctx) => {\n    const res = ctx.state.metadata(RESOURCE)!;\n    let errors;\n    switch (res.status()) {\n      case 'idle':\n        return undefined;\n      case 'loading':\n      case 'reloading':\n        return 'pending';\n      case 'resolved':\n      case 'local':\n        if (!res.hasValue()) {\n          return undefined;\n        }\n        errors = opts.onSuccess(res.value()!, ctx as FieldContext<TValue, TPathKind>);\n        return addDefaultField(errors, ctx.fieldTree);\n      case 'error':\n        errors = opts.onError(res.error(), ctx as FieldContext<TValue, TPathKind>);\n        return addDefaultField(errors, ctx.fieldTree);\n    }\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {addDefaultField} from '../../../field/validation';\nimport {FieldPathNode} from '../../../schema/path_node';\nimport {assertPathIsCurrent} from '../../../schema/schema';\nimport type {FieldContext, PathKind, SchemaPath, SchemaPathRules, TreeValidator} from '../../types';\n\n/**\n * Adds logic to a field to determine if the field or any of its child fields has validation errors.\n *\n * @param path The target path to add the validation logic to.\n * @param logic A `TreeValidator` that returns the current validation errors.\n *   Errors returned by the validator may specify a target field to indicate an error on a child field.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function validateTree<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  logic: NoInfer<TreeValidator<TValue, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addSyncTreeErrorRule((ctx) =>\n    addDefaultField(logic(ctx as FieldContext<TValue, TPathKind>), ctx.fieldTree),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {resource, isPromise} from '@angular/core';\nimport type {StandardSchemaV1} from '@standard-schema/spec';\nimport {addDefaultField} from '../../../field/validation';\nimport type {FieldTree, LogicFn, SchemaPath, SchemaPathTree} from '../../types';\nimport {createMetadataKey, metadata} from '../metadata';\nimport {validateAsync} from './validate_async';\nimport {validateTree} from './validate_tree';\nimport {\n  BaseNgValidationError,\n  type ValidationErrorOptions,\n  type WithFieldTree,\n  type WithOptionalFieldTree,\n  type WithoutFieldTree,\n} from './validation_errors';\n\n/**\n * Utility type that removes a string index key when its value is `unknown`,\n * i.e. `{[key: string]: unknown}`. It allows specific string keys to pass through, even if their\n * value is `unknown`, e.g. `{key: unknown}`.\n *\n * @experimental 21.0.0\n */\nexport type RemoveStringIndexUnknownKey<K, V> = string extends K\n  ? unknown extends V\n    ? never\n    : K\n  : K;\n\n/**\n * Utility type that recursively ignores unknown string index properties on the given object.\n * We use this on the `TSchema` type in `validateStandardSchema` in order to accommodate Zod's\n * `looseObject` which includes `{[key: string]: unknown}` as part of the type.\n *\n * @experimental 21.0.0\n */\nexport type IgnoreUnknownProperties<T> =\n  T extends Record<PropertyKey, unknown>\n    ? {\n        [K in keyof T as RemoveStringIndexUnknownKey<K, T[K]>]: IgnoreUnknownProperties<T[K]>;\n      }\n    : T;\n\n/**\n * Validates a field using a `StandardSchemaV1` compatible validator (e.g. a Zod validator).\n *\n * See https://github.com/standard-schema/standard-schema for more about standard schema.\n *\n * @param path The `FieldPath` to the field to validate.\n * @param schema The standard schema compatible validator to use for validation, or a LogicFn that returns the schema.\n * @template TSchema The type validated by the schema. This may be either the full `TValue` type,\n *   or a partial of it.\n * @template TValue The type of value stored in the field being validated.\n *\n * @see [Signal Form Schema Validation](guide/forms/signals/validation#integration-with-schema-validation-libraries)\n * @category validation\n * @experimental 21.0.0\n */\nexport function validateStandardSchema<TSchema, TModel extends IgnoreUnknownProperties<TSchema>>(\n  path: SchemaPath<TModel> & SchemaPathTree<TModel>,\n  schema: StandardSchemaV1<TSchema> | LogicFn<TModel, StandardSchemaV1<unknown> | undefined>,\n) {\n  // We create both a sync and async validator because the standard schema validator can return\n  // either a sync result or a Promise, and we need to handle both cases. The sync validator\n  // handles the sync result, and the async validator handles the Promise.\n  // We memoize the result of the validation function here, so that it is only run once for both\n  // validators, it can then be passed through both sync & async validation.\n  type Result = StandardSchemaV1.Result<TSchema> | Promise<StandardSchemaV1.Result<TSchema>>;\n  const VALIDATOR_MEMO = metadata(\n    path as SchemaPath<TModel>,\n    createMetadataKey<Result | undefined>(),\n    (ctx) => {\n      const resolvedSchema = typeof schema === 'function' ? schema(ctx) : schema;\n      return resolvedSchema\n        ? (resolvedSchema['~standard'].validate(ctx.value()) as Result)\n        : undefined;\n    },\n  );\n\n  validateTree<TModel>(path, ({state, fieldTreeOf}) => {\n    // Skip sync validation if the result is a Promise or undefined.\n    const result = state.metadata(VALIDATOR_MEMO)!();\n    if (!result || isPromise(result)) {\n      return [];\n    }\n    return (\n      result?.issues?.map((issue) =>\n        standardIssueToFormTreeError(fieldTreeOf<TModel>(path), issue),\n      ) ?? []\n    );\n  });\n\n  validateAsync<\n    TModel,\n    Promise<StandardSchemaV1.Result<TSchema>> | undefined,\n    readonly StandardSchemaV1.Issue[]\n  >(path, {\n    params: ({state}) => {\n      // Skip async validation if the result is *not* a Promise.\n      const result = state.metadata(VALIDATOR_MEMO)!();\n      return result && isPromise(result) ? result : undefined;\n    },\n    factory: (params) => {\n      return resource({\n        params,\n        loader: async ({params}) => (await params)?.issues ?? [],\n      });\n    },\n    onSuccess: (issues, {fieldTreeOf}) => {\n      return issues.map((issue) => standardIssueToFormTreeError(fieldTreeOf<TModel>(path), issue));\n    },\n    onError: () => {},\n  });\n}\n\n/**\n * Create a standard schema issue error associated with the target field\n * @param issue The standard schema issue\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function standardSchemaError(\n  issue: StandardSchemaV1.Issue,\n  options: WithFieldTree<ValidationErrorOptions>,\n): StandardSchemaValidationError;\n/**\n * Create a standard schema issue error\n * @param issue The standard schema issue\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function standardSchemaError(\n  issue: StandardSchemaV1.Issue,\n  options?: ValidationErrorOptions,\n): WithoutFieldTree<StandardSchemaValidationError>;\nexport function standardSchemaError(\n  issue: StandardSchemaV1.Issue,\n  options?: ValidationErrorOptions,\n): WithOptionalFieldTree<StandardSchemaValidationError> {\n  return new StandardSchemaValidationError(issue, options);\n}\n\n/**\n * Converts a `StandardSchemaV1.Issue` to a `FormTreeError`.\n *\n * @param fieldTree The root field to which the issue's path is relative.\n * @param issue The `StandardSchemaV1.Issue` to convert.\n * @returns A `ValidationError` representing the issue.\n */\nfunction standardIssueToFormTreeError(\n  fieldTree: FieldTree<unknown>,\n  issue: StandardSchemaV1.Issue,\n): StandardSchemaValidationError {\n  let target = fieldTree as FieldTree<Record<PropertyKey, unknown>>;\n  for (const pathPart of issue.path ?? []) {\n    const pathKey = typeof pathPart === 'object' ? pathPart.key : pathPart;\n    target = target[pathKey] as FieldTree<Record<PropertyKey, unknown>>;\n  }\n  return addDefaultField(standardSchemaError(issue, {message: issue.message}), target);\n}\n\n/**\n * An error used to indicate an issue validating against a standard schema.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class StandardSchemaValidationError extends BaseNgValidationError {\n  override readonly kind = 'standardSchema';\n\n  constructor(\n    readonly issue: StandardSchemaV1.Issue,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {httpResource, HttpResourceOptions, HttpResourceRequest} from '@angular/common/http';\nimport {Signal} from '@angular/core';\nimport {\n  FieldContext,\n  SchemaPath,\n  PathKind,\n  TreeValidationResult,\n  SchemaPathRules,\n} from '../../types';\nimport {MapToErrorsFn, validateAsync} from './validate_async';\n\n/**\n * Options that indicate how to create an httpResource for async validation for a field,\n * and map its result to validation errors.\n *\n * @template TValue The type of value stored in the field being validated.\n * @template TResult The type of result returned by the httpResource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport interface HttpValidatorOptions<TValue, TResult, TPathKind extends PathKind = PathKind.Root> {\n  /**\n   * A function that receives the field context and returns the url or request for the httpResource.\n   * If given a URL, the underlying httpResource will perform an HTTP GET on it.\n   *\n   * @param ctx The field context for the field being validated.\n   * @returns The URL or request for creating the httpResource.\n   */\n  readonly request:\n    | ((ctx: FieldContext<TValue, TPathKind>) => string | undefined)\n    | ((ctx: FieldContext<TValue, TPathKind>) => HttpResourceRequest | undefined);\n\n  /**\n   * A function that takes the httpResource result, and the current field context and maps it to a\n   * list of validation errors.\n   *\n   * @param result The httpResource result.\n   * @param ctx The context for the field the validator is attached to.\n   * @return A validation error, or list of validation errors to report based on the httpResource result.\n   *   The returned errors can optionally specify a field that the error should be targeted to.\n   *   A targeted error will show up as an error on its target field rather than the field being validated.\n   *   If a field is not given, the error is assumed to apply to the field being validated.\n   */\n  readonly onSuccess: MapToErrorsFn<TValue, TResult, TPathKind>;\n\n  /**\n   * A function to handle errors thrown by httpResource (HTTP errors, network errors, etc.).\n   * Receives the error and the field context, returns a list of validation errors.\n   */\n  readonly onError: (error: unknown, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;\n  /**\n   * The options to use when creating the httpResource.\n   */\n  readonly options?: HttpResourceOptions<TResult, unknown>;\n}\n\n/**\n * Adds async validation to the field corresponding to the given path based on an httpResource.\n * Async validation for a field only runs once all synchronous validation is passing.\n *\n * @param path A path indicating the field to bind the async validation logic to.\n * @param opts The http validation options.\n * @template TValue The type of value stored in the field being validated.\n * @template TResult The type of result returned by the httpResource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @see [Signal Form Async Validation](guide/forms/signals/validation#async-validation)\n * @category validation\n * @experimental 21.0.0\n */\nexport function validateHttp<TValue, TResult = unknown, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  opts: HttpValidatorOptions<TValue, TResult, TPathKind>,\n) {\n  validateAsync(path, {\n    params: opts.request,\n    factory: (request: Signal<any>) => httpResource(request, opts.options),\n    onSuccess: opts.onSuccess,\n    onError: opts.onError,\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DEBOUNCER} from '../../field/debounce';\nimport {FieldPathNode} from '../../schema/path_node';\nimport {assertPathIsCurrent} from '../../schema/schema';\nimport type {Debouncer, PathKind, SchemaPath, SchemaPathRules} from '../types';\n\n/**\n * Configures the frequency at which a form field is updated by UI events.\n *\n * When this rule is applied, updates from the UI to the form model will be delayed until either\n * the field is touched, or the most recently debounced update resolves.\n *\n * @param path The target path to debounce.\n * @param durationOrDebouncer Either a debounce duration in milliseconds, or a custom\n *     {@link Debouncer} function.\n *\n * @experimental 21.0.0\n */\nexport function debounce<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  durationOrDebouncer: number | Debouncer<TValue, TPathKind>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  const debouncer =\n    typeof durationOrDebouncer === 'function'\n      ? durationOrDebouncer\n      : durationOrDebouncer > 0\n        ? debounceForDuration(durationOrDebouncer)\n        : immediate;\n  pathNode.builder.addMetadataRule(DEBOUNCER, () => debouncer);\n}\n\nfunction debounceForDuration(durationInMilliseconds: number): Debouncer<unknown> {\n  return (_context, abortSignal) => {\n    return new Promise((resolve) => {\n      let timeoutId: ReturnType<typeof setTimeout> | undefined;\n\n      const onAbort = () => {\n        clearTimeout(timeoutId);\n        resolve();\n      };\n\n      timeoutId = setTimeout(() => {\n        abortSignal.removeEventListener('abort', onAbort);\n        resolve();\n      }, durationInMilliseconds);\n\n      abortSignal.addEventListener('abort', onAbort, {once: true});\n    });\n  };\n}\n\nfunction immediate() {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken, type Signal, type WritableSignal} from '@angular/core';\nimport type {ValidationError} from '../api/rules';\n\n/**\n * DI token that provides a writable signal that controls can use to set the signal of parse errors\n * for the `FormField` directive. Used internally by `transformedValue`.\n *\n * @experimental 21.2.0\n */\nexport const FORM_FIELD_PARSE_ERRORS = new InjectionToken<\n  WritableSignal<Signal<readonly ValidationError.WithoutFieldTree[]> | undefined>\n>(typeof ngDevMode !== 'undefined' && ngDevMode ? 'FORM_FIELD_PARSE_ERRORS' : '');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {type Signal, linkedSignal} from '@angular/core';\nimport type {ValidationError} from '../api/rules';\nimport {normalizeErrors} from '../api/rules/validation/util';\nimport type {ParseResult} from '../api/transformed_value';\n\n/**\n * An object that handles parsing raw UI values into model values.\n */\nexport interface Parser<TRaw> {\n  /**\n   * Errors encountered during the last parse attempt.\n   */\n  errors: Signal<readonly ValidationError.WithoutFieldTree[]>;\n  /**\n   * Parses the given raw value and updates the underlying model value if successful.\n   */\n  setRawValue: (rawValue: TRaw) => void;\n}\n\n/**\n * Creates a {@link Parser} that synchronizes a raw value with an underlying model value.\n *\n * @param getValue Function to get the current model value.\n * @param setValue Function to update the model value.\n * @param parse Function to parse the raw value into a {@link ParseResult}.\n * @returns A {@link Parser} instance.\n */\nexport function createParser<TValue, TRaw>(\n  getValue: () => TValue,\n  setValue: (value: TValue) => void,\n  parse: (raw: TRaw) => ParseResult<TValue>,\n): Parser<TRaw> {\n  const errors = linkedSignal({\n    source: getValue,\n    computation: () => [] as readonly ValidationError.WithoutFieldTree[],\n  });\n\n  const setRawValue = (rawValue: TRaw) => {\n    const result = parse(rawValue);\n    errors.set(normalizeErrors(result.error));\n    if (result.value !== undefined) {\n      setValue(result.value);\n    }\n    // `errors` is a linked signal sourced from the model value; write parse errors after\n    // model updates so `{value, errors}` results do not get reset by the recomputation.\n    errors.set(normalizeErrors(result.error));\n  };\n\n  return {errors: errors.asReadonly(), setRawValue};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  inject,\n  linkedSignal,\n  type ModelSignal,\n  type Signal,\n  type WritableSignal,\n} from '@angular/core';\nimport {FORM_FIELD_PARSE_ERRORS} from '../directive/parse_errors';\nimport {createParser} from '../util/parser';\nimport type {ValidationError} from './rules';\nimport type {OneOrMany} from './types';\n\n/**\n * Result of parsing a raw value into a model value.\n */\nexport interface ParseResult<TValue> {\n  /**\n   * The parsed value. If omitted, the model is not updated.\n   */\n  readonly value?: TValue;\n  /**\n   * Errors encountered during parsing, if any.\n   */\n  readonly error?: OneOrMany<ValidationError.WithoutFieldTree>;\n}\n\n/**\n * Options for `transformedValue`.\n *\n * @experimental 21.2.0\n */\nexport interface TransformedValueOptions<TValue, TRaw> {\n  /**\n   * Parse the raw value into the model value.\n   *\n   * Should return an object containing the parsed result, which may contain:\n   *   - `value`: The parsed model value. If `undefined`, the model will not be updated.\n   *   - `error`: Any parse errors encountered. If `undefined`, no errors are reported.\n   */\n  parse: (rawValue: TRaw) => ParseResult<TValue>;\n\n  /**\n   * Format the model value into the raw value.\n   */\n  format: (value: TValue) => TRaw;\n}\n\n/**\n * A writable signal representing a \"raw\" UI value that is synchronized with a model signal\n * via parse/format transformations.\n *\n * @category control\n * @experimental 21.2.0\n */\nexport interface TransformedValueSignal<TRaw> extends WritableSignal<TRaw> {\n  /**\n   * The current parse errors resulting from the last transformation.\n   */\n  readonly parseErrors: Signal<readonly ValidationError.WithoutFieldTree[]>;\n}\n\n/**\n * Creates a writable signal representing a \"raw\" UI value that is transformed to/from a model\n * value via `parse` and `format` functions.\n *\n * This utility simplifies the creation of custom form controls that parse a user-facing value\n * representation into an underlying model value. For example, a numeric input that displays and\n * accepts string values but stores a number.\n *\n * Parse errors are exposed via the returned signals `parseErrors()` property.\n * When `transformedValue` is used within a Signal Forms field context, parse errors are also\n * reported to the nearest field automatically. When no field context is present, no automatic\n * reporting occurs and `parseErrors` can be consumed directly.\n *\n * Note: `parse` may return both a `value` and an `error`. Returning `value` updates the model;\n * omitting it leaves the model unchanged.\n *\n * @param value The model signal to synchronize with.\n * @param options Configuration including `parse` and `format` functions.\n * @returns A `TransformedValueSignal` representing the raw value with parse error tracking.\n * @experimental 21.2.0\n *\n * @example\n * ```ts\n * @Component({\n *   selector: 'number-input',\n *   template: `<input [value]=\"rawValue()\" (input)=\"rawValue.set($event.target.value)\" />`,\n * })\n * export class NumberInput implements FormValueControl<number | null> {\n *   readonly value = model.required<number | null>();\n *\n *   protected readonly rawValue = transformedValue(this.value, {\n *     parse: (val) => {\n *       if (val === '') return {value: null};\n *       const num = Number(val);\n *       if (Number.isNaN(num)) {\n *         return {error: {kind: 'parse', message: `${val} is not numeric`}};\n *       }\n *       return {value: num};\n *     },\n *     format: (val) => val?.toString() ?? '',\n *   });\n * }\n * ```\n */\nexport function transformedValue<TValue, TRaw>(\n  value: ModelSignal<TValue>,\n  options: TransformedValueOptions<TValue, TRaw>,\n): TransformedValueSignal<TRaw> {\n  const {parse, format} = options;\n  const parser = createParser(value, value.set, parse);\n\n  // Wire up the parse errors from the parser to the form field.\n  const formFieldParseErrors = inject(FORM_FIELD_PARSE_ERRORS, {self: true, optional: true});\n  if (formFieldParseErrors) {\n    formFieldParseErrors.set(parser.errors);\n  }\n\n  // Create the result signal with overridden set/update and a `parseErrors` property.\n  const rawValue = linkedSignal(() => format(value()));\n  const result = rawValue as WritableSignal<TRaw> & {\n    parseErrors: Signal<readonly ValidationError.WithoutFieldTree[]>;\n  };\n  result.parseErrors = parser.errors;\n  const originalSet = result.set.bind(result);\n\n  // Notify the parser when `set` or `update` is called on the raw value\n  result.set = (newRawValue: TRaw) => {\n    parser.setRawValue(newRawValue);\n    originalSet(newRawValue);\n  };\n  result.update = (updateFn: (value: TRaw) => TRaw) => {\n    result.set(updateFn(rawValue()));\n  };\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {RuntimeError as RuntimeError} from '@angular/core';\nimport {RuntimeErrorCode} from '../errors';\nimport {signalErrorsToValidationErrors} from '../compat/validation_errors';\n\nimport {\n  ControlValueAccessor,\n  Validators,\n  type AbstractControl,\n  type FormControlStatus,\n  type ValidationErrors,\n  type ValidatorFn,\n} from '@angular/forms';\nimport type {FieldState} from '../api/types';\n\n// TODO: Also consider supporting (if possible):\n// - hasError\n// - getError\n// - reset\n// - name\n// - path\n// - markAs[Touched,Dirty,etc.]\n\n/**\n * Represents a combination of `NgControl` and `AbstractControl`.\n *\n * Note: We have this separate interface, rather than implementing the relevant parts of the two\n * controls with something like `InteropNgControl implements Pick<NgControl, ...>, Pick<AbstractControl, ...>`\n * because it confuses the internal JS minifier which can cause collisions in field names.\n */\ninterface CombinedControl {\n  value: any;\n  valid: boolean;\n  invalid: boolean;\n  touched: boolean;\n  untouched: boolean;\n  disabled: boolean;\n  enabled: boolean;\n  errors: ValidationErrors | null;\n  pristine: boolean;\n  dirty: boolean;\n  status: FormControlStatus;\n  control: AbstractControl<any, any>;\n  valueAccessor: ControlValueAccessor | null;\n  hasValidator(validator: ValidatorFn): boolean;\n  updateValueAndValidity(): void;\n}\n\n/**\n * A fake version of `NgControl` provided by the `Field` directive. This allows interoperability\n * with a wider range of components designed to work with reactive forms, in particular ones that\n * inject the `NgControl`. The interop control does not implement *all* properties and methods of\n * the real `NgControl`, but does implement some of the most commonly used ones that have a clear\n * equivalent in signal forms.\n */\nexport class InteropNgControl implements CombinedControl {\n  constructor(protected field: () => FieldState<unknown>) {}\n\n  readonly control: AbstractControl<any, any> = this as unknown as AbstractControl<any, any>;\n\n  get value(): any {\n    return this.field().value();\n  }\n\n  get valid(): boolean {\n    return this.field().valid();\n  }\n\n  get invalid(): boolean {\n    return this.field().invalid();\n  }\n\n  get pending(): boolean | null {\n    return this.field().pending();\n  }\n\n  get disabled(): boolean {\n    return this.field().disabled();\n  }\n\n  get enabled(): boolean {\n    return !this.field().disabled();\n  }\n\n  get errors(): ValidationErrors | null {\n    return signalErrorsToValidationErrors(this.field().errors());\n  }\n\n  get pristine(): boolean {\n    return !this.field().dirty();\n  }\n\n  get dirty(): boolean {\n    return this.field().dirty();\n  }\n\n  get touched(): boolean {\n    return this.field().touched();\n  }\n\n  get untouched(): boolean {\n    return !this.field().touched();\n  }\n\n  get status(): FormControlStatus {\n    if (this.field().disabled()) {\n      return 'DISABLED';\n    }\n    if (this.field().valid()) {\n      return 'VALID';\n    }\n    if (this.field().invalid()) {\n      return 'INVALID';\n    }\n    if (this.field().pending()) {\n      return 'PENDING';\n    }\n    throw new RuntimeError(\n      RuntimeErrorCode.UNKNOWN_STATUS,\n      ngDevMode && 'Unknown form control status',\n    );\n  }\n\n  valueAccessor: ControlValueAccessor | null = null;\n\n  hasValidator(validator: ValidatorFn): boolean {\n    // This addresses a common case where users look for the presence of `Validators.required` to\n    // determine whether or not to show a required \"*\" indicator in the UI.\n    if (validator === Validators.required) {\n      return this.field().required();\n    }\n    return false;\n  }\n\n  updateValueAndValidity() {\n    // No-op since value and validity are always up to date in signal forms.\n    // We offer this method so that reactive forms code attempting to call it doesn't error.\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {FieldState} from '../api/types';\n\n/**\n * Branded type for the public name of an input we bind on control components or DOM elements.\n */\nexport type ControlBindingKey = string & {__brand: 'ControlBindingKey'};\n\n/**\n * A map of field state properties to control binding name.\n *\n * This excludes `controlValue` whose corresponding control binding name differs between control\n * types.\n *\n * The control binding name can be used for inputs or attributes (since DOM attributes are case\n * insensitive).\n */\nconst FIELD_STATE_KEY_TO_CONTROL_BINDING = {\n  disabled: 'disabled' as ControlBindingKey,\n  disabledReasons: 'disabledReasons' as ControlBindingKey,\n  dirty: 'dirty' as ControlBindingKey,\n  errors: 'errors' as ControlBindingKey,\n  hidden: 'hidden' as ControlBindingKey,\n  invalid: 'invalid' as ControlBindingKey,\n  max: 'max' as ControlBindingKey,\n  maxLength: 'maxLength' as ControlBindingKey,\n  min: 'min' as ControlBindingKey,\n  minLength: 'minLength' as ControlBindingKey,\n  name: 'name' as ControlBindingKey,\n  pattern: 'pattern' as ControlBindingKey,\n  pending: 'pending' as ControlBindingKey,\n  readonly: 'readonly' as ControlBindingKey,\n  required: 'required' as ControlBindingKey,\n  touched: 'touched' as ControlBindingKey,\n} as const satisfies {[K in keyof FieldState<unknown>]?: ControlBindingKey};\n\n/**\n * Inverts `FIELD_STATE_KEY_TO_CONTROL_BINDING` to look up the minified name of the corresponding\n * field state property from its control binding name.\n */\nconst CONTROL_BINDING_TO_FIELD_STATE_KEY = /* @__PURE__ */ (() => {\n  const map = {} as Record<ControlBindingKey, keyof typeof FIELD_STATE_KEY_TO_CONTROL_BINDING>;\n  for (const key of Object.keys(FIELD_STATE_KEY_TO_CONTROL_BINDING) as Array<\n    keyof typeof FIELD_STATE_KEY_TO_CONTROL_BINDING\n  >) {\n    map[FIELD_STATE_KEY_TO_CONTROL_BINDING[key]] = key;\n  }\n  return map;\n})();\n\nexport function readFieldStateBindingValue(\n  fieldState: FieldState<unknown>,\n  key: ControlBindingKey,\n): unknown {\n  const property = CONTROL_BINDING_TO_FIELD_STATE_KEY[key];\n  return fieldState[property]?.();\n}\n\n/** The keys of {@link FIELD_STATE_KEY_TO_CONTROL_BINDING} */\nexport const CONTROL_BINDING_NAMES = /* @__PURE__ */ (() =>\n  Object.values(FIELD_STATE_KEY_TO_CONTROL_BINDING))() as Array<ControlBindingKey>;\n\nexport function createBindings<TKey extends string>(): {[K in TKey]?: unknown} {\n  return {};\n}\n\nexport function bindingUpdated<TKey extends string>(\n  bindings: {[K in TKey]?: unknown},\n  key: TKey,\n  value: unknown,\n) {\n  if (bindings[key] !== value) {\n    bindings[key] = value;\n    return true;\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {type Renderer2, untracked} from '@angular/core';\nimport {NativeInputParseError, WithoutFieldTree} from '../api/rules';\nimport type {ParseResult} from '../api/transformed_value';\n\n/**\n * Supported native control element types.\n *\n * The `type` property of a {@link HTMLTextAreaElement} should always be 'textarea', but the\n * TypeScript DOM API type definition lacks this detail, so we include it here.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLTextAreaElement/type\n */\nexport type NativeFormControl =\n  | HTMLInputElement\n  | HTMLSelectElement\n  | (HTMLTextAreaElement & {type: 'textarea'});\n\nexport function isNativeFormElement(element: HTMLElement): element is NativeFormControl {\n  return (\n    element.tagName === 'INPUT' || element.tagName === 'SELECT' || element.tagName === 'TEXTAREA'\n  );\n}\n\nexport function isNumericFormElement(element: HTMLElement): boolean {\n  if (element.tagName !== 'INPUT') {\n    return false;\n  }\n\n  const type = (element as HTMLInputElement).type;\n  return (\n    type === 'date' ||\n    type === 'datetime-local' ||\n    type === 'month' ||\n    type === 'number' ||\n    type === 'range' ||\n    type === 'time' ||\n    type === 'week'\n  );\n}\n\nexport function isTextualFormElement(element: HTMLElement): boolean {\n  return element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';\n}\n\n/**\n * Returns the value from a native control element.\n *\n * @param element The native control element.\n * @param currentValue A function that returns the current value from the control's corresponding\n *   field state.\n *\n * The type of the returned value depends on the `type` property of the control, and will attempt to\n * match the current value's type. For example, the value of `<input type=\"number\">` can be read as\n * a `string` or a `number`. If the current value is a `number`, then this will return a `number`.\n * Otherwise, this will return the value as a `string`.\n */\nexport function getNativeControlValue(\n  element: NativeFormControl,\n  currentValue: () => unknown,\n): ParseResult<unknown> {\n  let modelValue: unknown;\n\n  if (element.validity.badInput) {\n    return {\n      error: new NativeInputParseError() as WithoutFieldTree<NativeInputParseError>,\n    };\n  }\n\n  // Special cases for specific input types.\n  switch (element.type) {\n    case 'checkbox':\n      return {value: element.checked};\n    case 'number':\n    case 'range':\n    case 'datetime-local':\n      // We can read a `number` or a `string` from this input type. Prefer whichever is consistent\n      // with the current type.\n      modelValue = untracked(currentValue);\n      if (typeof modelValue === 'number' || modelValue === null) {\n        return {value: element.value === '' ? null : element.valueAsNumber};\n      }\n      break;\n    case 'date':\n    case 'month':\n    case 'time':\n    case 'week':\n      // We can read a `Date | null`, `number`, or `string` from this input type. Prefer whichever\n      // is consistent with the current type.\n      modelValue = untracked(currentValue);\n      if (modelValue === null || modelValue instanceof Date) {\n        return {value: element.valueAsDate};\n      } else if (typeof modelValue === 'number') {\n        return {value: element.valueAsNumber};\n      }\n      break;\n  }\n\n  // Default to reading the value as a string.\n  return {value: element.value};\n}\n\n/**\n * Sets a native control element's value.\n *\n * @param element The native control element.\n * @param value The new value to set.\n */\nexport function setNativeControlValue(element: NativeFormControl, value: unknown) {\n  // Special cases for specific input types.\n  switch (element.type) {\n    case 'checkbox':\n      element.checked = value as boolean;\n      return;\n    case 'radio':\n      // Although HTML behavior is to clear the input already, we do this just in case. It seems\n      // like it might be necessary in certain environments (e.g. Domino).\n      element.checked = value === element.value;\n      return;\n    case 'number':\n    case 'range':\n    case 'datetime-local':\n      // This input type can receive a `number` or a `string`.\n      if (typeof value === 'number') {\n        setNativeNumberControlValue(element, value);\n        return;\n      } else if (value === null) {\n        element.value = '';\n        return;\n      }\n      break;\n    case 'date':\n    case 'month':\n    case 'time':\n    case 'week':\n      // This input type can receive a `Date | null` or a `number` or a `string`.\n      if (value === null || value instanceof Date) {\n        element.valueAsDate = value;\n        return;\n      } else if (typeof value === 'number') {\n        setNativeNumberControlValue(element, value);\n        return;\n      }\n  }\n\n  // Default to setting the value as a string.\n  element.value = value as string;\n}\n\n/** Writes a value to a native <input type=\"number\">. */\nexport function setNativeNumberControlValue(element: HTMLInputElement, value: number) {\n  // Writing `NaN` causes a warning in the console, so we instead write `''`.\n  // This allows the user to safely use `NaN` as a number value that means \"clear the input\".\n  if (isNaN(value)) {\n    element.value = '';\n  } else {\n    element.valueAsNumber = value;\n  }\n}\n\n/**\n * Updates the native DOM property on the given node.\n *\n * @param key The control binding key (identifies the property type, e.g. disabled, required).\n * @param name The DOM attribute/property name.\n * @param value The new value for the property.\n */\nexport function setNativeDomProperty(\n  renderer: Renderer2,\n  element: NativeFormControl,\n  name: 'name' | 'disabled' | 'required' | 'readonly' | 'min' | 'max' | 'minLength' | 'maxLength',\n  value: string | number | undefined,\n) {\n  switch (name) {\n    case 'name':\n      renderer.setAttribute(element, name, value as string);\n      break;\n    case 'disabled':\n    case 'readonly':\n    case 'required':\n      if (value) {\n        renderer.setAttribute(element, name, '');\n      } else {\n        renderer.removeAttribute(element, name);\n      }\n      break;\n    case 'max':\n    case 'min':\n    case 'minLength':\n    case 'maxLength':\n      if (value !== undefined) {\n        renderer.setAttribute(element, name, value.toString());\n      } else {\n        renderer.removeAttribute(element, name);\n      }\n      break;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {ControlDirectiveHost as ControlDirectiveHost} from '@angular/core';\nimport type {FormField} from './form_field_directive';\nimport {\n  bindingUpdated,\n  CONTROL_BINDING_NAMES,\n  type ControlBindingKey,\n  createBindings,\n  readFieldStateBindingValue,\n} from './bindings';\nimport {setNativeDomProperty} from './native';\nimport {FormUiControl} from '../api/control';\n\nexport function customControlCreate(\n  host: ControlDirectiveHost,\n  parent: FormField<unknown>,\n): () => void {\n  host.listenToCustomControlModel((value) => parent.state().controlValue.set(value));\n  host.listenToCustomControlOutput('touchedChange', () => parent.state().markAsTouched());\n\n  parent.registerAsBinding(host.customControl as FormUiControl);\n\n  const bindings = createBindings<ControlBindingKey | 'controlValue'>();\n  return () => {\n    const state = parent.state();\n    // Bind custom form control model ('value' or 'checked').\n    const controlValue = state.controlValue();\n    if (bindingUpdated(bindings, 'controlValue', controlValue)) {\n      host.setCustomControlModelInput(controlValue);\n    }\n\n    // Bind remaining field state properties.\n    for (const name of CONTROL_BINDING_NAMES) {\n      let value: unknown;\n      if (name === 'errors') {\n        value = parent.errors();\n      } else {\n        value = readFieldStateBindingValue(state, name);\n      }\n      if (bindingUpdated(bindings, name, value)) {\n        host.setInputOnDirectives(name, value);\n\n        // If the host node is a native control, we can bind field state properties to native\n        // properties for any that weren't defined as inputs on the custom control.\n        if (parent.elementAcceptsNativeProperty(name) && !host.customControlHasInput(name)) {\n          setNativeDomProperty(\n            parent.renderer,\n            parent.nativeFormElement!,\n            name,\n            value as string | number | undefined,\n          );\n        }\n      }\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {untracked, type ControlDirectiveHost as ControlDirectiveHost} from '@angular/core';\nimport {\n  bindingUpdated,\n  CONTROL_BINDING_NAMES,\n  type ControlBindingKey,\n  createBindings,\n  readFieldStateBindingValue,\n} from './bindings';\nimport {setNativeDomProperty} from './native';\nimport type {FormField} from './form_field_directive';\n\nexport function cvaControlCreate(\n  host: ControlDirectiveHost,\n  parent: FormField<unknown>,\n): () => void {\n  parent.controlValueAccessor!.registerOnChange((value: unknown) =>\n    parent.state().controlValue.set(value as any),\n  );\n  parent.controlValueAccessor!.registerOnTouched(() => parent.state().markAsTouched());\n  parent.registerAsBinding();\n\n  const bindings = createBindings<ControlBindingKey | 'controlValue'>();\n  return () => {\n    const fieldState = parent.state();\n    const value = fieldState.value();\n    if (bindingUpdated(bindings, 'controlValue', value)) {\n      // We don't know if the interop control has underlying signals, so we must use `untracked` to\n      // prevent writing to a signal in a reactive context.\n      untracked(() => parent.controlValueAccessor!.writeValue(value));\n    }\n\n    for (const name of CONTROL_BINDING_NAMES) {\n      const value = readFieldStateBindingValue(fieldState, name);\n      if (bindingUpdated(bindings, name, value)) {\n        const propertyWasSet = host.setInputOnDirectives(name, value);\n        if (name === 'disabled' && parent.controlValueAccessor!.setDisabledState) {\n          untracked(() => parent.controlValueAccessor!.setDisabledState!(value as boolean));\n        } else if (!propertyWasSet && parent.elementAcceptsNativeProperty(name)) {\n          // Fall back to native DOM properties.\n          setNativeDomProperty(\n            parent.renderer,\n            parent.nativeFormElement,\n            name,\n            value as string | number | undefined,\n          );\n        }\n      }\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {DestroyRef} from '@angular/core';\n\n/**\n * Creates a `MutationObserver` to observe changes to the available `<option>`s for this select.\n *\n * @param select The native `<select>` element to observe.\n * @param lView The `LView` that contains the native form control.\n * @param tNode The `TNode` of the native form control.\n * @return The newly created `MutationObserver`.\n */\nexport function observeSelectMutations(\n  select: HTMLSelectElement,\n  onMutation: () => void,\n  destroyRef: DestroyRef,\n): void {\n  if (typeof MutationObserver !== 'function') {\n    // Observing mutations is best-effort.\n    return;\n  }\n\n  const observer = new MutationObserver((mutations) => {\n    if (mutations.some((m) => isRelevantSelectMutation(m))) {\n      onMutation();\n    }\n  });\n  observer.observe(select, {\n    attributes: true,\n    attributeFilter: ['value'],\n    // We watch the character data, because an `<option>` with no explicit `value` property set uses\n    // its text content as its value.\n    // (See https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionElement/value)\n    characterData: true,\n    childList: true,\n    subtree: true,\n  });\n  destroyRef.onDestroy(() => observer.disconnect());\n}\n\n/**\n * Checks if a given mutation record is relevant for resyncing a <select>.\n * In general its relevant if:\n * - Non comment content of the select changed\n * - The value attribute of an option changed.\n */\nfunction isRelevantSelectMutation(mutation: MutationRecord) {\n  // Consider changes that may add / remove options, or change their text content.\n  if (mutation.type === 'childList' || mutation.type === 'characterData') {\n    // If the target element is a comment it's not relevant.\n    if (mutation.target instanceof Comment) {\n      return false;\n    }\n    // Otherwise if any non-comment nodes were added / removed it is relevant.\n    for (const node of mutation.addedNodes) {\n      if (!(node instanceof Comment)) {\n        return true;\n      }\n    }\n    for (const node of mutation.removedNodes) {\n      if (!(node instanceof Comment)) {\n        return true;\n      }\n    }\n    // Otherwise it's not relevant.\n    return false;\n  }\n  // If the value attribute of an option changed, it's relevant.\n  if (mutation.type === 'attributes' && mutation.target instanceof HTMLOptionElement) {\n    return true;\n  }\n  // Everything else is not relevant.\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {\n  type ControlDirectiveHost as ControlDirectiveHost,\n  type Signal,\n  type WritableSignal,\n} from '@angular/core';\nimport type {ValidationError} from '../api/rules';\nimport {createParser} from '../util/parser';\nimport {\n  bindingUpdated,\n  CONTROL_BINDING_NAMES,\n  createBindings,\n  readFieldStateBindingValue,\n  type ControlBindingKey,\n} from './bindings';\nimport type {FormField} from './form_field_directive';\nimport {getNativeControlValue, setNativeControlValue, setNativeDomProperty} from './native';\nimport {observeSelectMutations} from './select';\n\nexport function nativeControlCreate(\n  host: ControlDirectiveHost,\n  parent: FormField<unknown>,\n  parseErrorsSource: WritableSignal<\n    Signal<readonly ValidationError.WithoutFieldTree[]> | undefined\n  >,\n): () => void {\n  let updateMode = false;\n  const input = parent.nativeFormElement;\n\n  // TODO: (perf) ok to always create this?\n  const parser = createParser(\n    // Read from the model value\n    () => parent.state().value(),\n    // Write to the buffered \"control value\"\n    (rawValue: unknown) => parent.state().controlValue.set(rawValue),\n    // Our parse function doesn't care about the raw value that gets passed in,\n    // It just reads the newly parsed value directly off the input element.\n    () => getNativeControlValue(input, parent.state().value),\n  );\n\n  parseErrorsSource.set(parser.errors);\n  // Pass undefined as the raw value since the parse function doesn't care about it.\n  host.listenToDom('input', () => parser.setRawValue(undefined));\n  host.listenToDom('blur', () => parent.state().markAsTouched());\n\n  parent.registerAsBinding();\n\n  // The native `<select>` tracks its `value` by keeping track of the selected `<option>`.\n  // Therefore if we set the value to an arbitrary string *before* the corresponding option has been\n  // created, the `<select>` will ignore it.\n  //\n  // This means that we need to know when an `<option>` is created, destroyed, or has its `value`\n  // changed so that we can re-sync the `<select>` to the field state's value. We implement this\n  // using a `MutationObserver` that we create to observe `<option>` changes.\n  if (input.tagName === 'SELECT') {\n    observeSelectMutations(\n      input as HTMLSelectElement,\n      () => {\n        // It's not legal to access `parent.state()` until update mode has run, but\n        // `observeSelectMutations` may fire earlier. It's okay to ignore these early notifications\n        // because we'll write `input.value` in that first update pass anyway.\n        if (!updateMode) {\n          return;\n        }\n        input.value = parent.state().controlValue() as string;\n      },\n      parent.destroyRef,\n    );\n  }\n\n  const bindings = createBindings<ControlBindingKey | 'controlValue'>();\n\n  return () => {\n    const state = parent.state();\n    const controlValue = state.controlValue();\n    if (bindingUpdated(bindings, 'controlValue', controlValue)) {\n      setNativeControlValue(input, controlValue);\n    }\n\n    for (const name of CONTROL_BINDING_NAMES) {\n      const value = readFieldStateBindingValue(state, name);\n      if (bindingUpdated(bindings, name, value)) {\n        host.setInputOnDirectives(name, value);\n        if (parent.elementAcceptsNativeProperty(name)) {\n          setNativeDomProperty(parent.renderer, input, name, value as string | number | undefined);\n        }\n      }\n    }\n\n    updateMode = true;\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  afterRenderEffect,\n  computed,\n  type ControlDirectiveHost as ControlDirectiveHost,\n  DestroyRef,\n  Directive,\n  effect,\n  ElementRef,\n  formatRuntimeError as formatRuntimeError,\n  inject,\n  InjectionToken,\n  Injector,\n  input,\n  Renderer2,\n  RuntimeError as RuntimeError,\n  type Signal,\n  signal,\n  untracked,\n} from '@angular/core';\nimport {type ControlValueAccessor, NG_VALUE_ACCESSOR, NgControl} from '@angular/forms';\nimport {type ValidationError} from '../api/rules';\nimport type {Field} from '../api/types';\nimport {InteropNgControl} from '../controls/interop_ng_control';\nimport {RuntimeErrorCode} from '../errors';\nimport {SIGNAL_FORMS_CONFIG} from '../field/di';\nimport type {FieldNode} from '../field/node';\nimport {bindingUpdated, type ControlBindingKey, createBindings} from './bindings';\nimport {customControlCreate} from './control_custom';\nimport {cvaControlCreate} from './control_cva';\nimport {nativeControlCreate} from './control_native';\nimport {\n  isNativeFormElement,\n  isNumericFormElement,\n  isTextualFormElement,\n  type NativeFormControl,\n} from './native';\nimport {FORM_FIELD_PARSE_ERRORS} from './parse_errors';\n\nexport const NgFieldDirective: unique symbol = Symbol();\n\nexport interface FormFieldBindingOptions {\n  /**\n   * Focuses the binding.\n   *\n   * If not specified, Signal Forms will attempt to focus the host element of the `FormField` when\n   * asked to focus this binding.\n   */\n  readonly focus?: (focusOptions?: FocusOptions) => void;\n}\n\n/**\n * Lightweight DI token provided by the {@link FormField} directive.\n *\n * @category control\n * @experimental 21.0.0\n */\nexport const FORM_FIELD = new InjectionToken<FormField<unknown>>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'FORM_FIELD' : '',\n);\n\n/**\n * Binds a form `FieldTree` to a UI control that edits it. A UI control can be one of several things:\n * 1. A native HTML input or textarea\n * 2. A signal forms custom control that implements `FormValueControl` or `FormCheckboxControl`\n * 3. A component that provides a `ControlValueAccessor`. This should only be used for backwards\n *    compatibility with reactive forms. Prefer options (1) and (2).\n *\n * This directive has several responsibilities:\n * 1. Two-way binds the field state's value with the UI control's value\n * 2. Binds additional forms related state on the field state to the UI control (disabled, required, etc.)\n * 3. Relays relevant events on the control to the field state (e.g. marks touched on blur)\n * 4. Provides a fake `NgControl` that implements a subset of the features available on the\n *    reactive forms `NgControl`. This is provided to improve interoperability with controls\n *    designed to work with reactive forms. It should not be used by controls written for signal\n *    forms.\n *\n * @category control\n * @experimental 21.0.0\n */\n@Directive({\n  selector: '[formField]',\n  exportAs: 'formField',\n  providers: [\n    {provide: FORM_FIELD, useExisting: FormField},\n    {provide: NgControl, useFactory: () => inject(FormField).interopNgControl},\n    {\n      provide: FORM_FIELD_PARSE_ERRORS,\n      useFactory: () => inject(FormField).parseErrorsSource,\n    },\n  ],\n})\nexport class FormField<T> {\n  readonly field = input.required<Field<T>>({alias: 'formField'});\n\n  /** @internal */\n  readonly renderer = inject(Renderer2);\n\n  /** @internal */\n  readonly destroyRef = inject(DestroyRef);\n\n  /**\n   * `FieldState` for the currently bound field.\n   */\n  readonly state = computed(() => this.field()());\n\n  /**\n   * The node injector for the element this field binding.\n   */\n  readonly injector = inject(Injector);\n\n  /**\n   * The DOM element hosting this field binding.\n   */\n  readonly element = inject<ElementRef<HTMLElement>>(ElementRef).nativeElement;\n\n  // Compute some helper booleans about the type of element we're sitting on.\n  private readonly elementIsNativeFormElement = isNativeFormElement(this.element);\n  private readonly elementAcceptsNumericValues = isNumericFormElement(this.element);\n  private readonly elementAcceptsTextualValues = isTextualFormElement(this.element);\n\n  /**\n   * Utility that casts `this.element` to `NativeFormControl` to avoid repeated type guards. Only\n   * safe to access when `elementIsNativeFormElement` is true.\n   *\n   * @internal\n   */\n  readonly nativeFormElement: NativeFormControl = (this.elementIsNativeFormElement\n    ? this.element\n    : undefined) as NativeFormControl;\n\n  /**\n   * Current focus implementation, set by `registerAsBinding`.\n   */\n  private focuser = (options?: FocusOptions) => this.element.focus(options);\n\n  /** Any `ControlValueAccessor` instances provided on the host element. */\n  private readonly controlValueAccessors = inject(NG_VALUE_ACCESSOR, {optional: true, self: true});\n\n  private readonly config = inject(SIGNAL_FORMS_CONFIG, {optional: true});\n\n  private readonly parseErrorsSource = signal<\n    Signal<readonly ValidationError.WithoutFieldTree[]> | undefined\n  >(undefined);\n\n  /** A lazily instantiated fake `NgControl`. */\n  private _interopNgControl: InteropNgControl | undefined;\n\n  /** Lazily instantiates a fake `NgControl` for this form field. */\n  protected get interopNgControl(): InteropNgControl {\n    return (this._interopNgControl ??= new InteropNgControl(this.state));\n  }\n\n  /** @internal */\n  readonly parseErrors = computed<ValidationError.WithFormField[]>(\n    () =>\n      this.parseErrorsSource()?.().map((err) => ({\n        ...err,\n        fieldTree: untracked(this.state).fieldTree,\n        formField: this as FormField<unknown>,\n      })) ?? [],\n  );\n\n  /** Errors associated with this form field. */\n  readonly errors = computed(() =>\n    this.state()\n      .errors()\n      .filter((err) => !err.formField || err.formField === this),\n  );\n\n  /** Whether this `FormField` has been registered as a binding on its associated `FieldState`. */\n  private isFieldBinding = false;\n\n  /**\n   * A `ControlValueAccessor`, if configured, for the host component.\n   *\n   * @internal\n   */\n  get controlValueAccessor(): ControlValueAccessor | undefined {\n    return this.controlValueAccessors?.[0] ?? this.interopNgControl?.valueAccessor ?? undefined;\n  }\n\n  /**\n   * Creates an `afterRenderEffect` that applies the configured class bindings to the host element\n   * if needed.\n   */\n  private installClassBindingEffect(): void {\n    const classes = Object.entries(this.config?.classes ?? {}).map(\n      ([className, computation]) =>\n        [className, computed(() => computation(this as FormField<unknown>))] as const,\n    );\n    if (classes.length === 0) {\n      return;\n    }\n\n    // If we have class bindings to apply, set up an afterRenderEffect to apply them.\n    const bindings = createBindings<string>();\n    afterRenderEffect(\n      {\n        write: () => {\n          for (const [className, computation] of classes) {\n            const active = computation();\n            if (bindingUpdated(bindings, className, active)) {\n              if (active) {\n                this.renderer.addClass(this.element, className);\n              } else {\n                this.renderer.removeClass(this.element, className);\n              }\n            }\n          }\n        },\n      },\n      {injector: this.injector},\n    );\n  }\n\n  /**\n   * Focuses this field binding.\n   *\n   * By default, this will focus the host DOM element. However, custom `FormUiControl`s can\n   * implement custom focusing behavior.\n   */\n  focus(options?: FocusOptions): void {\n    this.focuser(options);\n  }\n\n  /**\n   * Registers this `FormField` as a binding on its associated `FieldState`.\n   *\n   * This method should be called at most once for a given `FormField`. A `FormField` placed on a\n   * custom control (`FormUiControl`) automatically registers that custom control as a binding.\n   */\n  registerAsBinding(bindingOptions?: FormFieldBindingOptions): void {\n    if (this.isFieldBinding) {\n      throw new RuntimeError(\n        RuntimeErrorCode.BINDING_ALREADY_REGISTERED,\n        typeof ngDevMode !== 'undefined' &&\n          ngDevMode &&\n          'FormField already registered as a binding',\n      );\n    }\n    this.isFieldBinding = true;\n\n    this.installClassBindingEffect();\n\n    if (bindingOptions?.focus) {\n      this.focuser = (focusOptions?: FocusOptions) => bindingOptions.focus!(focusOptions);\n    }\n\n    // Register this control on the field state it is currently bound to. We do this at the end of\n    // initialization so that it only runs if we are actually syncing with this control\n    // (as opposed to just passing the field state through to its `formField` input).\n    effect(\n      (onCleanup) => {\n        const fieldNode = this.state() as unknown as FieldNode;\n        fieldNode.nodeState.formFieldBindings.update((controls) => [\n          ...controls,\n          this as FormField<unknown>,\n        ]);\n        onCleanup(() => {\n          fieldNode.nodeState.formFieldBindings.update((controls) =>\n            controls.filter((c) => c !== this),\n          );\n        });\n      },\n      {injector: this.injector},\n    );\n\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n      effect(\n        () => {\n          const fieldNode = this.state() as unknown as FieldNode;\n          if (fieldNode.hidden()) {\n            const path = fieldNode.structure.pathKeys().join('.') || '<root>';\n            console.warn(\n              formatRuntimeError(\n                RuntimeErrorCode.RENDERED_HIDDEN_FIELD,\n                `Field '${path}' is hidden but is being rendered. ` +\n                  `Hidden fields should be removed from the DOM using @if.`,\n              ),\n            );\n          }\n        },\n        {injector: this.injector},\n      );\n    }\n  }\n\n  /**\n   * The presence of this symbol tells the template type-checker that this directive is a control\n   * directive and should be type-checked as such. We don't use the `ngControlCreate` method below\n   * as it's marked internal and removed from the public API. A symbol is used instead to avoid\n   * polluting the public API with the marker.\n   */\n  readonly [NgFieldDirective]!: true;\n\n  /**\n   * Internal control directive creation lifecycle hook.\n   *\n   * The presence of this method tells the compiler to install `ControlFeature`, which will\n   * cause this directive to be recognized as a control directive by the `controlCreate` and\n   * `control` instructions.\n   *\n   * @internal */\n  ngControlCreate(host: ControlDirectiveHost<'formField'>): void {\n    if (host.hasPassThrough) {\n      return;\n    }\n\n    if (this.controlValueAccessor) {\n      this.ngControlUpdate = cvaControlCreate(host, this as FormField<unknown>);\n    } else if (host.customControl) {\n      this.ngControlUpdate = customControlCreate(host, this as FormField<unknown>);\n    } else if (this.elementIsNativeFormElement) {\n      this.ngControlUpdate = nativeControlCreate(\n        host,\n        this as FormField<unknown>,\n        this.parseErrorsSource,\n      );\n    } else {\n      throw new RuntimeError(\n        RuntimeErrorCode.INVALID_FIELD_DIRECTIVE_HOST,\n        typeof ngDevMode !== 'undefined' &&\n          ngDevMode &&\n          `${host.descriptor} is an invalid [formField] directive host. The host must be a native form control ` +\n            `(such as <input>', '<select>', or '<textarea>') or a custom form control with a 'value' or ` +\n            `'checked' model.`,\n      );\n    }\n  }\n\n  /** @internal */\n  ngControlUpdate: (() => void) | undefined;\n\n  /** @internal */\n  elementAcceptsNativeProperty<K extends ControlBindingKey>(\n    key: K,\n  ): key is K &\n    ('min' | 'max' | 'minLength' | 'maxLength' | 'disabled' | 'required' | 'readonly' | 'name') {\n    if (!this.elementIsNativeFormElement) {\n      return false;\n    }\n\n    switch (key) {\n      case 'min':\n      case 'max':\n        return this.elementAcceptsNumericValues;\n      case 'minLength':\n      case 'maxLength':\n        return this.elementAcceptsTextualValues;\n      case 'disabled':\n      case 'required':\n      case 'readonly':\n      case 'name':\n        return true;\n      default:\n        return false;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {Directive, input} from '@angular/core';\n\nimport {submit} from '../api/structure';\nimport {FieldTree} from '../api/types';\n\n/**\n * A directive that binds a `FieldTree` to a `<form>` element.\n *\n * It automatically:\n * 1. Sets `novalidate` on the form element to disable browser validation.\n * 2. Listens for the `submit` event, prevents the default behavior, and calls `submit()` on the\n * `FieldTree`.\n *\n * @usageNotes\n *\n * ```html\n * <form [formRoot]=\"myFieldTree\">\n *   ...\n * </form>\n * ```\n *\n * @publicApi\n * @experimental 21.0.0\n */\n@Directive({\n  selector: 'form[formRoot]',\n  host: {\n    'novalidate': '',\n    '(submit)': 'onSubmit($event)',\n  },\n})\nexport class FormRoot<T> {\n  readonly fieldTree = input.required<FieldTree<T>>({alias: 'formRoot'});\n\n  protected onSubmit(event: Event): void {\n    event.preventDefault();\n    submit(this.fieldTree());\n  }\n}\n"],"names":["SIGNAL_FORMS_CONFIG","InjectionToken","ngDevMode","provideSignalFormsConfig","config","provide","useValue","disabled","path","logic","assertPathIsCurrent","pathNode","FieldPathNode","unwrapFieldPath","builder","addDisabledReasonRule","ctx","result","fieldTree","message","undefined","hidden","addHiddenRule","readonly","addReadonlyRule","getLengthOrSize","value","v","length","size","getOption","opt","Function","isEmpty","isNaN","normalizeErrors","error","Array","isArray","validate","addSyncErrorRule","addDefaultField","requiredError","options","RequiredValidationError","minError","min","MinValidationError","maxError","max","MaxValidationError","minLengthError","minLength","MinLengthValidationError","maxLengthError","maxLength","MaxLengthValidationError","patternError","pattern","PatternValidationError","emailError","EmailValidationError","BaseNgValidationError","__brand","kind","constructor","Object","assign","NativeInputParseError","NgValidationError","EMAIL_REGEXP","email","test","maxValue","MAX_MEMO","metadata","createMetadataKey","MAX","state","Number","numValue","NaN","MAX_LENGTH_MEMO","MAX_LENGTH","minValue","MIN_MEMO","MIN","MIN_LENGTH_MEMO","MIN_LENGTH","PATTERN_MEMO","RegExp","PATTERN","required","REQUIRED_MEMO","when","REQUIRED","validateAsync","opts","RESOURCE","createManagedMetadataKey","factory","node","stateOf","validationState","shouldSkipValidation","syncValid","params","addAsyncErrorRule","res","errors","status","hasValue","onSuccess","onError","validateTree","addSyncTreeErrorRule","validateStandardSchema","schema","VALIDATOR_MEMO","resolvedSchema","fieldTreeOf","isPromise","issues","map","issue","standardIssueToFormTreeError","resource","loader","standardSchemaError","StandardSchemaValidationError","target","pathPart","pathKey","key","validateHttp","request","httpResource","debounce","durationOrDebouncer","debouncer","debounceForDuration","immediate","addMetadataRule","DEBOUNCER","durationInMilliseconds","_context","abortSignal","Promise","resolve","timeoutId","onAbort","clearTimeout","setTimeout","removeEventListener","addEventListener","once","FORM_FIELD_PARSE_ERRORS","createParser","getValue","setValue","parse","linkedSignal","debugName","source","computation","setRawValue","rawValue","set","asReadonly","transformedValue","format","parser","formFieldParseErrors","inject","self","optional","parseErrors","originalSet","bind","newRawValue","update","updateFn","InteropNgControl","field","control","valid","invalid","pending","enabled","signalErrorsToValidationErrors","pristine","dirty","touched","untouched","RuntimeError","valueAccessor","hasValidator","validator","Validators","updateValueAndValidity","FIELD_STATE_KEY_TO_CONTROL_BINDING","disabledReasons","name","CONTROL_BINDING_TO_FIELD_STATE_KEY","keys","readFieldStateBindingValue","fieldState","property","CONTROL_BINDING_NAMES","values","createBindings","bindingUpdated","bindings","isNativeFormElement","element","tagName","isNumericFormElement","type","isTextualFormElement","getNativeControlValue","currentValue","modelValue","validity","badInput","checked","untracked","valueAsNumber","Date","valueAsDate","setNativeControlValue","setNativeNumberControlValue","setNativeDomProperty","renderer","setAttribute","removeAttribute","toString","customControlCreate","host","parent","listenToCustomControlModel","controlValue","listenToCustomControlOutput","markAsTouched","registerAsBinding","customControl","setCustomControlModelInput","setInputOnDirectives","elementAcceptsNativeProperty","customControlHasInput","nativeFormElement","cvaControlCreate","controlValueAccessor","registerOnChange","registerOnTouched","writeValue","propertyWasSet","setDisabledState","observeSelectMutations","select","onMutation","destroyRef","MutationObserver","observer","mutations","some","m","isRelevantSelectMutation","observe","attributes","attributeFilter","characterData","childList","subtree","onDestroy","disconnect","mutation","Comment","addedNodes","removedNodes","HTMLOptionElement","nativeControlCreate","parseErrorsSource","updateMode","input","listenToDom","NgFieldDirective","Symbol","FORM_FIELD","FormField","alias","Renderer2","DestroyRef","computed","injector","Injector","ElementRef","nativeElement","elementIsNativeFormElement","elementAcceptsNumericValues","elementAcceptsTextualValues","focuser","focus","controlValueAccessors","NG_VALUE_ACCESSOR","signal","_interopNgControl","interopNgControl","err","formField","filter","isFieldBinding","installClassBindingEffect","classes","entries","className","afterRenderEffect","write","active","addClass","removeClass","bindingOptions","focusOptions","effect","onCleanup","fieldNode","nodeState","formFieldBindings","controls","c","structure","pathKeys","join","console","warn","formatRuntimeError","ngControlCreate","hasPassThrough","ngControlUpdate","descriptor","deps","i0","FactoryTarget","Directive","dir","ngDeclareDirective","minVersion","version","isStandalone","selector","inputs","classPropertyName","publicName","isSignal","isRequired","transformFunction","providers","useExisting","NgControl","useFactory","exportAs","controlCreate","passThroughInput","ngImport","decorators","args","FormRoot","onSubmit","event","preventDefault","submit","listeners"],"mappings":"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"}
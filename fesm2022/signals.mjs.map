{"version":3,"file":"signals.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/util/type_guards.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/util.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/validation.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/schema/logic.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/resolution.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/schema/logic_node.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/schema/path_node.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/schema/schema.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/metadata.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/logic.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/async.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/controls/interop_ng_control.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/field_directive.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/context.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/metadata.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/proxy.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/util/deep_signal.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/structure.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/submit.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/node.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/state.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/field_adapter.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/structure.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validation_errors.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/util.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/email.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/max.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/max_length.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/min.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/min_length.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/pattern.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/required.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/standard_schema.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * A version of `Array.isArray` that handles narrowing of readonly arrays properly.\n */\nexport function isArray(value: unknown): value is any[] | readonly any[] {\n  return Array.isArray(value);\n}\n\n/**\n * Checks if a value is an object.\n */\nexport function isObject(value: unknown): value is Record<PropertyKey, unknown> {\n  return (typeof value === 'object' || typeof value === 'function') && value != null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {FieldNode} from './node';\nimport type {FieldNodeOptions} from './structure';\n\n/**\n * Perform a reduction over a field's children (if any) and return the result.\n *\n * Optionally, the reduction is short circuited based on the provided `shortCircuit` function.\n */\nexport function reduceChildren<T>(\n  node: FieldNode,\n  initialValue: T,\n  fn: (child: FieldNode, value: T) => T,\n  shortCircuit?: (value: T) => boolean,\n): T {\n  const childrenMap = node.structure.childrenMap();\n  if (!childrenMap) {\n    return initialValue;\n  }\n  let value = initialValue;\n  for (const child of childrenMap.values()) {\n    if (shortCircuit?.(value)) {\n      break;\n    }\n    value = fn(child, value);\n  }\n  return value;\n}\n\n/** A shortCircuit function for reduceChildren that short-circuits if the value is false. */\nexport function shortCircuitFalse(value: boolean): boolean {\n  return !value;\n}\n\n/** A shortCircuit function for reduceChildren that short-circuits if the value is true. */\nexport function shortCircuitTrue(value: boolean): boolean {\n  return value;\n}\n\n/** Recasts the given value as a new type. */\nexport function cast<T>(value: unknown): asserts value is T {}\n\n/**\n * A helper method allowing to get injector regardless of the options type.\n * @param options\n */\nexport function getInjectorFromOptions(options: FieldNodeOptions) {\n  if (options.kind === 'root') {\n    return options.fieldManager.injector;\n  }\n\n  return options.parent.structure.root.structure.injector;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, Signal, ÉµWritable} from '@angular/core';\nimport type {FieldTree, TreeValidationResult, ValidationResult} from '../api/types';\nimport type {ValidationError, WithOptionalField} from '../api/validation_errors';\nimport {isArray} from '../util/type_guards';\nimport type {FieldNode} from './node';\nimport {reduceChildren, shortCircuitFalse} from './util';\n\n/**\n * Helper function taking validation state, and returning own state of the node.\n * @param state\n */\nexport function calculateValidationSelfStatus(\n  state: ValidationState,\n): 'invalid' | 'unknown' | 'valid' {\n  if (state.errors().length > 0) {\n    return 'invalid';\n  }\n  if (state.pending()) {\n    return 'unknown';\n  }\n\n  return 'valid';\n}\n\nexport interface ValidationState {\n  /**\n   * The full set of synchronous tree errors visible to this field. This includes ones that are\n   * targeted at a descendant field rather than at this field.\n   */\n  rawSyncTreeErrors: Signal<ValidationError[]>;\n\n  /**\n   * The full set of synchronous errors for this field, including synchronous tree errors and server\n   * errors. Server errors are considered \"synchronous\" because they are imperatively added. From\n   * the perspective of the field state they are either there or not, they are never in a pending\n   * state.\n   */\n  syncErrors: Signal<ValidationError[]>;\n\n  /**\n   * Whether the field is considered valid according solely to its synchronous validators.\n   * Errors resulting from a previous submit attempt are also considered for this state.\n   */\n  syncValid: Signal<boolean>;\n\n  /**\n   * The full set of asynchronous tree errors visible to this field. This includes ones that are\n   * targeted at a descendant field rather than at this field, as well as sentinel 'pending' values\n   * indicating that the validator is still running and an error could still occur.\n   */\n  rawAsyncErrors: Signal<(ValidationError | 'pending')[]>;\n\n  /**\n   * The asynchronous tree errors visible to this field that are specifically targeted at this field\n   * rather than a descendant. This also includes all 'pending' sentinel values, since those could\n   * theoretically result in errors for this field.\n   */\n  asyncErrors: Signal<(ValidationError | 'pending')[]>;\n\n  /**\n   * The combined set of all errors that currently apply to this field.\n   */\n  errors: Signal<ValidationError[]>;\n\n  /**\n   * The combined set of all errors that currently apply to this field and its descendants.\n   */\n  errorSummary: Signal<ValidationError[]>;\n\n  /**\n   * Whether this field has any asynchronous validators still pending.\n   */\n  pending: Signal<boolean>;\n\n  /**\n   * The validation status of the field.\n   * - The status is 'valid' if neither the field nor any of its children has any errors or pending\n   *   validators.\n   * - The status is 'invalid' if the field or any of its children has an error\n   *   (regardless of pending validators)\n   * - The status is 'unknown' if neither the field nor any of its children has any errors,\n   *   but the field or any of its children does have a pending validator.\n   *\n   * A field is considered valid if *all* of the following are true:\n   *  - It has no errors or pending validators\n   *  - All of its children are considered valid\n   * A field is considered invalid if *any* of the following are true:\n   *  - It has an error\n   *  - Any of its children is considered invalid\n   * A field is considered to have unknown validity status if it is not valid or invalid.\n   */\n  status: Signal<'valid' | 'invalid' | 'unknown'>;\n  /**\n   * Whether the field is considered valid.\n   *\n   * A field is considered valid if *all* of the following are true:\n   *  - It has no errors or pending validators\n   *  - All of its children are considered valid\n   *\n   * Note: `!valid()` is *not* the same as `invalid()`. Both `valid()` and `invalid()` can be false\n   * if there are currently no errors, but validators are still pending.\n   */\n  valid: Signal<boolean>;\n\n  /**\n   * Whether the field is considered invalid.\n   *\n   * A field is considered invalid if *any* of the following are true:\n   *  - It has an error\n   *  - Any of its children is considered invalid\n   *\n   * Note: `!invalid()` is *not* the same as `valid()`. Both `valid()` and `invalid()` can be false\n   * if there are currently no errors, but validators are still pending.\n   */\n  invalid: Signal<boolean>;\n\n  /**\n   * Indicates whether validation should be skipped for this field because it is hidden, disabled,\n   * or readonly.\n   */\n  shouldSkipValidation: Signal<boolean>;\n}\n\n/**\n * The validation state associated with a `FieldNode`.\n *\n * This class collects together various types of errors to represent the full validation state of\n * the field. There are 4 types of errors that need to be combined to determine validity:\n * 1. The synchronous errors produced by the schema logic.\n * 2. The synchronous tree errors produced by the schema logic. Tree errors may apply to a different\n *    field than the one that the logic that produced them is bound to. They support targeting the\n *    error at an arbitrary descendant field.\n * 3. The asynchronous tree errors produced by the schema logic. These work like synchronous tree\n *    errors, except the error list may also contain a special sentinel value indicating that a\n *    validator is still running.\n * 4. Server errors are not produced by the schema logic, but instead get imperatively added when a\n *    form submit fails with errors.\n */\nexport class FieldValidationState implements ValidationState {\n  constructor(readonly node: FieldNode) {}\n\n  /**\n   * The full set of synchronous tree errors visible to this field. This includes ones that are\n   * targeted at a descendant field rather than at this field.\n   */\n  readonly rawSyncTreeErrors: Signal<ValidationError[]> = computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n\n    return [\n      ...this.node.logicNode.logic.syncTreeErrors.compute(this.node.context),\n      ...(this.node.structure.parent?.validationState.rawSyncTreeErrors() ?? []),\n    ];\n  });\n\n  /**\n   * The full set of synchronous errors for this field, including synchronous tree errors and server\n   * errors. Server errors are considered \"synchronous\" because they are imperatively added. From\n   * the perspective of the field state they are either there or not, they are never in a pending\n   * state.\n   */\n  readonly syncErrors: Signal<ValidationError[]> = computed(() => {\n    // Short-circuit running validators if validation doesn't apply to this field.\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n\n    return [\n      ...this.node.logicNode.logic.syncErrors.compute(this.node.context),\n      ...this.syncTreeErrors(),\n      ...normalizeErrors(this.node.submitState.serverErrors()),\n    ];\n  });\n\n  /**\n   * Whether the field is considered valid according solely to its synchronous validators.\n   * Errors resulting from a previous submit attempt are also considered for this state.\n   */\n  readonly syncValid: Signal<boolean> = computed(() => {\n    // Short-circuit checking children if validation doesn't apply to this field.\n    if (this.shouldSkipValidation()) {\n      return true;\n    }\n\n    return reduceChildren(\n      this.node,\n      this.syncErrors().length === 0,\n      (child, value) => value && child.validationState.syncValid(),\n      shortCircuitFalse,\n    );\n  });\n\n  /**\n   * The synchronous tree errors visible to this field that are specifically targeted at this field\n   * rather than a descendant.\n   */\n  readonly syncTreeErrors: Signal<ValidationError[]> = computed(() =>\n    this.rawSyncTreeErrors().filter((err) => err.field === this.node.fieldProxy),\n  );\n\n  /**\n   * The full set of asynchronous tree errors visible to this field. This includes ones that are\n   * targeted at a descendant field rather than at this field, as well as sentinel 'pending' values\n   * indicating that the validator is still running and an error could still occur.\n   */\n  readonly rawAsyncErrors: Signal<(ValidationError | 'pending')[]> = computed(() => {\n    // Short-circuit running validators if validation doesn't apply to this field.\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n\n    return [\n      // TODO: add field in `validateAsync` and remove this map\n      ...this.node.logicNode.logic.asyncErrors.compute(this.node.context),\n      // TODO: does it make sense to filter this to errors in this subtree?\n      ...(this.node.structure.parent?.validationState.rawAsyncErrors() ?? []),\n    ];\n  });\n\n  /**\n   * The asynchronous tree errors visible to this field that are specifically targeted at this field\n   * rather than a descendant. This also includes all 'pending' sentinel values, since those could\n   * theoretically result in errors for this field.\n   */\n  readonly asyncErrors: Signal<(ValidationError | 'pending')[]> = computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n    return this.rawAsyncErrors().filter(\n      (err) => err === 'pending' || err.field === this.node.fieldProxy,\n    );\n  });\n\n  /**\n   * The combined set of all errors that currently apply to this field.\n   */\n  readonly errors = computed(() => [\n    ...this.syncErrors(),\n    ...this.asyncErrors().filter((err) => err !== 'pending'),\n  ]);\n\n  readonly errorSummary = computed(() =>\n    reduceChildren(this.node, this.errors(), (child, result) => [\n      ...result,\n      ...child.errorSummary(),\n    ]),\n  );\n\n  /**\n   * Whether this field has any asynchronous validators still pending.\n   */\n  readonly pending = computed(() =>\n    reduceChildren(\n      this.node,\n      this.asyncErrors().includes('pending'),\n      (child, value) => value || child.validationState.asyncErrors().includes('pending'),\n    ),\n  );\n\n  /**\n   * The validation status of the field.\n   * - The status is 'valid' if neither the field nor any of its children has any errors or pending\n   *   validators.\n   * - The status is 'invalid' if the field or any of its children has an error\n   *   (regardless of pending validators)\n   * - The status is 'unknown' if neither the field nor any of its children has any errors,\n   *   but the field or any of its children does have a pending validator.\n   *\n   * A field is considered valid if *all* of the following are true:\n   *  - It has no errors or pending validators\n   *  - All of its children are considered valid\n   * A field is considered invalid if *any* of the following are true:\n   *  - It has an error\n   *  - Any of its children is considered invalid\n   * A field is considered to have unknown validity status if it is not valid or invalid.\n   */\n  readonly status: Signal<'valid' | 'invalid' | 'unknown'> = computed(() => {\n    // Short-circuit checking children if validation doesn't apply to this field.\n    if (this.shouldSkipValidation()) {\n      return 'valid';\n    }\n    let ownStatus = calculateValidationSelfStatus(this);\n\n    return reduceChildren<'valid' | 'invalid' | 'unknown'>(\n      this.node,\n      ownStatus,\n      (child, value) => {\n        if (value === 'invalid' || child.validationState.status() === 'invalid') {\n          return 'invalid';\n        } else if (value === 'unknown' || child.validationState.status() === 'unknown') {\n          return 'unknown';\n        }\n        return 'valid';\n      },\n      (v) => v === 'invalid', // short-circuit on 'invalid'\n    );\n  });\n\n  /**\n   * Whether the field is considered valid.\n   *\n   * A field is considered valid if *all* of the following are true:\n   *  - It has no errors or pending validators\n   *  - All of its children are considered valid\n   *\n   * Note: `!valid()` is *not* the same as `invalid()`. Both `valid()` and `invalid()` can be false\n   * if there are currently no errors, but validators are still pending.\n   */\n  readonly valid = computed(() => this.status() === 'valid');\n\n  /**\n   * Whether the field is considered invalid.\n   *\n   * A field is considered invalid if *any* of the following are true:\n   *  - It has an error\n   *  - Any of its children is considered invalid\n   *\n   * Note: `!invalid()` is *not* the same as `valid()`. Both `valid()` and `invalid()` can be false\n   * if there are currently no errors, but validators are still pending.\n   */\n  readonly invalid = computed(() => this.status() === 'invalid');\n\n  /**\n   * Indicates whether validation should be skipped for this field because it is hidden, disabled,\n   * or readonly.\n   */\n  readonly shouldSkipValidation = computed(\n    () => this.node.hidden() || this.node.disabled() || this.node.readonly(),\n  );\n}\n\n/** Normalizes a validation result to a list of validation errors. */\nfunction normalizeErrors(error: ValidationResult): readonly ValidationError[] {\n  if (error === undefined) {\n    return [];\n  }\n\n  if (isArray(error)) {\n    return error;\n  }\n\n  return [error as ValidationError];\n}\n\n/**\n * Sets the given field on the given error(s) if it does not already have a field.\n * @param errors The error(s) to add the field to\n * @param field The default field to add\n * @returns The passed in error(s), with its field set.\n */\nexport function addDefaultField<E extends ValidationError>(\n  error: WithOptionalField<E>,\n  field: FieldTree<unknown>,\n): E;\nexport function addDefaultField<E extends ValidationError>(\n  errors: TreeValidationResult<E>,\n  field: FieldTree<unknown>,\n): ValidationResult<E>;\nexport function addDefaultField<E extends ValidationError>(\n  errors: TreeValidationResult<E>,\n  field: FieldTree<unknown>,\n): ValidationResult<E> {\n  if (isArray(errors)) {\n    for (const error of errors) {\n      (error as ÉµWritable<ValidationError>).field ??= field;\n    }\n  } else if (errors) {\n    (errors as ÉµWritable<ValidationError>).field ??= field;\n  }\n  return errors as ValidationResult<E>;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {untracked} from '@angular/core';\nimport {AggregateMetadataKey, MetadataKey} from '../api/metadata';\nimport {DisabledReason, type FieldContext, type FieldPath, type LogicFn} from '../api/types';\nimport type {ValidationError} from '../api/validation_errors';\nimport type {FieldNode} from '../field/node';\nimport {isArray} from '../util/type_guards';\n\n/**\n * Special key which is used to represent a dynamic logic property in a `FieldPathNode` path.\n * This property is used to represent logic that applies to every element of some dynamic form data\n * (i.e. an array).\n *\n * For example, a rule like `applyEach(p.myArray, () => { ... })` will add logic to the `DYNAMIC`\n * property of `p.myArray`.\n */\nexport const DYNAMIC: unique symbol = Symbol();\n\n/** Represents a result that should be ignored because its predicate indicates it is not active. */\nconst IGNORED = Symbol();\n\n/**\n * A predicate that indicates whether an `AbstractLogic` instance is currently active, or should be\n * ignored.\n */\nexport interface Predicate {\n  /** A boolean logic function that returns true if the logic is considered active. */\n  readonly fn: LogicFn<any, boolean>;\n  /**\n   * The path which this predicate was created for. This is used to determine the correct\n   * `FieldContext` to pass to the predicate function.\n   */\n  readonly path: FieldPath<any>;\n}\n\n/**\n * Represents a predicate that is bound to a particular depth in the field tree. This is needed for\n * recursively applied logic to ensure that the predicate is evaluated against the correct\n * application of that logic.\n *\n * Consider the following example:\n *\n * ```\n * const s = schema(p => {\n *   disabled(p.data);\n *   applyWhen(p.next, ({valueOf}) => valueOf(p.data) === 1, s);\n * });\n *\n * const f = form(signal({data: 0, next: {data: 1, next: {data: 2, next: undefined}}}), s);\n *\n * const isDisabled = f.next.next.data().disabled();\n * ```\n *\n * In order to determine `isDisabled` we need to evaluate the predicate from `applyWhen` *twice*.\n * Once to see if the schema should be applied to `f.next` and again to see if it should be applied\n * to `f.next.next`. The `depth` tells us which field we should be evaluating against each time.\n */\nexport interface BoundPredicate extends Predicate {\n  /** The depth in the field tree at which this predicate is bound. */\n  readonly depth: number;\n}\n\n/**\n * Base class for all logic. It is responsible for combining the results from multiple individual\n * logic functions registered in the schema, and using them to derive the value for some associated\n * piece of field state.\n */\nexport abstract class AbstractLogic<TReturn, TValue = TReturn> {\n  /** The set of logic functions that contribute to the value of the associated state. */\n  protected readonly fns: Array<LogicFn<any, TValue | typeof IGNORED>> = [];\n\n  constructor(\n    /**\n     * A list of predicates that conditionally enable all logic in this logic instance.\n     * The logic is only enabled when *all* of the predicates evaluate to true.\n     */\n    private predicates: ReadonlyArray<BoundPredicate>,\n  ) {}\n\n  /**\n   * Computes the value of the associated field state based on the logic functions and predicates\n   * registered with this logic instance.\n   */\n  abstract compute(arg: FieldContext<any>): TReturn;\n\n  /**\n   * The default value that the associated field state should assume if there are no logic functions\n   * registered by the schema (or if the logic is disabled by a predicate).\n   */\n  abstract get defaultValue(): TReturn;\n\n  /** Registers a logic function with this logic instance. */\n  push(logicFn: LogicFn<any, TValue>) {\n    this.fns.push(wrapWithPredicates(this.predicates, logicFn));\n  }\n\n  /**\n   * Merges in the logic from another logic instance, subject to the predicates of both the other\n   * instance and this instance.\n   */\n  mergeIn(other: AbstractLogic<TReturn, TValue>) {\n    const fns = this.predicates\n      ? other.fns.map((fn) => wrapWithPredicates(this.predicates, fn))\n      : other.fns;\n    this.fns.push(...fns);\n  }\n}\n\n/** Logic that combines its individual logic function results with logical OR. */\nexport class BooleanOrLogic extends AbstractLogic<boolean> {\n  override get defaultValue() {\n    return false;\n  }\n\n  override compute(arg: FieldContext<any>): boolean {\n    return this.fns.some((f) => {\n      const result = f(arg);\n      return result && result !== IGNORED;\n    });\n  }\n}\n\n/**\n * Logic that combines its individual logic function results by aggregating them in an array.\n * Depending on its `ignore` function it may ignore certain values, omitting them from the array.\n */\nexport class ArrayMergeIgnoreLogic<TElement, TIgnore = never> extends AbstractLogic<\n  readonly TElement[],\n  TElement | readonly (TElement | TIgnore)[] | TIgnore | undefined | void\n> {\n  /** Creates an instance of this class that ignores `null` values. */\n  static ignoreNull<TElement>(predicates: ReadonlyArray<BoundPredicate>) {\n    return new ArrayMergeIgnoreLogic<TElement, null>(predicates, (e: unknown) => e === null);\n  }\n\n  constructor(\n    predicates: ReadonlyArray<BoundPredicate>,\n    private ignore: undefined | ((e: TElement | undefined | TIgnore) => e is TIgnore),\n  ) {\n    super(predicates);\n  }\n\n  override get defaultValue() {\n    return [];\n  }\n\n  override compute(arg: FieldContext<any>): readonly TElement[] {\n    return this.fns.reduce((prev, f) => {\n      const value = f(arg);\n\n      if (value === undefined || value === IGNORED) {\n        return prev;\n      } else if (isArray(value)) {\n        return [...prev, ...(this.ignore ? value.filter((e) => !this.ignore!(e)) : value)];\n      } else {\n        if (this.ignore && this.ignore(value as TElement | TIgnore | undefined)) {\n          return prev;\n        }\n        return [...prev, value];\n      }\n    }, [] as TElement[]);\n  }\n}\n\n/** Logic that combines its individual logic function results by aggregating them in an array. */\nexport class ArrayMergeLogic<TElement> extends ArrayMergeIgnoreLogic<TElement, never> {\n  constructor(predicates: ReadonlyArray<BoundPredicate>) {\n    super(predicates, undefined);\n  }\n}\n\n/** Logic that combines aggregate metadata according to the keys's own reduce function. */\nexport class AggregateMetadataMergeLogic<TAcc, TItem> extends AbstractLogic<TAcc, TItem> {\n  override get defaultValue() {\n    return this.key.getInitial();\n  }\n\n  constructor(\n    predicates: ReadonlyArray<BoundPredicate>,\n    private key: AggregateMetadataKey<TAcc, TItem>,\n  ) {\n    super(predicates);\n  }\n\n  override compute(ctx: FieldContext<any>): TAcc {\n    if (this.fns.length === 0) {\n      return this.key.getInitial();\n    }\n    let acc: TAcc = this.key.getInitial();\n    for (let i = 0; i < this.fns.length; i++) {\n      const item = this.fns[i](ctx);\n      if (item !== IGNORED) {\n        acc = this.key.reduce(acc, item);\n      }\n    }\n    return acc;\n  }\n}\n\n/**\n * Wraps a logic function such that it returns the special `IGNORED` sentinel value if any of the\n * given predicates evaluates to false.\n *\n * @param predicates A list of bound predicates to apply to the logic function\n * @param logicFn The logic function to wrap\n * @returns A wrapped version of the logic function that may return `IGNORED`.\n */\nfunction wrapWithPredicates<TValue, TReturn>(\n  predicates: ReadonlyArray<BoundPredicate>,\n  logicFn: LogicFn<TValue, TReturn>,\n): LogicFn<TValue, TReturn | typeof IGNORED> {\n  if (predicates.length === 0) {\n    return logicFn;\n  }\n  return (arg: FieldContext<any>): TReturn | typeof IGNORED => {\n    for (const predicate of predicates) {\n      let predicateField = arg.stateOf(predicate.path) as FieldNode;\n      // Check the depth of the current field vs the depth this predicate is supposed to be\n      // evaluated at. If necessary, walk up the field tree to grab the correct context field.\n      // We can check the pathKeys as an untracked read since we know the structure of our fields\n      // doesn't change.\n      const depthDiff = untracked(predicateField.structure.pathKeys).length - predicate.depth;\n      for (let i = 0; i < depthDiff; i++) {\n        predicateField = predicateField.structure.parent!;\n      }\n      // If any of the predicates don't match, don't actually run the logic function, just return\n      // the default value.\n      if (!predicate.fn(predicateField.context)) {\n        return IGNORED;\n      }\n    }\n    return logicFn(arg);\n  };\n}\n\n/**\n * Container for all the different types of logic that can be applied to a field\n * (disabled, hidden, errors, etc.)\n */\n\nexport class LogicContainer {\n  /** Logic that determines if the field is hidden. */\n  readonly hidden: BooleanOrLogic;\n  /** Logic that determines reasons for the field being disabled. */\n  readonly disabledReasons: ArrayMergeLogic<DisabledReason>;\n  /** Logic that determines if the field is read-only. */\n  readonly readonly: BooleanOrLogic;\n  /** Logic that produces synchronous validation errors for the field. */\n  readonly syncErrors: ArrayMergeIgnoreLogic<ValidationError, null>;\n  /** Logic that produces synchronous validation errors for the field's subtree. */\n  readonly syncTreeErrors: ArrayMergeIgnoreLogic<ValidationError, null>;\n  /** Logic that produces asynchronous validation results (errors or 'pending'). */\n  readonly asyncErrors: ArrayMergeIgnoreLogic<ValidationError | 'pending', null>;\n  /** A map of aggregate metadata keys to the `AbstractLogic` instances that compute their values. */\n  private readonly aggregateMetadataKeys = new Map<\n    AggregateMetadataKey<unknown, unknown>,\n    AbstractLogic<unknown>\n  >();\n  /** A map of metadata keys to the factory functions that create their values. */\n  private readonly metadataFactories = new Map<\n    MetadataKey<unknown>,\n    (ctx: FieldContext<unknown>) => unknown\n  >();\n\n  /**\n   * Constructs a new `Logic` container.\n   * @param predicates An array of predicates that must all be true for the logic\n   *   functions within this container to be active.\n   */\n  constructor(private predicates: ReadonlyArray<BoundPredicate>) {\n    this.hidden = new BooleanOrLogic(predicates);\n    this.disabledReasons = new ArrayMergeLogic(predicates);\n    this.readonly = new BooleanOrLogic(predicates);\n    this.syncErrors = ArrayMergeIgnoreLogic.ignoreNull<ValidationError>(predicates);\n    this.syncTreeErrors = ArrayMergeIgnoreLogic.ignoreNull<ValidationError>(predicates);\n    this.asyncErrors = ArrayMergeIgnoreLogic.ignoreNull<ValidationError | 'pending'>(predicates);\n  }\n\n  /** Checks whether there is logic for the given aggregate metadata key. */\n  hasAggregateMetadata(key: AggregateMetadataKey<any, any>) {\n    return this.aggregateMetadataKeys.has(key);\n  }\n\n  /**\n   * Gets an iterable of [aggregate metadata, logic function] pairs.\n   * @returns An iterable of aggregate metadata entries.\n   */\n  getAggregateMetadataEntries() {\n    return this.aggregateMetadataKeys.entries();\n  }\n\n  /**\n   * Gets an iterable of [metadata, value factory function] pairs.\n   * @returns An iterable of metadata factory entries.\n   */\n  getMetadataFactoryEntries() {\n    return this.metadataFactories.entries();\n  }\n\n  /**\n   * Retrieves or creates the `AbstractLogic` for a given aggregate metadata key.\n   * @param key The `AggregateMetadataKey` for which to get the logic.\n   * @returns The `AbstractLogic` associated with the key.\n   */\n  getAggregateMetadata<T>(key: AggregateMetadataKey<unknown, T>): AbstractLogic<T> {\n    if (!this.aggregateMetadataKeys.has(key as AggregateMetadataKey<unknown, unknown>)) {\n      this.aggregateMetadataKeys.set(\n        key as AggregateMetadataKey<unknown, unknown>,\n        new AggregateMetadataMergeLogic(this.predicates, key),\n      );\n    }\n    return this.aggregateMetadataKeys.get(\n      key as AggregateMetadataKey<unknown, unknown>,\n    )! as AbstractLogic<T>;\n  }\n\n  /**\n   * Adds a factory function for a given metadata key.\n   * @param key The `MetadataKey` to associate the factory with.\n   * @param factory The factory function.\n   * @throws If a factory is already defined for the given key.\n   */\n  addMetadataFactory(key: MetadataKey<unknown>, factory: (ctx: FieldContext<unknown>) => unknown) {\n    if (this.metadataFactories.has(key)) {\n      // TODO: name of the metadata key?\n      throw new Error(`Can't define value twice for the same MetadataKey`);\n    }\n    this.metadataFactories.set(key, factory);\n  }\n\n  /**\n   * Merges logic from another `Logic` instance into this one.\n   * @param other The `Logic` instance to merge from.\n   */\n  mergeIn(other: LogicContainer) {\n    this.hidden.mergeIn(other.hidden);\n    this.disabledReasons.mergeIn(other.disabledReasons);\n    this.readonly.mergeIn(other.readonly);\n    this.syncErrors.mergeIn(other.syncErrors);\n    this.syncTreeErrors.mergeIn(other.syncTreeErrors);\n    this.asyncErrors.mergeIn(other.asyncErrors);\n    for (const [key, metadataLogic] of other.getAggregateMetadataEntries()) {\n      this.getAggregateMetadata(key).mergeIn(metadataLogic);\n    }\n    for (const [key, metadataFactory] of other.getMetadataFactoryEntries()) {\n      this.addMetadataFactory(key, metadataFactory);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nlet boundPathDepth = 0;\n\n/**\n * The depth of the current path when evaluating a logic function.\n * Do not set this directly, it is a context variable managed by `setBoundPathDepthForResolution`.\n */\nexport function getBoundPathDepth() {\n  return boundPathDepth;\n}\n\n/**\n * Sets the bound path depth for the duration of the given logic function.\n * This is used to ensure that the field resolution algorithm walks far enough up the field tree to\n * reach the point where the root of the path we're bound to is applied. This normally isn't a big\n * concern, but matters when we're dealing with recursive structures.\n *\n * Consider this example:\n *\n * ```\n * const s = schema(p => {\n *   disabled(p.next, ({valueOf}) => valueOf(p.data));\n *   apply(p.next, s);\n * });\n * ```\n *\n * Here we need to know that the `disabled` logic was bound to a path of depth 1. Otherwise we'd\n * attempt to resolve `p.data` in the context of the field corresponding to `p.next`.\n * The resolution algorithm would start with the field for `p.next` and see that it *does* contain\n * the logic for `s` (due to the fact that its recursively applied.) It would then decide not to\n * walk up the field tree at all, and to immediately start walking down the keys for the target path\n * `p.data`, leading it to grab the field corresponding to `p.next.data`.\n *\n * We avoid the problem described above by keeping track of the depth (relative to Schema root) of\n * the path we were bound to. We then require the resolution algorithm to walk at least that far up\n * the tree before finding a node that contains the logic for `s`.\n *\n * @param fn A logic function that is bound to a particular path\n * @param depth The depth in the field tree of the field the logic is bound to\n * @returns A version of the logic function that is aware of its depth.\n */\nexport function setBoundPathDepthForResolution<A extends any[], R>(\n  fn: (...args: A) => R,\n  depth: number,\n): (...args: A) => R {\n  return (...args: A) => {\n    try {\n      boundPathDepth = depth;\n      return fn(...args);\n    } finally {\n      boundPathDepth = 0;\n    }\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {AggregateMetadataKey, MetadataKey} from '../api/metadata';\nimport type {\n  AsyncValidationResult,\n  DisabledReason,\n  FieldContext,\n  LogicFn,\n  ValidationResult,\n} from '../api/types';\nimport {setBoundPathDepthForResolution} from '../field/resolution';\nimport {BoundPredicate, LogicContainer, Predicate} from './logic';\n\n/**\n * Abstract base class for building a `LogicNode`.\n * This class defines the interface for adding various logic rules (e.g., hidden, disabled)\n * and data factories to a node in the logic tree.\n * LogicNodeBuilders are 1:1 with nodes in the Schema tree.\n */\nexport abstract class AbstractLogicNodeBuilder {\n  constructor(\n    /** The depth of this node in the schema tree. */\n    protected readonly depth: number,\n  ) {}\n\n  /** Adds a rule to determine if a field should be hidden. */\n  abstract addHiddenRule(logic: LogicFn<any, boolean>): void;\n  /** Adds a rule to determine if a field should be disabled, and for what reason. */\n  abstract addDisabledReasonRule(logic: LogicFn<any, DisabledReason | undefined>): void;\n  /** Adds a rule to determine if a field should be read-only. */\n  abstract addReadonlyRule(logic: LogicFn<any, boolean>): void;\n  /** Adds a rule for synchronous validation errors for a field. */\n  abstract addSyncErrorRule(logic: LogicFn<any, ValidationResult>): void;\n  /** Adds a rule for synchronous validation errors that apply to a subtree. */\n  abstract addSyncTreeErrorRule(logic: LogicFn<any, ValidationResult>): void;\n  /** Adds a rule for asynchronous validation errors for a field. */\n  abstract addAsyncErrorRule(logic: LogicFn<any, AsyncValidationResult>): void;\n  /** Adds a rule to compute aggregate metadata for a field. */\n  abstract addAggregateMetadataRule<M>(\n    key: AggregateMetadataKey<unknown, M>,\n    logic: LogicFn<any, M>,\n  ): void;\n  /** Adds a factory function to produce a data value associated with a field. */\n  abstract addMetadataFactory<D>(key: MetadataKey<D>, factory: (ctx: FieldContext<any>) => D): void;\n  /**\n   * Gets a builder for a child node associated with the given property key.\n   * @param key The property key of the child.\n   * @returns A `LogicNodeBuilder` for the child.\n   */\n  abstract getChild(key: PropertyKey): LogicNodeBuilder;\n\n  /**\n   * Checks whether a particular `AbstractLogicNodeBuilder` has been merged into this one.\n   * @param builder The builder to check for.\n   * @returns True if the builder has been merged, false otherwise.\n   */\n  abstract hasLogic(builder: AbstractLogicNodeBuilder): boolean;\n\n  /**\n   * Builds the `LogicNode` from the accumulated rules and child builders.\n   * @returns The constructed `LogicNode`.\n   */\n  build(): LogicNode {\n    return new LeafLogicNode(this, [], 0);\n  }\n}\n\n/**\n * A builder for `LogicNode`. Used to add logic to the final `LogicNode` tree.\n * This builder supports merging multiple sources of logic, potentially with predicates,\n * preserving the order of rule application.\n */\nexport class LogicNodeBuilder extends AbstractLogicNodeBuilder {\n  constructor(depth: number) {\n    super(depth);\n  }\n\n  /**\n   * The current `NonMergeableLogicNodeBuilder` being used to add rules directly to this\n   * `LogicNodeBuilder`. Do not use this directly, call `getCurrent()` which will create a current\n   * builder if there is none.\n   */\n  private current: NonMergeableLogicNodeBuilder | undefined;\n  /**\n   * Stores all builders that contribute to this node, along with any predicates\n   * that gate their application.\n   */\n  readonly all: {builder: AbstractLogicNodeBuilder; predicate?: Predicate}[] = [];\n\n  override addHiddenRule(logic: LogicFn<any, boolean>): void {\n    this.getCurrent().addHiddenRule(logic);\n  }\n\n  override addDisabledReasonRule(logic: LogicFn<any, DisabledReason | undefined>): void {\n    this.getCurrent().addDisabledReasonRule(logic);\n  }\n\n  override addReadonlyRule(logic: LogicFn<any, boolean>): void {\n    this.getCurrent().addReadonlyRule(logic);\n  }\n\n  override addSyncErrorRule(logic: LogicFn<any, ValidationResult>): void {\n    this.getCurrent().addSyncErrorRule(logic);\n  }\n\n  override addSyncTreeErrorRule(logic: LogicFn<any, ValidationResult>): void {\n    this.getCurrent().addSyncTreeErrorRule(logic);\n  }\n\n  override addAsyncErrorRule(logic: LogicFn<any, AsyncValidationResult>): void {\n    this.getCurrent().addAsyncErrorRule(logic);\n  }\n\n  override addAggregateMetadataRule<T>(\n    key: AggregateMetadataKey<unknown, T>,\n    logic: LogicFn<any, T>,\n  ): void {\n    this.getCurrent().addAggregateMetadataRule(key, logic);\n  }\n\n  override addMetadataFactory<D>(\n    key: MetadataKey<D>,\n    factory: (ctx: FieldContext<any>) => D,\n  ): void {\n    this.getCurrent().addMetadataFactory(key, factory);\n  }\n\n  override getChild(key: PropertyKey): LogicNodeBuilder {\n    return this.getCurrent().getChild(key);\n  }\n\n  override hasLogic(builder: AbstractLogicNodeBuilder): boolean {\n    if (this === builder) {\n      return true;\n    }\n    return this.all.some(({builder: subBuilder}) => subBuilder.hasLogic(builder));\n  }\n\n  /**\n   * Merges logic from another `LogicNodeBuilder` into this one.\n   * If a `predicate` is provided, all logic from the `other` builder will only apply\n   * when the predicate evaluates to true.\n   * @param other The `LogicNodeBuilder` to merge in.\n   * @param predicate An optional predicate to gate the merged logic.\n   */\n  mergeIn(other: LogicNodeBuilder, predicate?: Predicate): void {\n    // Add the other builder to our collection, we'll defer the actual merging of the logic until\n    // the logic node is requested to be created. In order to preserve the original ordering of the\n    // rules, we close off the current builder to any further edits. If additional logic is added,\n    // a new current builder will be created to capture it.\n    if (predicate) {\n      this.all.push({\n        builder: other,\n        predicate: {\n          fn: setBoundPathDepthForResolution(predicate.fn, this.depth),\n          path: predicate.path,\n        },\n      });\n    } else {\n      this.all.push({builder: other});\n    }\n    this.current = undefined;\n  }\n\n  /**\n   * Gets the current `NonMergeableLogicNodeBuilder` for adding rules directly to this\n   * `LogicNodeBuilder`. If no current builder exists, a new one is created.\n   * The current builder is cleared whenever `mergeIn` is called to preserve the order\n   * of rules when merging separate builder trees.\n   * @returns The current `NonMergeableLogicNodeBuilder`.\n   */\n  private getCurrent(): NonMergeableLogicNodeBuilder {\n    if (this.current === undefined) {\n      this.current = new NonMergeableLogicNodeBuilder(this.depth);\n      this.all.push({builder: this.current});\n    }\n    return this.current;\n  }\n\n  /**\n   * Creates a new root `LogicNodeBuilder`.\n   * @returns A new instance of `LogicNodeBuilder`.\n   */\n  static newRoot(): LogicNodeBuilder {\n    return new LogicNodeBuilder(0);\n  }\n}\n\n/**\n * A type of `AbstractLogicNodeBuilder` used internally by the `LogicNodeBuilder` to record \"pure\"\n * chunks of logic that do not require merging in other builders.\n */\nclass NonMergeableLogicNodeBuilder extends AbstractLogicNodeBuilder {\n  /** The collection of logic rules directly added to this builder. */\n  readonly logic = new LogicContainer([]);\n  /**\n   * A map of child property keys to their corresponding `LogicNodeBuilder` instances.\n   * This allows for building a tree of logic.\n   */\n  readonly children = new Map<PropertyKey, LogicNodeBuilder>();\n\n  constructor(depth: number) {\n    super(depth);\n  }\n\n  override addHiddenRule(logic: LogicFn<any, boolean>): void {\n    this.logic.hidden.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addDisabledReasonRule(logic: LogicFn<any, DisabledReason | undefined>): void {\n    this.logic.disabledReasons.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addReadonlyRule(logic: LogicFn<any, boolean>): void {\n    this.logic.readonly.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addSyncErrorRule(logic: LogicFn<any, ValidationResult>): void {\n    this.logic.syncErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addSyncTreeErrorRule(logic: LogicFn<any, ValidationResult>): void {\n    this.logic.syncTreeErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addAsyncErrorRule(logic: LogicFn<any, AsyncValidationResult>): void {\n    this.logic.asyncErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addAggregateMetadataRule<T>(\n    key: AggregateMetadataKey<unknown, T>,\n    logic: LogicFn<any, T>,\n  ): void {\n    this.logic.getAggregateMetadata(key).push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n\n  override addMetadataFactory<D>(\n    key: MetadataKey<D>,\n    factory: (ctx: FieldContext<any>) => D,\n  ): void {\n    this.logic.addMetadataFactory(key, setBoundPathDepthForResolution(factory, this.depth));\n  }\n\n  override getChild(key: PropertyKey): LogicNodeBuilder {\n    if (!this.children.has(key)) {\n      this.children.set(key, new LogicNodeBuilder(this.depth + 1));\n    }\n    return this.children.get(key)!;\n  }\n\n  override hasLogic(builder: AbstractLogicNodeBuilder): boolean {\n    return this === builder;\n  }\n}\n\n/**\n * Represents a node in the logic tree, containing all logic applicable\n * to a specific field or path in the form structure.\n * LogicNodes are 1:1 with nodes in the Field tree.\n */\nexport interface LogicNode {\n  /** The collection of logic rules (hidden, disabled, errors, etc.) for this node. */\n  readonly logic: LogicContainer;\n\n  /**\n   * Retrieves the `LogicNode` for a child identified by the given property key.\n   * @param key The property key of the child.\n   * @returns The `LogicNode` for the specified child.\n   */\n  getChild(key: PropertyKey): LogicNode;\n\n  /**\n   * Checks whether the logic from a particular `AbstractLogicNodeBuilder` has been merged into this\n   * node.\n   * @param builder The builder to check for.\n   * @returns True if the builder has been merged, false otherwise.\n   */\n  hasLogic(builder: AbstractLogicNodeBuilder): boolean;\n}\n\n/**\n * A tree structure of `Logic` corresponding to a tree of fields.\n * This implementation represents a leaf in the sense that its logic is derived\n * from a single builder.\n */\nclass LeafLogicNode implements LogicNode {\n  /** The computed logic for this node. */\n  readonly logic: LogicContainer;\n\n  /**\n   * Constructs a `LeafLogicNode`.\n   * @param builder The `AbstractLogicNodeBuilder` from which to derive the logic.\n   *   If undefined, an empty `Logic` instance is created.\n   * @param predicates An array of predicates that gate the logic from the builder.\n   */\n  constructor(\n    private builder: AbstractLogicNodeBuilder | undefined,\n    private predicates: BoundPredicate[],\n    /** The depth of this node in the field tree. */\n    private depth: number,\n  ) {\n    this.logic = builder ? createLogic(builder, predicates, depth) : new LogicContainer([]);\n  }\n\n  // TODO: cache here, or just rely on the user of this API to do caching?\n  /**\n   * Retrieves the `LogicNode` for a child identified by the given property key.\n   * @param key The property key of the child.\n   * @returns The `LogicNode` for the specified child.\n   */\n  getChild(key: PropertyKey): LogicNode {\n    // The logic for a particular child may be spread across multiple builders. We lazily combine\n    // this logic at the time the child logic node is requested to be created.\n    const childBuilders = this.builder ? getAllChildBuilders(this.builder, key) : [];\n    if (childBuilders.length === 0) {\n      return new LeafLogicNode(undefined, [], this.depth + 1);\n    } else if (childBuilders.length === 1) {\n      const {builder, predicates} = childBuilders[0];\n      return new LeafLogicNode(\n        builder,\n        [...this.predicates, ...predicates.map((p) => bindLevel(p, this.depth))],\n        this.depth + 1,\n      );\n    } else {\n      const builtNodes = childBuilders.map(\n        ({builder, predicates}) =>\n          new LeafLogicNode(\n            builder,\n            [...this.predicates, ...predicates.map((p) => bindLevel(p, this.depth))],\n            this.depth + 1,\n          ),\n      );\n      return new CompositeLogicNode(builtNodes);\n    }\n  }\n\n  /**\n   * Checks whether the logic from a particular `AbstractLogicNodeBuilder` has been merged into this\n   * node.\n   * @param builder The builder to check for.\n   * @returns True if the builder has been merged, false otherwise.\n   */\n  hasLogic(builder: AbstractLogicNodeBuilder): boolean {\n    return this.builder?.hasLogic(builder) ?? false;\n  }\n}\n\n/**\n * A `LogicNode` that represents the composition of multiple `LogicNode` instances.\n * This is used when logic for a particular path is contributed by several distinct\n * builder branches that need to be merged.\n */\nclass CompositeLogicNode implements LogicNode {\n  /** The merged logic from all composed nodes. */\n  readonly logic: LogicContainer;\n\n  /**\n   * Constructs a `CompositeLogicNode`.\n   * @param all An array of `LogicNode` instances to compose.\n   */\n  constructor(private all: LogicNode[]) {\n    this.logic = new LogicContainer([]);\n    for (const node of all) {\n      this.logic.mergeIn(node.logic);\n    }\n  }\n\n  /**\n   * Retrieves the child `LogicNode` by composing the results of `getChild` from all\n   * underlying `LogicNode` instances.\n   * @param key The property key of the child.\n   * @returns A `CompositeLogicNode` representing the composed child.\n   */\n  getChild(key: PropertyKey): LogicNode {\n    return new CompositeLogicNode(this.all.flatMap((child) => child.getChild(key)));\n  }\n\n  /**\n   * Checks whether the logic from a particular `AbstractLogicNodeBuilder` has been merged into this\n   * node.\n   * @param builder The builder to check for.\n   * @returns True if the builder has been merged, false otherwise.\n   */\n  hasLogic(builder: AbstractLogicNodeBuilder): boolean {\n    return this.all.some((node) => node.hasLogic(builder));\n  }\n}\n\n/**\n * Gets all of the builders that contribute logic to the given child of the parent builder.\n * This function recursively traverses the builder hierarchy.\n * @param builder The parent `AbstractLogicNodeBuilder`.\n * @param key The property key of the child.\n * @returns An array of objects, each containing a `LogicNodeBuilder` for the child and any associated predicates.\n */\nfunction getAllChildBuilders(\n  builder: AbstractLogicNodeBuilder,\n  key: PropertyKey,\n): {builder: LogicNodeBuilder; predicates: Predicate[]}[] {\n  if (builder instanceof LogicNodeBuilder) {\n    return builder.all.flatMap(({builder, predicate}) => {\n      const children = getAllChildBuilders(builder, key);\n      if (predicate) {\n        return children.map(({builder, predicates}) => ({\n          builder,\n          predicates: [...predicates, predicate],\n        }));\n      }\n      return children;\n    });\n  } else if (builder instanceof NonMergeableLogicNodeBuilder) {\n    if (builder.children.has(key)) {\n      return [{builder: builder.children.get(key)!, predicates: []}];\n    }\n  } else {\n    throw new Error('Unknown LogicNodeBuilder type');\n  }\n  return [];\n}\n\n/**\n * Creates the full `Logic` for a given builder.\n * This function handles different types of builders (`LogicNodeBuilder`, `NonMergeableLogicNodeBuilder`)\n * and applies the provided predicates.\n * @param builder The `AbstractLogicNodeBuilder` to process.\n * @param predicates Predicates to apply to the logic derived from the builder.\n * @param depth The depth in the field tree of the field which this logic applies to.\n * @returns The `Logic` instance.\n */\nfunction createLogic(\n  builder: AbstractLogicNodeBuilder,\n  predicates: BoundPredicate[],\n  depth: number,\n): LogicContainer {\n  const logic = new LogicContainer(predicates);\n  if (builder instanceof LogicNodeBuilder) {\n    const builtNodes = builder.all.map(\n      ({builder, predicate}) =>\n        new LeafLogicNode(\n          builder,\n          predicate ? [...predicates, bindLevel(predicate, depth)] : predicates,\n          depth,\n        ),\n    );\n    for (const node of builtNodes) {\n      logic.mergeIn(node.logic);\n    }\n  } else if (builder instanceof NonMergeableLogicNodeBuilder) {\n    logic.mergeIn(builder.logic);\n  } else {\n    throw new Error('Unknown LogicNodeBuilder type');\n  }\n  return logic;\n}\n\n/**\n * Create a bound version of the given predicate to a specific depth in the field tree.\n * This allows us to unambiguously know which `FieldContext` the predicate function should receive.\n *\n * This is of particular concern when a schema is applied recursively to itself. Since the schema is\n * only compiled once, each nested application adds the same predicate instance. We differentiate\n * these by recording the depth of the field they're bound to.\n *\n * @param predicate The unbound predicate\n * @param depth The depth of the field the predicate is bound to\n * @returns A bound predicate\n */\nfunction bindLevel(predicate: Predicate, depth: number): BoundPredicate {\n  return {...predicate, depth: depth};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {FieldPath} from '../api/types';\nimport {DYNAMIC, Predicate} from './logic';\nimport {LogicNodeBuilder} from './logic_node';\nimport type {SchemaImpl} from './schema';\n\n/**\n * Special key which is used to retrieve the `FieldPathNode` instance from its `FieldPath` proxy wrapper.\n */\nconst PATH = Symbol('PATH');\n\n/**\n * A path in the schema on which logic is stored so that it can be added to the corresponding field\n * when the field is created.\n */\nexport class FieldPathNode {\n  /** The root path node from which this path node is descended. */\n  readonly root: FieldPathNode;\n\n  /**\n   * A map containing all child path nodes that have been created on this path.\n   * Child path nodes are created automatically on first access if they do not exist already.\n   */\n  private readonly children = new Map<PropertyKey, FieldPathNode>();\n\n  /**\n   * A proxy that wraps the path node, allowing navigation to its child paths via property access.\n   */\n  readonly fieldPathProxy: FieldPath<any> = new Proxy(\n    this,\n    FIELD_PATH_PROXY_HANDLER,\n  ) as unknown as FieldPath<any>;\n\n  protected constructor(\n    /** The property keys used to navigate from the root path to this path. */\n    readonly keys: PropertyKey[],\n    /** The logic builder used to accumulate logic on this path node. */\n    readonly logic: LogicNodeBuilder,\n    root: FieldPathNode,\n  ) {\n    this.root = root ?? this;\n  }\n\n  /**\n   * Gets the special path node containing the per-element logic that applies to *all* children paths.\n   */\n  get element(): FieldPathNode {\n    return this.getChild(DYNAMIC);\n  }\n\n  /**\n   * Gets the path node for the given child property key.\n   * Child paths are created automatically on first access if they do not exist already.\n   */\n  getChild(key: PropertyKey): FieldPathNode {\n    if (!this.children.has(key)) {\n      this.children.set(\n        key,\n        new FieldPathNode([...this.keys, key], this.logic.getChild(key), this.root),\n      );\n    }\n    return this.children.get(key)!;\n  }\n\n  /**\n   * Merges in logic from another schema to this one.\n   * @param other The other schema to merge in the logic from\n   * @param predicate A predicate indicating when the merged in logic should be active.\n   */\n  mergeIn(other: SchemaImpl, predicate?: Predicate) {\n    const path = other.compile();\n    this.logic.mergeIn(path.logic, predicate);\n  }\n\n  /** Extracts the underlying path node from the given path proxy. */\n  static unwrapFieldPath(formPath: FieldPath<unknown>): FieldPathNode {\n    return (formPath as any)[PATH] as FieldPathNode;\n  }\n\n  /** Creates a new root path node to be passed in to a schema function. */\n  static newRoot() {\n    return new FieldPathNode([], LogicNodeBuilder.newRoot(), undefined!);\n  }\n}\n\n/** Proxy handler which implements `FieldPath` on top of a `FieldPathNode`. */\nexport const FIELD_PATH_PROXY_HANDLER: ProxyHandler<FieldPathNode> = {\n  get(node: FieldPathNode, property: string | symbol) {\n    if (property === PATH) {\n      return node;\n    }\n\n    return node.getChild(property).fieldPathProxy;\n  },\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {FieldPath, SchemaFn, SchemaOrSchemaFn} from '../api/types';\nimport {FieldPathNode} from './path_node';\n\n/**\n * Keeps track of the path node for the schema function that is currently being compiled. This is\n * used to detect erroneous references to a path node outside of the context of its schema function.\n * Do not set this directly, it is a context variable managed by `SchemaImpl.compile`.\n */\nlet currentCompilingNode: FieldPathNode | undefined = undefined;\n\n/**\n * A cache of all schemas compiled under the current root compilation. This is used to avoid doing\n * extra work when compiling a schema that reuses references to the same sub-schema. For example:\n *\n * ```\n * const sub = schema(p => ...);\n * const s = schema(p => {\n *   apply(p.a, sub);\n *   apply(p.b, sub);\n * });\n * ```\n *\n * This also ensures that we don't go into an infinite loop when compiling a schema that references\n * itself.\n *\n * Do not directly add or remove entries from this map, it is a context variable managed by\n * `SchemaImpl.compile` and `SchemaImpl.rootCompile`.\n */\nconst compiledSchemas = new Map<SchemaImpl, FieldPathNode>();\n\n/**\n * Implements the `Schema` concept.\n */\nexport class SchemaImpl {\n  constructor(private schemaFn: SchemaFn<unknown>) {}\n\n  /**\n   * Compiles this schema within the current root compilation context. If the schema was previously\n   * compiled within this context, we reuse the cached FieldPathNode, otherwise we create a new one\n   * and cache it in the compilation context.\n   */\n  compile(): FieldPathNode {\n    if (compiledSchemas.has(this)) {\n      return compiledSchemas.get(this)!;\n    }\n    const path = FieldPathNode.newRoot();\n    compiledSchemas.set(this, path);\n    let prevCompilingNode = currentCompilingNode;\n    try {\n      currentCompilingNode = path;\n      this.schemaFn(path.fieldPathProxy);\n    } finally {\n      // Use a try/finally to ensure we restore the previous root upon completion,\n      // even if there are errors while compiling the schema.\n      currentCompilingNode = prevCompilingNode;\n    }\n    return path;\n  }\n\n  /**\n   * Creates a SchemaImpl from the given SchemaOrSchemaFn.\n   */\n  static create(schema: SchemaImpl | SchemaOrSchemaFn<any>) {\n    if (schema instanceof SchemaImpl) {\n      return schema;\n    }\n    return new SchemaImpl(schema as SchemaFn<unknown>);\n  }\n\n  /**\n   * Compiles the given schema in a fresh compilation context. This clears the cached results of any\n   * previous compilations.\n   */\n  static rootCompile(schema: SchemaImpl | SchemaOrSchemaFn<any> | undefined): FieldPathNode {\n    try {\n      compiledSchemas.clear();\n      if (schema === undefined) {\n        return FieldPathNode.newRoot();\n      }\n      if (schema instanceof SchemaImpl) {\n        return schema.compile();\n      }\n      return new SchemaImpl(schema as SchemaFn<unknown>).compile();\n    } finally {\n      // Use a try/finally to ensure we properly reset the compilation context upon completion,\n      // even if there are errors while compiling the schema.\n      compiledSchemas.clear();\n    }\n  }\n}\n\n/** Checks if the given value is a schema or schema function. */\nexport function isSchemaOrSchemaFn(value: unknown): value is SchemaOrSchemaFn<unknown> {\n  return value instanceof SchemaImpl || typeof value === 'function';\n}\n\n/** Checks that a path node belongs to the schema function currently being compiled. */\nexport function assertPathIsCurrent(path: FieldPath<unknown>): void {\n  if (currentCompilingNode !== FieldPathNode.unwrapFieldPath(path).root) {\n    throw new Error(\n      `A FieldPath can only be used directly within the Schema that owns it,` +\n        ` **not** outside of it or within a sub-schema.`,\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * Represents metadata that may be defined on a field when it is created using a `metadata` rule\n * in the schema. A particular `MetadataKey` can only be defined on a particular field **once**.\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport class MetadataKey<TValue> {\n  private brand!: TValue;\n\n  /** Use {@link createMetadataKey}. */\n  private constructor() {}\n}\n\n/**\n * Creates a {@link MetadataKey}.\n *\n * @experimental 21.0.0\n */\nexport function createMetadataKey<TValue>(): MetadataKey<TValue> {\n  return new (MetadataKey as new () => MetadataKey<TValue>)();\n}\n\n/**\n * Represents metadata that is aggregated from multiple parts according to the key's reducer\n * function. A value can be contributed to the aggregated value for a field using an\n * `aggregateMetadata` rule in the schema. There may be multiple rules in a schema that contribute\n * values to the same `AggregateMetadataKey` of the same field.\n *\n * @experimental 21.0.0\n */\nexport class AggregateMetadataKey<TAcc, TItem> {\n  private brand!: [TAcc, TItem];\n\n  /** Use {@link reducedMetadataKey}. */\n  private constructor(\n    readonly reduce: (acc: TAcc, item: TItem) => TAcc,\n    readonly getInitial: () => TAcc,\n  ) {}\n}\n\n/**\n * Creates an {@link AggregateMetadataKey} that reduces its individual values into an accumulated\n * value using the given `reduce` and `getInitial` functions.\n * @param reduce The reducer function.\n * @param getInitial A function that gets the initial value for the reduce operation.\n *\n * @experimental 21.0.0\n */\nexport function reducedMetadataKey<TAcc, TItem>(\n  reduce: (acc: TAcc, item: TItem) => TAcc,\n  getInitial: () => TAcc,\n): AggregateMetadataKey<TAcc, TItem> {\n  return new (AggregateMetadataKey as new (\n    reduce: (acc: TAcc, item: TItem) => TAcc,\n    getInitial: () => TAcc,\n  ) => AggregateMetadataKey<TAcc, TItem>)(reduce, getInitial);\n}\n\n/**\n * Creates an {@link AggregateMetadataKey} that reduces its individual values into a list.\n *\n * @experimental 21.0.0\n */\nexport function listMetadataKey<TItem>(): AggregateMetadataKey<TItem[], TItem | undefined> {\n  return reducedMetadataKey<TItem[], TItem | undefined>(\n    (acc, item) => (item === undefined ? acc : [...acc, item]),\n    () => [],\n  );\n}\n\n/**\n * Creates {@link AggregateMetadataKey} that reduces its individual values by taking their min.\n *\n * @experimental 21.0.0\n */\nexport function minMetadataKey(): AggregateMetadataKey<number | undefined, number | undefined> {\n  return reducedMetadataKey<number | undefined, number | undefined>(\n    (prev, next) => {\n      if (prev === undefined) {\n        return next;\n      }\n      if (next === undefined) {\n        return prev;\n      }\n      return Math.min(prev, next);\n    },\n    () => undefined,\n  );\n}\n\n/**\n * Creates {@link AggregateMetadataKey} that reduces its individual values by taking their max.\n *\n * @experimental 21.0.0\n */\nexport function maxMetadataKey(): AggregateMetadataKey<number | undefined, number | undefined> {\n  return reducedMetadataKey<number | undefined, number | undefined>(\n    (prev, next) => {\n      if (prev === undefined) {\n        return next;\n      }\n      if (next === undefined) {\n        return prev;\n      }\n      return Math.max(prev, next);\n    },\n    () => undefined,\n  );\n}\n\n/**\n * Creates an {@link AggregateMetadataKey} that reduces its individual values by logically or-ing\n * them.\n *\n * @experimental 21.0.0\n */\nexport function orMetadataKey(): AggregateMetadataKey<boolean, boolean> {\n  return reducedMetadataKey(\n    (prev, next) => prev || next,\n    () => false,\n  );\n}\n\n/**\n * Creates an {@link AggregateMetadataKey} that reduces its individual values by logically and-ing\n * them.\n *\n * @experimental 21.0.0\n */\nexport function andMetadataKey(): AggregateMetadataKey<boolean, boolean> {\n  return reducedMetadataKey(\n    (prev, next) => prev && next,\n    () => true,\n  );\n}\n\n/**\n * An {@link AggregateMetadataKey} representing whether the field is required.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const REQUIRED: AggregateMetadataKey<boolean, boolean> = orMetadataKey();\n\n/**\n * An {@link AggregateMetadataKey} representing the min value of the field.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const MIN: AggregateMetadataKey<number | undefined, number | undefined> = maxMetadataKey();\n\n/**\n * An {@link AggregateMetadataKey} representing the max value of the field.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const MAX: AggregateMetadataKey<number | undefined, number | undefined> = minMetadataKey();\n\n/**\n * An {@link AggregateMetadataKey} representing the min length of the field.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const MIN_LENGTH: AggregateMetadataKey<number | undefined, number | undefined> =\n  maxMetadataKey();\n\n/**\n * An {@link AggregateMetadataKey} representing the max length of the field.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const MAX_LENGTH: AggregateMetadataKey<number | undefined, number | undefined> =\n  minMetadataKey();\n\n/**\n * An {@link AggregateMetadataKey} representing the patterns the field must match.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const PATTERN: AggregateMetadataKey<RegExp[], RegExp | undefined> =\n  listMetadataKey<RegExp>();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {addDefaultField} from '../field/validation';\nimport {FieldPathNode} from '../schema/path_node';\nimport {assertPathIsCurrent} from '../schema/schema';\nimport {AggregateMetadataKey, createMetadataKey, MetadataKey} from './metadata';\nimport type {\n  FieldContext,\n  FieldPath,\n  FieldValidator,\n  LogicFn,\n  PathKind,\n  TreeValidator,\n} from './types';\n\n/**\n * Adds logic to a field to conditionally disable it. A disabled field does not contribute to the\n * validation, touched/dirty, or other state of its parent field.\n *\n * @param path The target path to add the disabled logic to.\n * @param logic A reactive function that returns `true` (or a string reason) when the field is disabled,\n *   and `false` when it is not disabled.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function disabled<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<TValue, TPathKind>,\n  logic?: string | NoInfer<LogicFn<TValue, boolean | string, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.logic.addDisabledReasonRule((ctx) => {\n    let result: boolean | string = true;\n    if (typeof logic === 'string') {\n      result = logic;\n    } else if (logic) {\n      result = logic(ctx as FieldContext<TValue, TPathKind>);\n    }\n    if (typeof result === 'string') {\n      return {field: ctx.field, message: result};\n    }\n    return result ? {field: ctx.field} : undefined;\n  });\n}\n\n/**\n * Adds logic to a field to conditionally make it readonly. A readonly field does not contribute to\n * the validation, touched/dirty, or other state of its parent field.\n *\n * @param path The target path to make readonly.\n * @param logic A reactive function that returns `true` when the field is readonly.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function readonly<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<TValue, TPathKind>,\n  logic: NoInfer<LogicFn<TValue, boolean, TPathKind>> = () => true,\n) {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.logic.addReadonlyRule(logic);\n}\n\n/**\n * Adds logic to a field to conditionally hide it. A hidden field does not contribute to the\n * validation, touched/dirty, or other state of its parent field.\n *\n * If a field may be hidden it is recommended to guard it with an `@if` in the template:\n * ```\n * @if (!email().hidden()) {\n *   <label for=\"email\">Email</label>\n *   <input id=\"email\" type=\"email\" [control]=\"email\" />\n * }\n * ```\n *\n * @param path The target path to add the hidden logic to.\n * @param logic A reactive function that returns `true` when the field is hidden.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function hidden<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<TValue, TPathKind>,\n  logic: NoInfer<LogicFn<TValue, boolean, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.logic.addHiddenRule(logic);\n}\n\n/**\n * Adds logic to a field to determine if the field has validation errors.\n *\n * @param path The target path to add the validation logic to.\n * @param logic A `Validator` that returns the current validation errors.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function validate<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<TValue, TPathKind>,\n  logic: NoInfer<FieldValidator<TValue, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.logic.addSyncErrorRule((ctx) =>\n    addDefaultField(logic(ctx as FieldContext<TValue, TPathKind>), ctx.field),\n  );\n}\n\n/**\n * Adds logic to a field to determine if the field or any of its child fields has validation errors.\n *\n * @param path The target path to add the validation logic to.\n * @param logic A `TreeValidator` that returns the current validation errors.\n *   Errors returned by the validator may specify a target field to indicate an error on a child field.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function validateTree<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<TValue, TPathKind>,\n  logic: NoInfer<TreeValidator<TValue, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.logic.addSyncTreeErrorRule((ctx) =>\n    addDefaultField(logic(ctx as FieldContext<TValue, TPathKind>), ctx.field),\n  );\n}\n\n/**\n * Adds a value to an {@link AggregateMetadataKey} of a field.\n *\n * @param path The target path to set the aggregate metadata on.\n * @param key The aggregate metadata key\n * @param logic A function that receives the `FieldContext` and returns a value to add to the aggregate metadata.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TMetadataItem The type of value the metadata aggregates over.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function aggregateMetadata<\n  TValue,\n  TMetadataItem,\n  TPathKind extends PathKind = PathKind.Root,\n>(\n  path: FieldPath<TValue, TPathKind>,\n  key: AggregateMetadataKey<any, TMetadataItem>,\n  logic: NoInfer<LogicFn<TValue, TMetadataItem, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.logic.addAggregateMetadataRule(key, logic);\n}\n\n/**\n * Creates a new {@link MetadataKey} and defines the value of the new metadata key for the given field.\n *\n * @param path The path to define the metadata for.\n * @param factory A factory function that creates the value for the metadata.\n *   This function is **not** reactive. It is run once when the field is created.\n * @returns The newly created metadata key\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function metadata<TValue, TData, TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<TValue, TPathKind>,\n  factory: (ctx: FieldContext<TValue, TPathKind>) => TData,\n): MetadataKey<TData>;\n\n/**\n * Defines the value of a {@link MetadataKey} for a given field.\n *\n * @param path The path to define the metadata for.\n * @param key  The metadata key to define.\n * @param factory A factory function that creates the value for the metadata.\n *   This function is **not** reactive. It is run once when the field is created.\n * @returns The given metadata key\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function metadata<TValue, TData, TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<TValue, TPathKind>,\n  key: MetadataKey<TData>,\n  factory: (ctx: FieldContext<TValue, TPathKind>) => TData,\n): MetadataKey<TData>;\n\nexport function metadata<TValue, TData, TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<TValue, TPathKind>,\n  ...rest:\n    | [(ctx: FieldContext<TValue, TPathKind>) => TData]\n    | [MetadataKey<TData>, (ctx: FieldContext<TValue, TPathKind>) => TData]\n): MetadataKey<TData> {\n  assertPathIsCurrent(path);\n\n  let key: MetadataKey<TData>;\n  let factory: (ctx: FieldContext<TValue, TPathKind>) => TData;\n  if (rest.length === 2) {\n    [key, factory] = rest;\n  } else {\n    [factory] = rest;\n  }\n  key ??= createMetadataKey();\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.logic.addMetadataFactory(key, factory as (ctx: FieldContext<unknown>) => unknown);\n  return key;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {httpResource, HttpResourceOptions, HttpResourceRequest} from '@angular/common/http';\nimport {computed, ResourceRef, Signal} from '@angular/core';\nimport {FieldNode} from '../field/node';\nimport {addDefaultField} from '../field/validation';\nimport {FieldPathNode} from '../schema/path_node';\nimport {assertPathIsCurrent} from '../schema/schema';\nimport {metadata} from './logic';\nimport {FieldContext, FieldPath, PathKind, TreeValidationResult} from './types';\n\n/**\n * A function that takes the result of an async operation and the current field context, and maps it\n * to a list of validation errors.\n *\n * @param result The result of the async operation.\n * @param ctx The context for the field the validator is attached to.\n * @return A validation error, or list of validation errors to report based on the result of the async operation.\n *   The returned errors can optionally specify a field that the error should be targeted to.\n *   A targeted error will show up as an error on its target field rather than the field being validated.\n *   If a field is not given, the error is assumed to apply to the field being validated.\n * @template TValue The type of value stored in the field being validated.\n * @template TResult The type of result returned by the async operation\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @experimental 21.0.0\n */\nexport type MapToErrorsFn<TValue, TResult, TPathKind extends PathKind = PathKind.Root> = (\n  result: TResult,\n  ctx: FieldContext<TValue, TPathKind>,\n) => TreeValidationResult;\n\n/**\n * Options that indicate how to create a resource for async validation for a field,\n * and map its result to validation errors.\n *\n * @template TValue The type of value stored in the field being validated.\n * @template TParams The type of parameters to the resource.\n * @template TResult The type of result returned by the resource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport interface AsyncValidatorOptions<\n  TValue,\n  TParams,\n  TResult,\n  TPathKind extends PathKind = PathKind.Root,\n> {\n  /**\n   * A function that receives the field context and returns the params for the resource.\n   *\n   * @param ctx The field context for the field being validated.\n   * @returns The params for the resource.\n   */\n  readonly params: (ctx: FieldContext<TValue, TPathKind>) => TParams;\n\n  /**\n   * A function that receives the resource params and returns a resource of the given params.\n   * The given params should be used as is to create the resource.\n   * The forms system will report the params as `undefined` when this validation doesn't need to be run.\n   *\n   * @param params The params to use for constructing the resource\n   * @returns A reference to the constructed resource.\n   */\n  readonly factory: (params: Signal<TParams | undefined>) => ResourceRef<TResult | undefined>;\n\n  /**\n   * A function that takes the resource result, and the current field context and maps it to a list\n   * of validation errors.\n   *\n   * @param result The resource result.\n   * @param ctx The context for the field the validator is attached to.\n   * @return A validation error, or list of validation errors to report based on the resource result.\n   *   The returned errors can optionally specify a field that the error should be targeted to.\n   *   A targeted error will show up as an error on its target field rather than the field being validated.\n   *   If a field is not given, the error is assumed to apply to the field being validated.\n   */\n  readonly errors: MapToErrorsFn<TValue, TResult, TPathKind>;\n}\n\n/**\n * Options that indicate how to create an httpResource for async validation for a field,\n * and map its result to validation errors.\n *\n * @template TValue The type of value stored in the field being validated.\n * @template TResult The type of result returned by the httpResource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport interface HttpValidatorOptions<TValue, TResult, TPathKind extends PathKind = PathKind.Root> {\n  /**\n   * A function that receives the field context and returns the url or request for the httpResource.\n   * If given a URL, the underlying httpResource will perform an HTTP GET on it.\n   *\n   * @param ctx The field context for the field being validated.\n   * @returns The URL or request for creating the httpResource.\n   */\n  readonly request:\n    | ((ctx: FieldContext<TValue, TPathKind>) => string | undefined)\n    | ((ctx: FieldContext<TValue, TPathKind>) => HttpResourceRequest | undefined);\n\n  /**\n   * A function that takes the httpResource result, and the current field context and maps it to a\n   * list of validation errors.\n   *\n   * @param result The httpResource result.\n   * @param ctx The context for the field the validator is attached to.\n   * @return A validation error, or list of validation errors to report based on the httpResource result.\n   *   The returned errors can optionally specify a field that the error should be targeted to.\n   *   A targeted error will show up as an error on its target field rather than the field being validated.\n   *   If a field is not given, the error is assumed to apply to the field being validated.\n   */\n  readonly errors: MapToErrorsFn<TValue, TResult, TPathKind>;\n\n  /**\n   * The options to use when creating the httpResource.\n   */\n  readonly options?: HttpResourceOptions<TResult, unknown>;\n}\n\n/**\n * Adds async validation to the field corresponding to the given path based on a resource.\n * Async validation for a field only runs once all synchronous validation is passing.\n *\n * @param path A path indicating the field to bind the async validation logic to.\n * @param opts The async validation options.\n * @template TValue The type of value stored in the field being validated.\n * @template TParams The type of parameters to the resource.\n * @template TResult The type of result returned by the resource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function validateAsync<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<TValue, TPathKind>,\n  opts: AsyncValidatorOptions<TValue, TParams, TResult, TPathKind>,\n): void {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n\n  const RESOURCE = metadata(path, (ctx) => {\n    const params = computed(() => {\n      const node = ctx.stateOf(path) as FieldNode;\n      const validationState = node.validationState;\n      if (validationState.shouldSkipValidation() || !validationState.syncValid()) {\n        return undefined;\n      }\n      return opts.params(ctx);\n    });\n    return opts.factory(params);\n  });\n\n  pathNode.logic.addAsyncErrorRule((ctx) => {\n    const res = ctx.state.metadata(RESOURCE)!;\n    switch (res.status()) {\n      case 'idle':\n        return undefined;\n      case 'loading':\n      case 'reloading':\n        return 'pending';\n      case 'resolved':\n      case 'local':\n        if (!res.hasValue()) {\n          return undefined;\n        }\n        const errors = opts.errors(res.value()!, ctx as FieldContext<TValue, TPathKind>);\n        return addDefaultField(errors, ctx.field);\n      case 'error':\n        // TODO: Design error handling for async validation. For now, just throw the error.\n        throw res.error();\n    }\n  });\n}\n\n/**\n * Adds async validation to the field corresponding to the given path based on an httpResource.\n * Async validation for a field only runs once all synchronous validation is passing.\n *\n * @param path A path indicating the field to bind the async validation logic to.\n * @param opts The http validation options.\n * @template TValue The type of value stored in the field being validated.\n * @template TResult The type of result returned by the httpResource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function validateHttp<TValue, TResult = unknown, TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<TValue, TPathKind>,\n  opts: HttpValidatorOptions<TValue, TResult, TPathKind>,\n) {\n  validateAsync(path, {\n    params: opts.request,\n    factory: (request: Signal<any>) => httpResource(request, opts.options),\n    errors: opts.errors,\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ControlValueAccessor,\n  Validators,\n  type AbstractControl,\n  type FormControlStatus,\n  type NgControl,\n  type ValidationErrors,\n  type ValidatorFn,\n} from '@angular/forms';\nimport {REQUIRED} from '../api/metadata';\nimport type {FieldState} from '../api/types';\n\n// TODO: Also consider supporting (if possible):\n// - hasError\n// - getError\n// - reset\n// - name\n// - path\n// - markAs[Touched,Dirty,etc.]\n\n/**\n * Properties of both NgControl & AbstractControl that are supported by the InteropNgControl.\n */\nexport type InteropSharedKeys =\n  | 'value'\n  | 'valid'\n  | 'invalid'\n  | 'touched'\n  | 'untouched'\n  | 'disabled'\n  | 'enabled'\n  | 'errors'\n  | 'pristine'\n  | 'dirty'\n  | 'status';\n\n/**\n * A fake version of `NgControl` provided by the `Field` directive. This allows interoperability\n * with a wider range of components designed to work with reactive forms, in particular ones that\n * inject the `NgControl`. The interop control does not implement *all* properties and methods of\n * the real `NgControl`, but does implement some of the most commonly used ones that have a clear\n * equivalent in signal forms.\n */\nexport class InteropNgControl\n  implements\n    Pick<NgControl, InteropSharedKeys | 'control' | 'valueAccessor'>,\n    Pick<AbstractControl<unknown>, InteropSharedKeys | 'hasValidator'>\n{\n  constructor(protected field: () => FieldState<unknown>) {}\n\n  readonly control: AbstractControl<any, any> = this as unknown as AbstractControl<any, any>;\n\n  get value(): any {\n    return this.field().value();\n  }\n\n  get valid(): boolean {\n    return this.field().valid();\n  }\n\n  get invalid(): boolean {\n    return this.field().invalid();\n  }\n\n  get pending(): boolean | null {\n    return this.field().pending();\n  }\n\n  get disabled(): boolean {\n    return this.field().disabled();\n  }\n\n  get enabled(): boolean {\n    return !this.field().disabled();\n  }\n\n  get errors(): ValidationErrors | null {\n    const errors = this.field().errors();\n    if (errors.length === 0) {\n      return null;\n    }\n    const errObj: ValidationErrors = {};\n    for (const error of errors) {\n      errObj[error.kind] = error;\n    }\n    return errObj;\n  }\n\n  get pristine(): boolean {\n    return !this.field().dirty();\n  }\n\n  get dirty(): boolean {\n    return this.field().dirty();\n  }\n\n  get touched(): boolean {\n    return this.field().touched();\n  }\n\n  get untouched(): boolean {\n    return !this.field().touched();\n  }\n\n  get status(): FormControlStatus {\n    if (this.field().disabled()) {\n      return 'DISABLED';\n    }\n    if (this.field().valid()) {\n      return 'VALID';\n    }\n    if (this.field().invalid()) {\n      return 'INVALID';\n    }\n    if (this.field().pending()) {\n      return 'PENDING';\n    }\n    throw Error('AssertionError: unknown form control status');\n  }\n\n  valueAccessor: ControlValueAccessor | null = null;\n\n  hasValidator(validator: ValidatorFn): boolean {\n    // This addresses a common case where users look for the presence of `Validators.required` to\n    // determine whether or not to show a required \"*\" indicator in the UI.\n    if (validator === Validators.required) {\n      return this.field().metadata(REQUIRED)();\n    }\n    return false;\n  }\n\n  updateValueAndValidity() {\n    // No-op since value and validity are always up to date in signal forms.\n    // We offer this method so that reactive forms code attempting to call it doesn't error.\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  computed,\n  Directive,\n  effect,\n  inject,\n  InjectionToken,\n  Injector,\n  input,\n  untracked,\n  ÉµCONTROL,\n  ÉµControl,\n} from '@angular/core';\nimport {ControlValueAccessor, NG_VALUE_ACCESSOR, NgControl} from '@angular/forms';\nimport {InteropNgControl} from '../controls/interop_ng_control';\nimport type {FieldNode} from '../field/node';\nimport type {FieldTree} from './types';\n\n/**\n * Lightweight DI token provided by the {@link Field} directive.\n */\nexport const FIELD = new InjectionToken<Field<unknown>>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'FIELD' : '',\n);\n\n/**\n * Binds a form `FieldTree` to a UI control that edits it. A UI control can be one of several things:\n * 1. A native HTML input or textarea\n * 2. A signal forms custom control that implements `FormValueControl` or `FormCheckboxControl`\n * 3. A component that provides a `ControlValueAccessor`. This should only be used for backwards\n *    compatibility with reactive forms. Prefer options (1) and (2).\n *\n * This directive has several responsibilities:\n * 1. Two-way binds the field's value with the UI control's value\n * 2. Binds additional forms related state on the field to the UI control (disabled, required, etc.)\n * 3. Relays relevant events on the control to the field (e.g. marks field touched on blur)\n * 4. Provides a fake `NgControl` that implements a subset of the features available on the\n *    reactive forms `NgControl`. This is provided to improve interoperability with controls\n *    designed to work with reactive forms. It should not be used by controls written for signal\n *    forms.\n *\n * @category control\n * @experimental 21.0.0\n */\n@Directive({\n  selector: '[field]',\n  providers: [\n    {provide: FIELD, useExisting: Field},\n    {provide: NgControl, useFactory: () => inject(Field).ÉµgetOrCreateNgControl()},\n  ],\n})\nexport class Field<T> implements ÉµControl<T> {\n  private readonly injector = inject(Injector);\n  readonly field = input.required<FieldTree<T>>();\n  readonly state = computed(() => this.field()());\n  readonly [ÉµCONTROL] = undefined;\n\n  /** Any `ControlValueAccessor` instances provided on the host element. */\n  private readonly controlValueAccessors = inject(NG_VALUE_ACCESSOR, {optional: true, self: true});\n\n  /** A lazily instantiated fake `NgControl`. */\n  private interopNgControl: InteropNgControl | undefined;\n\n  /** A `ControlValueAccessor`, if configured, for the host component. */\n  private get controlValueAccessor(): ControlValueAccessor | undefined {\n    return this.controlValueAccessors?.[0] ?? this.interopNgControl?.valueAccessor ?? undefined;\n  }\n\n  get ÉµhasInteropControl() {\n    return this.controlValueAccessor !== undefined;\n  }\n\n  /** Lazily instantiates a fake `NgControl` for this field. */\n  ÉµgetOrCreateNgControl(): InteropNgControl {\n    return (this.interopNgControl ??= new InteropNgControl(this.state));\n  }\n\n  ÉµinteropControlCreate() {\n    const controlValueAccessor = this.controlValueAccessor!;\n    controlValueAccessor.registerOnChange((value: T) => {\n      const state = this.state();\n      state.value.set(value);\n      state.markAsDirty();\n    });\n    controlValueAccessor.registerOnTouched(() => this.state().markAsTouched());\n  }\n\n  ÉµinteropControlUpdate() {\n    const controlValueAccessor = this.controlValueAccessor!;\n    // TODO: https://github.com/orgs/angular/projects/60/views/1?pane=issue&itemId=131711472\n    // * check if values changed since last update before writing.\n\n    // These values remain reactive\n    const value = this.state().value();\n    const disabled = this.state().disabled();\n\n    // The CVA is accessed in a reactive context (the template executation)\n    // Since we don't control the implementation of the CVA and it can have underlying signals\n    // We need to untrack to prevent writing to a signal in a reactive context\n    untracked(() => {\n      controlValueAccessor.writeValue(value);\n      controlValueAccessor.setDisabledState?.(disabled);\n    });\n  }\n\n  // TODO: https://github.com/orgs/angular/projects/60/views/1?pane=issue&itemId=131861631\n  Éµregister() {\n    // Register this control on the field it is currently bound to. We do this at the end of\n    // initialization so that it only runs if we are actually syncing with this control\n    // (as opposed to just passing the field through to its `field` input).\n    effect(\n      (onCleanup) => {\n        const fieldNode = this.state() as FieldNode;\n        fieldNode.nodeState.fieldBindings.update((controls) => [\n          ...controls,\n          this as Field<unknown>,\n        ]);\n        onCleanup(() => {\n          fieldNode.nodeState.fieldBindings.update((controls) =>\n            controls.filter((c) => c !== this),\n          );\n        });\n      },\n      {injector: this.injector},\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, Signal, untracked, WritableSignal} from '@angular/core';\nimport {FieldContext, FieldPath, FieldState, FieldTree} from '../api/types';\nimport {FieldPathNode} from '../schema/path_node';\nimport {isArray} from '../util/type_guards';\nimport type {FieldNode} from './node';\nimport {getBoundPathDepth} from './resolution';\n\n/**\n * `FieldContext` implementation, backed by a `FieldNode`.\n */\nexport class FieldNodeContext implements FieldContext<unknown> {\n  /**\n   * Cache of paths that have been resolved for this context.\n   *\n   * For each resolved path we keep track of a signal of field that it maps to rather than a static\n   * field, since it theoretically could change. In practice for the current system it should not\n   * actually change, as they only place we currently track fields moving within the parent\n   * structure is for arrays, and paths do not currently support array indexing.\n   */\n  private readonly cache = new WeakMap<FieldPath<unknown>, Signal<FieldTree<unknown>>>();\n\n  constructor(\n    /** The field node this context corresponds to. */\n    private readonly node: FieldNode,\n  ) {}\n\n  /**\n   * Resolves a target path relative to this context.\n   * @param target The path to resolve\n   * @returns The field corresponding to the target path.\n   */\n  private resolve<U>(target: FieldPath<U>): FieldTree<U> {\n    if (!this.cache.has(target)) {\n      const resolver = computed<FieldTree<unknown>>(() => {\n        const targetPathNode = FieldPathNode.unwrapFieldPath(target);\n\n        // First, find the field where the root our target path was merged in.\n        // We determine this by walking up the field tree from the current field and looking for\n        // the place where the LogicNodeBuilder from the target path's root was merged in.\n        // We always make sure to walk up at least as far as the depth of the path we were bound to.\n        // This ensures that we do not accidentally match on the wrong application of a recursively\n        // applied schema.\n        let field: FieldNode | undefined = this.node;\n        let stepsRemaining = getBoundPathDepth();\n        while (stepsRemaining > 0 || !field.structure.logic.hasLogic(targetPathNode.root.logic)) {\n          stepsRemaining--;\n          field = field.structure.parent;\n          if (field === undefined) {\n            throw new Error('Path is not part of this field tree.');\n          }\n        }\n\n        // Now, we can navigate to the target field using the relative path in the target path node\n        // to traverse down from the field we just found.\n        for (let key of targetPathNode.keys) {\n          field = field.structure.getChild(key);\n          if (field === undefined) {\n            throw new Error(\n              `Cannot resolve path .${targetPathNode.keys.join('.')} relative to field ${[\n                '<root>',\n                ...this.node.structure.pathKeys(),\n              ].join('.')}.`,\n            );\n          }\n        }\n\n        return field.fieldProxy;\n      });\n\n      this.cache.set(target, resolver);\n    }\n    return this.cache.get(target)!() as FieldTree<U>;\n  }\n\n  get field(): FieldTree<unknown> {\n    return this.node.fieldProxy;\n  }\n\n  get state(): FieldState<unknown> {\n    return this.node;\n  }\n\n  get value(): WritableSignal<unknown> {\n    return this.node.structure.value;\n  }\n\n  get key(): Signal<string> {\n    return this.node.structure.keyInParent;\n  }\n\n  readonly index = computed(() => {\n    // Attempt to read the key first, this will throw an error if we're on a root field.\n    const key = this.key();\n    // Assert that the parent is actually an array.\n    if (!isArray(untracked(this.node.structure.parent!.value))) {\n      throw new Error(`RuntimeError: cannot access index, parent field is not an array`);\n    }\n    // Return the key as a number if we are indeed inside an array field.\n    return Number(key);\n  });\n\n  readonly fieldOf = <P>(p: FieldPath<P>) => this.resolve(p);\n  readonly stateOf = <P>(p: FieldPath<P>) => this.resolve(p)();\n  readonly valueOf = <P>(p: FieldPath<P>) => this.resolve(p)().value();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, runInInjectionContext, Signal, untracked} from '@angular/core';\nimport {AggregateMetadataKey, MetadataKey} from '../api/metadata';\nimport type {FieldNode} from './node';\nimport {cast} from './util';\n\n/**\n * Tracks custom metadata associated with a `FieldNode`.\n */\nexport class FieldMetadataState {\n  /** A map of all `MetadataKey` and `AggregateMetadataKey` that have been defined for this field. */\n  private readonly metadata = new Map<\n    MetadataKey<unknown> | AggregateMetadataKey<unknown, unknown>,\n    unknown\n  >();\n\n  constructor(private readonly node: FieldNode) {\n    // Field nodes (and thus their metadata state) are created in a linkedSignal in order to mirror\n    // the structure of the model data. We need to run the metadata factories untracked so that they\n    // do not cause recomputation of the linkedSignal.\n    untracked(() =>\n      // Metadata factories are run in the form's injection context so they can create resources\n      // and inject DI dependencies.\n      runInInjectionContext(this.node.structure.injector, () => {\n        for (const [key, factory] of this.node.logicNode.logic.getMetadataFactoryEntries()) {\n          this.metadata.set(key, factory(this.node.context));\n        }\n      }),\n    );\n  }\n\n  /** Gets the value of a `MetadataKey` or `AggregateMetadataKey` for the field. */\n  get<T>(key: MetadataKey<T> | AggregateMetadataKey<T, unknown>): T | undefined | Signal<T> {\n    if (key instanceof MetadataKey) {\n      return this.metadata.get(key) as T | undefined;\n    }\n    // Aggregate metadata comes with an initial value, and are considered to exist for every field.\n    // If no logic explicitly contributes values for the metadata, it is just considered to be the\n    // initial value. Therefore if the user asks for aggregate metadata for a field,\n    // we just create its computed on the fly.\n    cast<AggregateMetadataKey<unknown, unknown>>(key);\n    if (!this.metadata.has(key)) {\n      const logic = this.node.logicNode.logic.getAggregateMetadata(key);\n      const result = computed(() => logic.compute(this.node.context));\n      this.metadata.set(key, result);\n    }\n    return this.metadata.get(key)! as Signal<T>;\n  }\n\n  /** Checks whether the current metadata state has the given metadata key. */\n  has(key: MetadataKey<any> | AggregateMetadataKey<any, any>): boolean {\n    if (key instanceof AggregateMetadataKey) {\n      // For aggregate metadata keys, they get added to the map lazily, on first access, so we can't\n      // rely on checking presence in the metadata map. Instead we check if there is any logic for\n      // the given metadata key.\n      return this.node.logicNode.logic.hasAggregateMetadata(key);\n    } else {\n      // Non-aggregate metadata gets added to our metadata map on construction, so we can just\n      // refer to their presence in the map.\n      return this.metadata.has(key);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {untracked} from '@angular/core';\nimport {isArray} from '../util/type_guards';\nimport type {FieldNode} from './node';\n\n/**\n * Proxy handler which implements `FieldTree<T>` on top of `FieldNode`.\n */\nexport const FIELD_PROXY_HANDLER: ProxyHandler<() => FieldNode> = {\n  get(getTgt: () => FieldNode, p: string | symbol) {\n    const tgt = getTgt();\n\n    // First, check whether the requested property is a defined child node of this node.\n    const child = tgt.structure.getChild(p);\n    if (child !== undefined) {\n      // If so, return the child node's `FieldTree` proxy, allowing the developer to continue\n      // navigating the form structure.\n      return child.fieldProxy;\n    }\n\n    // Otherwise, we need to consider whether the properties they're accessing are related to array\n    // iteration. We're specifically interested in `length`, but we only want to pass this through\n    // if the value is actually an array.\n    //\n    // We untrack the value here to avoid spurious reactive notifications. In reality, we've already\n    // incurred a dependency on the value via `tgt.getChild()` above.\n    const value = untracked(tgt.value);\n\n    if (isArray(value)) {\n      // Allow access to the length for field arrays, it should be the same as the length of the data.\n      if (p === 'length') {\n        return (tgt.value() as Array<unknown>).length;\n      }\n      // Allow access to the iterator. This allows the user to spread the field array into a\n      // standard array in order to call methods like `filter`, `map`, etc.\n      if (p === Symbol.iterator) {\n        return (Array.prototype as any)[p];\n      }\n      // Note: We can consider supporting additional array methods if we want in the future,\n      // but they should be thoroughly tested. Just forwarding the method directly from the\n      // `Array` prototype results in broken behavior for some methods like `map`.\n    }\n\n    // Otherwise, this property doesn't exist.\n    return undefined;\n  },\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, Signal, untracked, WritableSignal} from '@angular/core';\nimport {SIGNAL} from '@angular/core/primitives/signals';\nimport {isArray} from './type_guards';\n\n/**\n * Creates a writable signal for a specific property on a source writeable signal.\n * @param source A writeable signal to derive from\n * @param prop A signal of a property key of the source value\n * @returns A writeable signal for the given property of the source value.\n * @template S The source value type\n * @template K The key type for S\n */\nexport function deepSignal<S, K extends keyof S>(\n  source: WritableSignal<S>,\n  prop: Signal<K>,\n): WritableSignal<S[K]> {\n  // Memoize the property.\n  const read = computed(() => source()[prop()]) as WritableSignal<S[K]>;\n\n  read[SIGNAL] = source[SIGNAL];\n  read.set = (value: S[K]) => {\n    source.update((current) => valueForWrite(current, value, prop()) as S);\n  };\n\n  read.update = (fn: (current: S[K]) => S[K]) => {\n    read.set(fn(untracked(read)));\n  };\n  read.asReadonly = () => read;\n\n  return read;\n}\n\n/**\n * Gets an updated root value to use when setting a value on a deepSignal with the given path.\n * @param sourceValue The current value of the deepSignal's source.\n * @param newPropValue The value being written to the deepSignal's property\n * @param prop The deepSignal's property key\n * @returns An updated value for the deepSignal's source\n */\nfunction valueForWrite(sourceValue: unknown, newPropValue: unknown, prop: PropertyKey): unknown {\n  if (isArray(sourceValue)) {\n    const newValue = [...sourceValue];\n    newValue[prop as number] = newPropValue;\n    return newValue;\n  } else {\n    return {...(sourceValue as object), [prop]: newPropValue};\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  computed,\n  DestroyableInjector,\n  Injector,\n  linkedSignal,\n  Signal,\n  WritableSignal,\n} from '@angular/core';\n\nimport {DYNAMIC} from '../schema/logic';\nimport {LogicNode} from '../schema/logic_node';\nimport type {FieldPathNode} from '../schema/path_node';\nimport {deepSignal} from '../util/deep_signal';\nimport {isArray, isObject} from '../util/type_guards';\nimport type {FormFieldManager} from './manager';\nimport type {FieldNode, ParentFieldNode} from './node';\nimport type {FieldAdapter} from './field_adapter';\n\n/**\n * Key by which a parent `FieldNode` tracks its children.\n *\n * Often this is the actual property key of the child, but in the case of arrays it could be a\n * tracking key allocated for the object.\n */\nexport type TrackingKey = PropertyKey & {__brand: 'FieldIdentity'};\n\n/** Structural component of a `FieldNode` which tracks its path, parent, and children. */\nexport abstract class FieldNodeStructure {\n  /** Computed map of child fields, based on the current value of this field. */\n  abstract readonly childrenMap: Signal<Map<TrackingKey, FieldNode> | undefined>;\n\n  /** The field's value. */\n  abstract readonly value: WritableSignal<unknown>;\n\n  /**\n   * The key of this field in its parent field.\n   * Attempting to read this for the root field will result in an error being thrown.\n   */\n  abstract readonly keyInParent: Signal<string>;\n\n  /** The field manager responsible for managing this field. */\n  abstract readonly fieldManager: FormFieldManager;\n\n  /** The root field that this field descends from. */\n  abstract readonly root: FieldNode;\n\n  /** The list of property keys to follow to get from the `root` to this field. */\n  abstract readonly pathKeys: Signal<readonly PropertyKey[]>;\n\n  /** The parent field of this field. */\n  abstract readonly parent: FieldNode | undefined;\n\n  /** Added to array elements for tracking purposes. */\n  // TODO: given that we don't ever let a field move between parents, is it safe to just extract\n  // this to a shared symbol for all fields, rather than having a separate one per parent?\n  readonly identitySymbol = Symbol();\n\n  /** Lazily initialized injector. Do not access directly, access via `injector` getter instead. */\n  private _injector: DestroyableInjector | undefined = undefined;\n\n  /** Lazily initialized injector. */\n  get injector(): DestroyableInjector {\n    this._injector ??= Injector.create({\n      providers: [],\n      parent: this.fieldManager.injector,\n    }) as DestroyableInjector;\n    return this._injector;\n  }\n\n  constructor(\n    /** The logic to apply to this field. */\n    readonly logic: LogicNode,\n  ) {}\n\n  /** Gets the child fields of this field. */\n  children(): Iterable<FieldNode> {\n    return this.childrenMap()?.values() ?? [];\n  }\n\n  /** Retrieve a child `FieldNode` of this node by property key. */\n  getChild(key: PropertyKey): FieldNode | undefined {\n    const map = this.childrenMap();\n    const value = this.value();\n    if (!map || !isObject(value)) {\n      return undefined;\n    }\n\n    if (isArray(value)) {\n      const childValue = value[key];\n      if (isObject(childValue) && childValue.hasOwnProperty(this.identitySymbol)) {\n        // For arrays, we want to use the tracking identity of the value instead of the raw property\n        // as our index into the `childrenMap`.\n        key = childValue[this.identitySymbol] as PropertyKey;\n      }\n    }\n\n    return map.get((typeof key === 'number' ? key.toString() : key) as TrackingKey);\n  }\n\n  /** Destroys the field when it is no longer needed. */\n  destroy(): void {\n    this.injector.destroy();\n  }\n}\n\n/** The structural component of a `FieldNode` that is the root of its field tree. */\nexport class RootFieldNodeStructure extends FieldNodeStructure {\n  override get parent(): undefined {\n    return undefined;\n  }\n\n  override get root(): FieldNode {\n    return this.node;\n  }\n\n  override get pathKeys(): Signal<readonly PropertyKey[]> {\n    return ROOT_PATH_KEYS;\n  }\n\n  override get keyInParent(): Signal<string> {\n    return ROOT_KEY_IN_PARENT;\n  }\n\n  override readonly childrenMap: Signal<Map<TrackingKey, FieldNode> | undefined>;\n\n  /**\n   * Creates the structure for the root node of a field tree.\n   *\n   * @param node The full field node that this structure belongs to\n   * @param pathNode The path corresponding to this node in the schema\n   * @param logic The logic to apply to this field\n   * @param fieldManager The field manager for this field\n   * @param value The value signal for this field\n   * @param adapter Adapter that knows how to create new fields and appropriate state.\n   * @param createChildNode A factory function to create child nodes for this field.\n   */\n  constructor(\n    /** The full field node that corresponds to this structure. */\n    private readonly node: FieldNode,\n    pathNode: FieldPathNode,\n    logic: LogicNode,\n    override readonly fieldManager: FormFieldManager,\n    override readonly value: WritableSignal<unknown>,\n    adapter: FieldAdapter,\n    createChildNode: (options: ChildFieldNodeOptions) => FieldNode,\n  ) {\n    super(logic);\n    this.childrenMap = makeChildrenMapSignal(\n      node as ParentFieldNode,\n      value,\n      this.identitySymbol,\n      pathNode,\n      logic,\n      adapter,\n      createChildNode,\n    );\n  }\n}\n\n/** The structural component of a child `FieldNode` within a field tree. */\nexport class ChildFieldNodeStructure extends FieldNodeStructure {\n  override readonly root: FieldNode;\n  override readonly pathKeys: Signal<readonly PropertyKey[]>;\n  override readonly keyInParent: Signal<string>;\n  override readonly value: WritableSignal<unknown>;\n\n  override readonly childrenMap: Signal<Map<TrackingKey, FieldNode> | undefined>;\n\n  override get fieldManager(): FormFieldManager {\n    return this.root.structure.fieldManager;\n  }\n\n  /**\n   * Creates the structure for a child field node in a field tree.\n   *\n   * @param node The full field node that this structure belongs to\n   * @param pathNode The path corresponding to this node in the schema\n   * @param logic The logic to apply to this field\n   * @param parent The parent field node for this node\n   * @param identityInParent The identity used to track this field in its parent\n   * @param initialKeyInParent The key of this field in its parent at the time of creation\n   * @param adapter Adapter that knows how to create new fields and appropriate state.\n   * @param createChildNode A factory function to create child nodes for this field.\n   */\n  constructor(\n    node: FieldNode,\n    pathNode: FieldPathNode,\n    logic: LogicNode,\n    override readonly parent: ParentFieldNode,\n    identityInParent: TrackingKey | undefined,\n    initialKeyInParent: string,\n    adapter: FieldAdapter,\n    createChildNode: (options: ChildFieldNodeOptions) => FieldNode,\n  ) {\n    super(logic);\n\n    this.root = this.parent.structure.root;\n\n    this.pathKeys = computed(() => [...parent.structure.pathKeys(), this.keyInParent()]);\n\n    if (identityInParent === undefined) {\n      const key = initialKeyInParent;\n      this.keyInParent = computed(() => {\n        if (parent.structure.childrenMap()?.get(key as TrackingKey) !== node) {\n          throw new Error(\n            `RuntimeError: orphan field, looking for property '${key}' of ${getDebugName(parent)}`,\n          );\n        }\n        return key;\n      });\n    } else {\n      let lastKnownKey = initialKeyInParent;\n      this.keyInParent = computed(() => {\n        // TODO(alxhub): future perf optimization: here we depend on the parent's value, but most\n        // changes to the value aren't structural - they aren't moving around objects and thus\n        // shouldn't affect `keyInParent`. We currently mitigate this issue via `lastKnownKey`\n        // which avoids a search.\n        const parentValue = parent.structure.value();\n        if (!isArray(parentValue)) {\n          // It should not be possible to encounter this error. It would require the parent to\n          // change from an array field to non-array field. However, in the current implementation\n          // a field's parent can never change.\n          throw new Error(\n            `RuntimeError: orphan field, expected ${getDebugName(parent)} to be an array`,\n          );\n        }\n\n        // Check the parent value at the last known key to avoid a scan.\n        // Note: lastKnownKey is a string, but we pretend to typescript like its a number,\n        // since accessing someArray['1'] is the same as accessing someArray[1]\n        const data = parentValue[lastKnownKey as unknown as number];\n        if (\n          isObject(data) &&\n          data.hasOwnProperty(parent.structure.identitySymbol) &&\n          data[parent.structure.identitySymbol] === identityInParent\n        ) {\n          return lastKnownKey;\n        }\n\n        // Otherwise, we need to check all the keys in the parent.\n        for (let i = 0; i < parentValue.length; i++) {\n          const data = parentValue[i];\n          if (\n            isObject(data) &&\n            data.hasOwnProperty(parent.structure.identitySymbol) &&\n            data[parent.structure.identitySymbol] === identityInParent\n          ) {\n            return (lastKnownKey = i.toString());\n          }\n        }\n\n        throw new Error(\n          `RuntimeError: orphan field, can't find element in array ${getDebugName(parent)}`,\n        );\n      });\n    }\n\n    this.value = deepSignal(this.parent.structure.value, this.keyInParent);\n    this.childrenMap = makeChildrenMapSignal(\n      node as ParentFieldNode,\n      this.value,\n      this.identitySymbol,\n      pathNode,\n      logic,\n      adapter,\n      createChildNode,\n    );\n\n    this.fieldManager.structures.add(this);\n  }\n}\n\n/** Global id used for tracking keys. */\nlet globalId = 0;\n\n/** Options passed when constructing a root field node. */\nexport interface RootFieldNodeOptions {\n  /** Kind of node, used to differentiate root node options from child node options. */\n  readonly kind: 'root';\n  /** The path node corresponding to this field in the schema. */\n  readonly pathNode: FieldPathNode;\n  /** The logic to apply to this field. */\n  readonly logic: LogicNode;\n  /** The value signal for this field. */\n  readonly value: WritableSignal<unknown>;\n  /** The field manager for this field. */\n  readonly fieldManager: FormFieldManager;\n  /** This allows for more granular field and state management, and is currently used for compat. */\n  readonly fieldAdapter: FieldAdapter;\n}\n\n/** Options passed when constructing a child field node. */\nexport interface ChildFieldNodeOptions {\n  /** Kind of node, used to differentiate root node options from child node options. */\n  readonly kind: 'child';\n  /** The parent field node of this field. */\n  readonly parent: ParentFieldNode;\n  /** The path node corresponding to this field in the schema. */\n  readonly pathNode: FieldPathNode;\n  /** The logic to apply to this field. */\n  readonly logic: LogicNode;\n  /** The key of this field in its parent at the time of creation. */\n  readonly initialKeyInParent: string;\n  /** The identity used to track this field in its parent. */\n  readonly identityInParent: TrackingKey | undefined;\n  /** This allows for more granular field and state management, and is currently used for compat. */\n  readonly fieldAdapter: FieldAdapter;\n}\n\n/** Options passed when constructing a field node. */\nexport type FieldNodeOptions = RootFieldNodeOptions | ChildFieldNodeOptions;\n\n/** A signal representing an empty list of path keys, used for root fields. */\nconst ROOT_PATH_KEYS = computed<readonly PropertyKey[]>(() => []);\n\n/**\n * A signal representing a non-existent key of the field in its parent, used for root fields which\n * do not have a parent. This signal will throw if it is read.\n */\nconst ROOT_KEY_IN_PARENT = computed(() => {\n  throw new Error(`RuntimeError: the top-level field in the form has no parent`);\n});\n\n/**\n * Creates a linked signal map of all child fields for a field.\n *\n * @param node The field to create the children map signal for.\n * @param valueSignal The value signal for the field.\n * @param identitySymbol The key used to access the tracking id of a field.\n * @param pathNode The path node corresponding to the field in the schema.\n * @param logic The logic to apply to the field.\n * @param adapter Adapter that knows how to create new fields and appropriate state.\n * @param createChildNode A factory function to create child nodes for this field.\n * @returns\n */\nfunction makeChildrenMapSignal(\n  node: FieldNode,\n  valueSignal: WritableSignal<unknown>,\n  identitySymbol: symbol,\n  pathNode: FieldPathNode,\n  logic: LogicNode,\n  adapter: FieldAdapter,\n  createChildNode: (options: ChildFieldNodeOptions) => FieldNode,\n): Signal<Map<TrackingKey, FieldNode> | undefined> {\n  // We use a `linkedSignal` to preserve the instances of `FieldNode` for each child field even if\n  // the value of this field changes its object identity. The computation creates or updates the map\n  // of child `FieldNode`s for `node` based on its current value.\n  return linkedSignal<unknown, Map<TrackingKey, FieldNode> | undefined>({\n    source: valueSignal,\n    computation: (value, previous): Map<TrackingKey, FieldNode> | undefined => {\n      // We may or may not have a previous map. If there isn't one, then `childrenMap` will be lazily\n      // initialized to a new map instance if needed.\n      let childrenMap = previous?.value;\n\n      if (!isObject(value)) {\n        // Non-object values have no children.\n        return undefined;\n      }\n      const isValueArray = isArray(value);\n\n      // Remove fields that have disappeared since the last time this map was computed.\n      if (childrenMap !== undefined) {\n        let oldKeys: Set<TrackingKey> | undefined = undefined;\n        if (isValueArray) {\n          oldKeys = new Set(childrenMap.keys());\n          for (let i = 0; i < value.length; i++) {\n            const childValue = value[i] as unknown;\n            if (isObject(childValue) && childValue.hasOwnProperty(identitySymbol)) {\n              oldKeys.delete(childValue[identitySymbol] as TrackingKey);\n            } else {\n              oldKeys.delete(i.toString() as TrackingKey);\n            }\n          }\n\n          for (const key of oldKeys) {\n            childrenMap.delete(key);\n          }\n        } else {\n          for (let key of childrenMap.keys()) {\n            if (!value.hasOwnProperty(key)) {\n              childrenMap.delete(key);\n            }\n          }\n        }\n      }\n\n      // Add fields that exist in the value but don't yet have instances in the map.\n      for (let key of Object.keys(value)) {\n        let trackingId: TrackingKey | undefined = undefined;\n        const childValue = value[key] as unknown;\n\n        // Fields explicitly set to `undefined` are treated as if they don't exist.\n        // This ensures that `{value: undefined}` and `{}` have the same behavior for their `value`\n        // field.\n        if (childValue === undefined) {\n          // The value might have _become_ `undefined`, so we need to delete it here.\n          childrenMap?.delete(key as TrackingKey);\n          continue;\n        }\n\n        if (isValueArray && isObject(childValue)) {\n          // For object values in arrays, assign a synthetic identity instead.\n          trackingId = (childValue[identitySymbol] as TrackingKey) ??= Symbol(\n            ngDevMode ? `id:${globalId++}` : '',\n          ) as TrackingKey;\n        }\n\n        const identity = trackingId ?? (key as TrackingKey);\n\n        if (childrenMap?.has(identity)) {\n          continue;\n        }\n\n        // Determine the logic for the field that we're defining.\n        let childPath: FieldPathNode | undefined;\n        let childLogic: LogicNode;\n        if (isValueArray) {\n          // Fields for array elements have their logic defined by the `element` mechanism.\n          // TODO: other dynamic data\n          childPath = pathNode.getChild(DYNAMIC);\n          childLogic = logic.getChild(DYNAMIC);\n        } else {\n          // Fields for plain properties exist in our logic node's child map.\n          childPath = pathNode.getChild(key);\n          childLogic = logic.getChild(key);\n        }\n\n        childrenMap ??= new Map<TrackingKey, FieldNode>();\n        childrenMap.set(\n          identity,\n          createChildNode({\n            kind: 'child',\n            parent: node as ParentFieldNode,\n            pathNode: childPath,\n            logic: childLogic,\n            initialKeyInParent: key,\n            identityInParent: trackingId,\n            fieldAdapter: adapter,\n          }),\n        );\n      }\n\n      return childrenMap;\n    },\n    equal: () => false,\n  });\n}\n\n/** Gets a human readable name for a field node for use in error messages. */\nfunction getDebugName(node: FieldNode) {\n  return `<root>.${node.structure.pathKeys().join('.')}`;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, linkedSignal, Signal, signal, WritableSignal} from '@angular/core';\nimport {ValidationError} from '../api/validation_errors';\nimport type {FieldNode} from './node';\n\n/**\n * State of a `FieldNode` that's associated with form submission.\n */\nexport class FieldSubmitState {\n  /**\n   * Whether this field was directly submitted (as opposed to indirectly by a parent field being submitted)\n   * and is still in the process of submitting.\n   */\n  readonly selfSubmitting = signal<boolean>(false);\n\n  /** Server errors that are associated with this field. */\n  readonly serverErrors: WritableSignal<readonly ValidationError[]>;\n\n  constructor(private readonly node: FieldNode) {\n    this.serverErrors = linkedSignal({\n      source: this.node.structure.value,\n      computation: () => [] as readonly ValidationError[],\n    });\n  }\n\n  /**\n   * Whether this form is currently in the process of being submitted.\n   * Either because the field was submitted directly, or because a parent field was submitted.\n   */\n  readonly submitting: Signal<boolean> = computed(() => {\n    return this.selfSubmitting() || (this.node.structure.parent?.submitting() ?? false);\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {Signal, WritableSignal} from '@angular/core';\nimport type {Field} from '../api/field_directive';\nimport {\n  AggregateMetadataKey,\n  MAX,\n  MAX_LENGTH,\n  MetadataKey,\n  MIN,\n  MIN_LENGTH,\n  PATTERN,\n  REQUIRED,\n} from '../api/metadata';\nimport type {DisabledReason, FieldContext, FieldState, FieldTree} from '../api/types';\nimport type {ValidationError} from '../api/validation_errors';\nimport {LogicNode} from '../schema/logic_node';\nimport {FieldPathNode} from '../schema/path_node';\nimport {FieldNodeContext} from './context';\nimport type {FieldAdapter} from './field_adapter';\nimport type {FormFieldManager} from './manager';\nimport {FieldMetadataState} from './metadata';\nimport {FIELD_PROXY_HANDLER} from './proxy';\nimport {FieldNodeState} from './state';\nimport {\n  type ChildFieldNodeOptions,\n  ChildFieldNodeStructure,\n  type FieldNodeOptions,\n  type FieldNodeStructure,\n  RootFieldNodeStructure,\n} from './structure';\nimport {FieldSubmitState} from './submit';\nimport {ValidationState} from './validation';\n/**\n * Internal node in the form tree for a given field.\n *\n * Field nodes have several responsibilities:\n *  - They track instance state for the particular field (touched)\n *  - They compute signals for derived state (valid, disabled, etc) based on their associated\n *    `LogicNode`\n *  - They act as the public API for the field (they implement the `FieldState` interface)\n *  - They implement navigation of the form tree via `.parent` and `.getChild()`.\n *\n * This class is largely a wrapper that aggregates several smaller pieces that each manage a subset of\n * the responsibilities.\n */\nexport class FieldNode implements FieldState<unknown> {\n  readonly structure: FieldNodeStructure;\n  readonly validationState: ValidationState;\n  readonly metadataState: FieldMetadataState;\n  readonly nodeState: FieldNodeState;\n  readonly submitState: FieldSubmitState;\n\n  private _context: FieldContext<unknown> | undefined = undefined;\n  readonly fieldAdapter: FieldAdapter;\n\n  get context(): FieldContext<unknown> {\n    return (this._context ??= new FieldNodeContext(this));\n  }\n\n  /**\n   * Proxy to this node which allows navigation of the form graph below it.\n   */\n  readonly fieldProxy = new Proxy(() => this, FIELD_PROXY_HANDLER) as unknown as FieldTree<any>;\n\n  constructor(options: FieldNodeOptions) {\n    this.fieldAdapter = options.fieldAdapter;\n    this.structure = this.fieldAdapter.createStructure(this, options);\n    this.validationState = this.fieldAdapter.createValidationState(this, options);\n    this.nodeState = this.fieldAdapter.createNodeState(this, options);\n    this.metadataState = new FieldMetadataState(this);\n    this.submitState = new FieldSubmitState(this);\n  }\n\n  get logicNode(): LogicNode {\n    return this.structure.logic;\n  }\n\n  get value(): WritableSignal<unknown> {\n    return this.structure.value;\n  }\n\n  get keyInParent(): Signal<string | number> {\n    return this.structure.keyInParent;\n  }\n\n  get errors(): Signal<ValidationError[]> {\n    return this.validationState.errors;\n  }\n\n  get errorSummary(): Signal<ValidationError[]> {\n    return this.validationState.errorSummary;\n  }\n\n  get pending(): Signal<boolean> {\n    return this.validationState.pending;\n  }\n\n  get valid(): Signal<boolean> {\n    return this.validationState.valid;\n  }\n\n  get invalid(): Signal<boolean> {\n    return this.validationState.invalid;\n  }\n\n  get dirty(): Signal<boolean> {\n    return this.nodeState.dirty;\n  }\n\n  get touched(): Signal<boolean> {\n    return this.nodeState.touched;\n  }\n\n  get disabled(): Signal<boolean> {\n    return this.nodeState.disabled;\n  }\n\n  get disabledReasons(): Signal<readonly DisabledReason[]> {\n    return this.nodeState.disabledReasons;\n  }\n\n  get hidden(): Signal<boolean> {\n    return this.nodeState.hidden;\n  }\n\n  get readonly(): Signal<boolean> {\n    return this.nodeState.readonly;\n  }\n\n  get fieldBindings(): Signal<readonly Field<unknown>[]> {\n    return this.nodeState.fieldBindings;\n  }\n\n  get submitting(): Signal<boolean> {\n    return this.submitState.submitting;\n  }\n\n  get name(): Signal<string> {\n    return this.nodeState.name;\n  }\n\n  private metadataOrUndefined<M>(key: AggregateMetadataKey<M, any>): Signal<M> | undefined {\n    return this.hasMetadata(key) ? this.metadata(key) : undefined;\n  }\n\n  get max(): Signal<number | undefined> | undefined {\n    return this.metadataOrUndefined(MAX);\n  }\n\n  get maxLength(): Signal<number | undefined> | undefined {\n    return this.metadataOrUndefined(MAX_LENGTH);\n  }\n\n  get min(): Signal<number | undefined> | undefined {\n    return this.metadataOrUndefined(MIN);\n  }\n\n  get minLength(): Signal<number | undefined> | undefined {\n    return this.metadataOrUndefined(MIN_LENGTH);\n  }\n\n  get pattern(): Signal<readonly RegExp[]> | undefined {\n    return this.metadataOrUndefined(PATTERN);\n  }\n\n  get required(): Signal<boolean> | undefined {\n    return this.metadataOrUndefined(REQUIRED);\n  }\n\n  metadata<M>(key: AggregateMetadataKey<M, any>): Signal<M>;\n  metadata<M>(key: MetadataKey<M>): M | undefined;\n  metadata<M>(key: MetadataKey<M> | AggregateMetadataKey<M, any>): Signal<M> | M | undefined {\n    return this.metadataState.get(key);\n  }\n  hasMetadata(key: MetadataKey<any> | AggregateMetadataKey<any, any>): boolean {\n    return this.metadataState.has(key);\n  }\n\n  /**\n   * Marks this specific field as touched.\n   */\n  markAsTouched(): void {\n    this.nodeState.markAsTouched();\n  }\n\n  /**\n   * Marks this specific field as dirty.\n   */\n  markAsDirty(): void {\n    this.nodeState.markAsDirty();\n  }\n\n  /**\n   * Resets the {@link touched} and {@link dirty} state of the field and its descendants.\n   *\n   * Note this does not change the data model, which can be reset directly if desired.\n   */\n  reset(): void {\n    this.nodeState.markAsUntouched();\n    this.nodeState.markAsPristine();\n\n    for (const child of this.structure.children()) {\n      child.reset();\n    }\n  }\n\n  /**\n   * Creates a new root field node for a new form.\n   */\n  static newRoot<T>(\n    fieldManager: FormFieldManager,\n    value: WritableSignal<T>,\n    pathNode: FieldPathNode,\n    adapter: FieldAdapter,\n  ): FieldNode {\n    return adapter.newRoot(fieldManager, value, pathNode, adapter);\n  }\n\n  /**\n   * Creates a child field node based on the given options.\n   */\n  private static newChild(options: ChildFieldNodeOptions): FieldNode {\n    return options.fieldAdapter.newChild(options);\n  }\n\n  createStructure(options: FieldNodeOptions) {\n    return options.kind === 'root'\n      ? new RootFieldNodeStructure(\n          this,\n          options.pathNode,\n          options.logic,\n          options.fieldManager,\n          options.value,\n          options.fieldAdapter,\n          FieldNode.newChild,\n        )\n      : new ChildFieldNodeStructure(\n          this,\n          options.pathNode,\n          options.logic,\n          options.parent,\n          options.identityInParent,\n          options.initialKeyInParent,\n          options.fieldAdapter,\n          FieldNode.newChild,\n        );\n  }\n}\n\n/**\n * Field node of a field that has children.\n * This simplifies and makes certain types cleaner.\n */\nexport interface ParentFieldNode extends FieldNode {\n  readonly value: WritableSignal<Record<string, unknown>>;\n  readonly structure: FieldNodeStructure & {value: WritableSignal<Record<string, unknown>>};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal, Signal} from '@angular/core';\nimport type {Field} from '../api/field_directive';\nimport type {DisabledReason} from '../api/types';\nimport type {FieldNode} from './node';\nimport {reduceChildren, shortCircuitTrue} from './util';\n\n/**\n * The non-validation and non-submit state associated with a `FieldNode`, such as touched and dirty\n * status, as well as derived logical state.\n */\nexport class FieldNodeState {\n  /**\n   * Indicates whether this field has been touched directly by the user (as opposed to indirectly by\n   * touching a child field).\n   *\n   * A field is considered directly touched when a user stops editing it for the first time (i.e. on blur)\n   */\n  private readonly selfTouched = signal(false);\n\n  /**\n   * Indicates whether this field has been dirtied directly by the user (as opposed to indirectly by\n   * dirtying a child field).\n   *\n   * A field is considered directly dirtied if a user changed the value of the field at least once.\n   */\n  private readonly selfDirty = signal(false);\n\n  /**\n   * Marks this specific field as touched.\n   */\n  markAsTouched(): void {\n    this.selfTouched.set(true);\n  }\n\n  /**\n   * Marks this specific field as dirty.\n   */\n  markAsDirty(): void {\n    this.selfDirty.set(true);\n  }\n\n  /**\n   * Marks this specific field as not dirty.\n   */\n  markAsPristine(): void {\n    this.selfDirty.set(false);\n  }\n\n  /**\n   * Marks this specific field as not touched.\n   */\n  markAsUntouched(): void {\n    this.selfTouched.set(false);\n  }\n\n  /** The {@link Field} directives that bind this field to a UI control. */\n  readonly fieldBindings = signal<readonly Field<unknown>[]>([]);\n\n  constructor(private readonly node: FieldNode) {}\n\n  /**\n   * Whether this field is considered dirty.\n   *\n   * A field is considered dirty if one of the following is true:\n   *  - It was directly dirtied and is interactive\n   *  - One of its children is considered dirty\n   */\n  readonly dirty: Signal<boolean> = computed(() => {\n    const selfDirtyValue = this.selfDirty() && !this.isNonInteractive();\n    return reduceChildren(\n      this.node,\n      selfDirtyValue,\n      (child, value) => value || child.nodeState.dirty(),\n      shortCircuitTrue,\n    );\n  });\n\n  /**\n   * Whether this field is considered touched.\n   *\n   * A field is considered touched if one of the following is true:\n   *  - It was directly touched and is interactive\n   *  - One of its children is considered touched\n   */\n  readonly touched: Signal<boolean> = computed(() => {\n    const selfTouchedValue = this.selfTouched() && !this.isNonInteractive();\n    return reduceChildren(\n      this.node,\n      selfTouchedValue,\n      (child, value) => value || child.nodeState.touched(),\n      shortCircuitTrue,\n    );\n  });\n\n  /**\n   * The reasons for this field's disablement. This includes disabled reasons for any parent field\n   * that may have been disabled, indirectly causing this field to be disabled as well.\n   * The `field` property of the `DisabledReason` can be used to determine which field ultimately\n   * caused the disablement.\n   */\n  readonly disabledReasons: Signal<readonly DisabledReason[]> = computed(() => [\n    ...(this.node.structure.parent?.nodeState.disabledReasons() ?? []),\n    ...this.node.logicNode.logic.disabledReasons.compute(this.node.context),\n  ]);\n\n  /**\n   * Whether this field is considered disabled.\n   *\n   * A field is considered disabled if one of the following is true:\n   * - The schema contains logic that directly disabled it\n   * - Its parent field is considered disabled\n   */\n  readonly disabled: Signal<boolean> = computed(() => !!this.disabledReasons().length);\n\n  /**\n   * Whether this field is considered readonly.\n   *\n   * A field is considered readonly if one of the following is true:\n   * - The schema contains logic that directly made it readonly\n   * - Its parent field is considered readonly\n   */\n  readonly readonly: Signal<boolean> = computed(\n    () =>\n      (this.node.structure.parent?.nodeState.readonly() ||\n        this.node.logicNode.logic.readonly.compute(this.node.context)) ??\n      false,\n  );\n\n  /**\n   * Whether this field is considered hidden.\n   *\n   * A field is considered hidden if one of the following is true:\n   * - The schema contains logic that directly hides it\n   * - Its parent field is considered hidden\n   */\n  readonly hidden: Signal<boolean> = computed(\n    () =>\n      (this.node.structure.parent?.nodeState.hidden() ||\n        this.node.logicNode.logic.hidden.compute(this.node.context)) ??\n      false,\n  );\n\n  readonly name: Signal<string> = computed(() => {\n    const parent = this.node.structure.parent;\n    if (!parent) {\n      return this.node.structure.fieldManager.rootName;\n    }\n\n    return `${parent.name()}.${this.node.structure.keyInParent()}`;\n  });\n\n  /** Whether this field is considered non-interactive.\n   *\n   * A field is considered non-interactive if one of the following is true:\n   * - It is hidden\n   * - It is disabled\n   * - It is readonly\n   */\n  private readonly isNonInteractive = computed(\n    () => this.hidden() || this.disabled() || this.readonly(),\n  );\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {FieldPathNode} from '../schema/path_node';\n\nimport {FormFieldManager} from './manager';\nimport {FieldNode} from './node';\nimport {FieldNodeState} from './state';\nimport {ChildFieldNodeOptions, FieldNodeOptions, FieldNodeStructure} from './structure';\nimport {ValidationState, FieldValidationState} from './validation';\nimport {WritableSignal} from '@angular/core';\n\n/**\n * Adapter allowing customization of the creation logic for a field and its associated\n * structure and state.\n */\nexport interface FieldAdapter {\n  /**\n   * Creates a node structure.\n   * @param node\n   * @param options\n   */\n  createStructure(node: FieldNode, options: FieldNodeOptions): FieldNodeStructure;\n\n  /**\n   * Creates node validation state\n   * @param param\n   * @param options\n   */\n  createValidationState(param: FieldNode, options: FieldNodeOptions): ValidationState;\n\n  /**\n   * Creates node state.\n   * @param param\n   * @param options\n   */\n  createNodeState(param: FieldNode, options: FieldNodeOptions): FieldNodeState;\n\n  /**\n   * Creates a custom child node.\n   * @param options\n   */\n  newChild(options: ChildFieldNodeOptions): FieldNode;\n\n  /**\n   * Creates a custom root node.\n   * @param fieldManager\n   * @param model\n   * @param pathNode\n   * @param adapter\n   */\n  newRoot<TValue>(\n    fieldManager: FormFieldManager,\n    model: WritableSignal<TValue>,\n    pathNode: FieldPathNode,\n    adapter: FieldAdapter,\n  ): FieldNode;\n}\n\n/**\n * Basic adapter supporting standard form behavior.\n */\nexport class BasicFieldAdapter implements FieldAdapter {\n  /**\n   * Creates a new Root field node.\n   * @param fieldManager\n   * @param value\n   * @param pathNode\n   * @param adapter\n   */\n  newRoot<TValue>(\n    fieldManager: FormFieldManager,\n    value: WritableSignal<TValue>,\n    pathNode: FieldPathNode,\n    adapter: FieldAdapter,\n  ): FieldNode {\n    return new FieldNode({\n      kind: 'root',\n      fieldManager,\n      value,\n      pathNode,\n      logic: pathNode.logic.build(),\n      fieldAdapter: adapter,\n    });\n  }\n\n  /**\n   * Creates a new child field node.\n   * @param options\n   */\n  newChild(options: ChildFieldNodeOptions): FieldNode {\n    return new FieldNode(options);\n  }\n\n  /**\n   * Creates a node state.\n   * @param node\n   */\n  createNodeState(node: FieldNode): FieldNodeState {\n    return new FieldNodeState(node);\n  }\n\n  /**\n   * Creates a validation state.\n   * @param node\n   */\n  createValidationState(node: FieldNode): ValidationState {\n    return new FieldValidationState(node);\n  }\n\n  /**\n   * Creates a node structure.\n   * @param node\n   * @param options\n   */\n  createStructure(node: FieldNode, options: FieldNodeOptions): FieldNodeStructure {\n    return node.createStructure(options);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {APP_ID, effect, inject, Injector, untracked} from '@angular/core';\nimport type {FieldNodeStructure} from './structure';\n\n/**\n * Manages the collection of fields associated with a given `form`.\n *\n * Fields are created implicitly, through reactivity, and may create \"owned\" entities like effects\n * or resources. When a field is no longer connected to the form, these owned entities should be\n * destroyed, which is the job of the `FormFieldManager`.\n */\nexport class FormFieldManager {\n  readonly rootName: string;\n  constructor(\n    readonly injector: Injector,\n    rootName: string | undefined,\n  ) {\n    this.rootName = rootName ?? `${this.injector.get(APP_ID)}.form${nextFormId++}`;\n  }\n\n  /**\n   * Contains all child field structures that have been created as part of the current form.\n   * New child structures are automatically added when they are created.\n   * Structures are destroyed and removed when they are no longer reachable from the root.\n   */\n  readonly structures = new Set<FieldNodeStructure>();\n\n  /**\n   * Creates an effect that runs when the form's structure changes and checks for structures that\n   * have become unreachable to clean up.\n   *\n   * For example, consider a form wrapped around the following model: `signal([0, 1, 2])`.\n   * This form would have 4 nodes as part of its structure tree.\n   * One structure for the root array, and one structure for each element of the array.\n   * Now imagine the data is updated: `model.set([0])`. In this case the structure for the first\n   * element can still be reached from the root, but the structures for the second and third\n   * elements are now orphaned and not connected to the root. Thus they will be destroyed.\n   *\n   * @param root The root field structure.\n   */\n  createFieldManagementEffect(root: FieldNodeStructure): void {\n    effect(\n      () => {\n        const liveStructures = new Set<FieldNodeStructure>();\n        this.markStructuresLive(root, liveStructures);\n\n        // Destroy all nodes that are no longer live.\n        for (const structure of this.structures) {\n          if (!liveStructures.has(structure)) {\n            this.structures.delete(structure);\n            untracked(() => structure.destroy());\n          }\n        }\n      },\n      {injector: this.injector},\n    );\n  }\n\n  /**\n   * Collects all structures reachable from the given structure into the given set.\n   *\n   * @param structure The root structure\n   * @param liveStructures The set of reachable structures to populate\n   */\n  private markStructuresLive(\n    structure: FieldNodeStructure,\n    liveStructures: Set<FieldNodeStructure>,\n  ): void {\n    liveStructures.add(structure);\n    for (const child of structure.children()) {\n      this.markStructuresLive(child.structure, liveStructures);\n    }\n  }\n}\n\nlet nextFormId = 0;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {inject, Injector, runInInjectionContext, WritableSignal} from '@angular/core';\n\nimport {BasicFieldAdapter, FieldAdapter} from '../field/field_adapter';\nimport {FormFieldManager} from '../field/manager';\nimport {FieldNode} from '../field/node';\nimport {addDefaultField} from '../field/validation';\nimport {FieldPathNode} from '../schema/path_node';\nimport {assertPathIsCurrent, isSchemaOrSchemaFn, SchemaImpl} from '../schema/schema';\nimport {isArray} from '../util/type_guards';\nimport type {\n  FieldPath,\n  FieldTree,\n  LogicFn,\n  OneOrMany,\n  PathKind,\n  Schema,\n  SchemaFn,\n  SchemaOrSchemaFn,\n  TreeValidationResult,\n} from './types';\nimport {ValidationError, WithOptionalField} from './validation_errors';\n\n/**\n * Options that may be specified when creating a form.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport interface FormOptions {\n  /**\n   * The injector to use for dependency injection. If this is not provided, the injector for the\n   * current [injection context](guide/di/dependency-injection-context), will be used.\n   */\n  injector?: Injector;\n  name?: string;\n\n  /**\n   * Adapter allows managing fields in a more flexible way.\n   * Currently this is used to support interop with reactive forms.\n   */\n  adapter?: FieldAdapter;\n}\n\n/** Extracts the model, schema, and options from the arguments passed to `form()`. */\nfunction normalizeFormArgs<TValue>(\n  args: any[],\n): [WritableSignal<TValue>, SchemaOrSchemaFn<TValue> | undefined, FormOptions | undefined] {\n  let model: WritableSignal<TValue>;\n  let schema: SchemaOrSchemaFn<TValue> | undefined;\n  let options: FormOptions | undefined;\n\n  if (args.length === 3) {\n    [model, schema, options] = args;\n  } else if (args.length === 2) {\n    if (isSchemaOrSchemaFn(args[1])) {\n      [model, schema] = args;\n    } else {\n      [model, options] = args;\n    }\n  } else {\n    [model] = args;\n  }\n\n  return [model, schema, options];\n}\n\n/**\n * Creates a form wrapped around the given model data. A form is represented as simply a `FieldTree`\n * of the model data.\n *\n * `form` uses the given model as the source of truth and *does not* maintain its own copy of the\n * data. This means that updating the value on a `FieldState` updates the originally passed in model\n * as well.\n *\n * @example\n * ```\n * const nameModel = signal({first: '', last: ''});\n * const nameForm = form(nameModel);\n * nameForm.first().value.set('John');\n * nameForm().value(); // {first: 'John', last: ''}\n * nameModel(); // {first: 'John', last: ''}\n * ```\n *\n * @param model A writable signal that contains the model data for the form. The resulting field\n * structure will match the shape of the model and any changes to the form data will be written to\n * the model.\n * @return A `FieldTree` representing a form around the data model.\n * @template TValue The type of the data model.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function form<TValue>(model: WritableSignal<TValue>): FieldTree<TValue>;\n\n/**\n * Creates a form wrapped around the given model data. A form is represented as simply a `FieldTree`\n * of the model data.\n *\n * `form` uses the given model as the source of truth and *does not* maintain its own copy of the\n * data. This means that updating the value on a `FieldState` updates the originally passed in model\n * as well.\n *\n * @example\n * ```\n * const nameModel = signal({first: '', last: ''});\n * const nameForm = form(nameModel);\n * nameForm.first().value.set('John');\n * nameForm().value(); // {first: 'John', last: ''}\n * nameModel(); // {first: 'John', last: ''}\n * ```\n *\n * The form can also be created with a schema, which is a set of rules that define the logic for the\n * form. The schema can be either a pre-defined schema created with the `schema` function, or a\n * function that builds the schema by binding logic to a parts of the field structure.\n *\n * @example\n * ```\n * const nameForm = form(signal({first: '', last: ''}), (name) => {\n *   required(name.first);\n *   pattern(name.last, /^[a-z]+$/i, {message: 'Alphabet characters only'});\n * });\n * nameForm().valid(); // false\n * nameForm().value.set({first: 'John', last: 'Doe'});\n * nameForm().valid(); // true\n * ```\n *\n * @param model A writable signal that contains the model data for the form. The resulting field\n * structure will match the shape of the model and any changes to the form data will be written to\n * the model.\n * @param schemaOrOptions The second argument can be either\n *   1. A schema or a function used to specify logic for the form (e.g. validation, disabled fields, etc.).\n *      When passing a schema, the form options can be passed as a third argument if needed.\n *   2. The form options\n * @return A `FieldTree` representing a form around the data model\n * @template TValue The type of the data model.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function form<TValue>(\n  model: WritableSignal<TValue>,\n  schemaOrOptions: SchemaOrSchemaFn<TValue> | FormOptions,\n): FieldTree<TValue>;\n\n/**\n * Creates a form wrapped around the given model data. A form is represented as simply a `FieldTree`\n * of the model data.\n *\n * `form` uses the given model as the source of truth and *does not* maintain its own copy of the\n * data. This means that updating the value on a `FieldState` updates the originally passed in model\n * as well.\n *\n * @example\n * ```\n * const nameModel = signal({first: '', last: ''});\n * const nameForm = form(nameModel);\n * nameForm.first().value.set('John');\n * nameForm().value(); // {first: 'John', last: ''}\n * nameModel(); // {first: 'John', last: ''}\n * ```\n *\n * The form can also be created with a schema, which is a set of rules that define the logic for the\n * form. The schema can be either a pre-defined schema created with the `schema` function, or a\n * function that builds the schema by binding logic to a parts of the field structure.\n *\n * @example\n * ```\n * const nameForm = form(signal({first: '', last: ''}), (name) => {\n *   required(name.first);\n *   error(name.last, ({value}) => !/^[a-z]+$/i.test(value()), 'Alphabet characters only');\n * });\n * nameForm().valid(); // false\n * nameForm().value.set({first: 'John', last: 'Doe'});\n * nameForm().valid(); // true\n * ```\n *\n * @param model A writable signal that contains the model data for the form. The resulting field\n * structure will match the shape of the model and any changes to the form data will be written to\n * the model.\n * @param schema A schema or a function used to specify logic for the form (e.g. validation, disabled fields, etc.)\n * @param options The form options\n * @return A `FieldTree` representing a form around the data model.\n * @template TValue The type of the data model.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function form<TValue>(\n  model: WritableSignal<TValue>,\n  schema: SchemaOrSchemaFn<TValue>,\n  options: FormOptions,\n): FieldTree<TValue>;\n\nexport function form<TValue>(...args: any[]): FieldTree<TValue> {\n  const [model, schema, options] = normalizeFormArgs<TValue>(args);\n  const injector = options?.injector ?? inject(Injector);\n  const pathNode = runInInjectionContext(injector, () => SchemaImpl.rootCompile(schema));\n  const fieldManager = new FormFieldManager(injector, options?.name);\n  const adapter = options?.adapter ?? new BasicFieldAdapter();\n  const fieldRoot = FieldNode.newRoot(fieldManager, model, pathNode, adapter);\n  fieldManager.createFieldManagementEffect(fieldRoot.structure);\n\n  return fieldRoot.fieldProxy as FieldTree<TValue>;\n}\n\n/**\n * Applies a schema to each item of an array.\n *\n * @example\n * ```\n * const nameSchema = schema<{first: string, last: string}>((name) => {\n *   required(name.first);\n *   required(name.last);\n * });\n * const namesForm = form(signal([{first: '', last: ''}]), (names) => {\n *   applyEach(names, nameSchema);\n * });\n * ```\n *\n * When binding logic to the array items, the `FieldTree` for the array item is passed as an\n * additional argument. This can be used to reference other properties on the item.\n *\n * @example\n * ```\n * const namesForm = form(signal([{first: '', last: ''}]), (names) => {\n *   applyEach(names, (name) => {\n *     error(\n *       name.last,\n *       (value, nameField) => value === nameField.first().value(),\n *       'Last name must be different than first name',\n *     );\n *   });\n * });\n * ```\n *\n * @param path The target path for an array field whose items the schema will be applied to.\n * @param schema A schema for an element of the array, or function that binds logic to an\n * element of the array.\n * @template TValue The data type of the item field to apply the schema to.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function applyEach<TValue>(\n  path: FieldPath<TValue[]>,\n  schema: NoInfer<SchemaOrSchemaFn<TValue, PathKind.Item>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const elementPath = FieldPathNode.unwrapFieldPath(path).element.fieldPathProxy;\n  apply(elementPath, schema as Schema<TValue>);\n}\n\n/**\n * Applies a predefined schema to a given `FieldPath`.\n *\n * @example\n * ```\n * const nameSchema = schema<{first: string, last: string}>((name) => {\n *   required(name.first);\n *   required(name.last);\n * });\n * const profileForm = form(signal({name: {first: '', last: ''}, age: 0}), (profile) => {\n *   apply(profile.name, nameSchema);\n * });\n * ```\n *\n * @param path The target path to apply the schema to.\n * @param schema The schema to apply to the property\n * @template TValue The data type of the field to apply the schema to.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function apply<TValue>(\n  path: FieldPath<TValue>,\n  schema: NoInfer<SchemaOrSchemaFn<TValue>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.mergeIn(SchemaImpl.create(schema));\n}\n\n/**\n * Conditionally applies a predefined schema to a given `FieldPath`.\n *\n * @param path The target path to apply the schema to.\n * @param logic A `LogicFn<T, boolean>` that returns `true` when the schema should be applied.\n * @param schema The schema to apply to the field when the `logic` function returns `true`.\n * @template TValue The data type of the field to apply the schema to.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function applyWhen<TValue>(\n  path: FieldPath<TValue>,\n  logic: LogicFn<TValue, boolean>,\n  schema: NoInfer<SchemaOrSchemaFn<TValue>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.mergeIn(SchemaImpl.create(schema), {fn: logic, path});\n}\n\n/**\n * Conditionally applies a predefined schema to a given `FieldPath`.\n *\n * @param path The target path to apply the schema to.\n * @param predicate A type guard that accepts a value `T` and returns `true` if `T` is of type\n *   `TNarrowed`.\n * @param schema The schema to apply to the field when `predicate` returns `true`.\n * @template TValue The data type of the field to apply the schema to.\n * @template TNarrowed The data type of the schema (a narrowed type of TValue).\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function applyWhenValue<TValue, TNarrowed extends TValue>(\n  path: FieldPath<TValue>,\n  predicate: (value: TValue) => value is TNarrowed,\n  schema: SchemaOrSchemaFn<TNarrowed>,\n): void;\n\n/**\n * Conditionally applies a predefined schema to a given `FieldPath`.\n *\n * @param path The target path to apply the schema to.\n * @param predicate A function that accepts a value `T` and returns `true` when the schema\n *   should be applied.\n * @param schema The schema to apply to the field when `predicate` returns `true`.\n * @template TValue The data type of the field to apply the schema to.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function applyWhenValue<TValue>(\n  path: FieldPath<TValue>,\n  predicate: (value: TValue) => boolean,\n  schema: NoInfer<SchemaOrSchemaFn<TValue>>,\n): void;\n\nexport function applyWhenValue(\n  path: FieldPath<unknown>,\n  predicate: (value: unknown) => boolean,\n  schema: SchemaOrSchemaFn<unknown>,\n) {\n  applyWhen(path, ({value}) => predicate(value()), schema);\n}\n\n/**\n * Submits a given `FieldTree` using the given action function and applies any server errors\n * resulting from the action to the field. Server errors returned by the `action` will be integrated\n * into the field as a `ValidationError` on the sub-field indicated by the `field` property of the\n * server error.\n *\n * @example\n * ```\n * async function registerNewUser(registrationForm: FieldTree<{username: string, password: string}>) {\n *   const result = await myClient.registerNewUser(registrationForm().value());\n *   if (result.errorCode === myClient.ErrorCode.USERNAME_TAKEN) {\n *     return [{\n *       field: registrationForm.username,\n *       error: {kind: 'server', message: 'Username already taken'}\n *     }];\n *   }\n *   return undefined;\n * }\n *\n * const registrationForm = form(signal({username: 'god', password: ''}));\n * submit(registrationForm, async (f) => {\n *   return registerNewUser(registrationForm);\n * });\n * registrationForm.username().errors(); // [{kind: 'server', message: 'Username already taken'}]\n * ```\n *\n * @param form The field to submit.\n * @param action An asynchronous action used to submit the field. The action may return server\n * errors.\n * @template TValue The data type of the field being submitted.\n *\n * @category submission\n * @experimental 21.0.0\n */\nexport async function submit<TValue>(\n  form: FieldTree<TValue>,\n  action: (form: FieldTree<TValue>) => Promise<TreeValidationResult>,\n) {\n  const node = form() as FieldNode;\n  markAllAsTouched(node);\n\n  // Fail fast if the form is already invalid.\n  if (node.invalid()) {\n    return;\n  }\n\n  node.submitState.selfSubmitting.set(true);\n  try {\n    const errors = await action(form);\n    errors && setServerErrors(node, errors);\n  } finally {\n    node.submitState.selfSubmitting.set(false);\n  }\n}\n\n/**\n * Sets a list of server errors to their individual fields.\n *\n * @param submittedField The field that was submitted, resulting in the errors.\n * @param errors The errors to set.\n */\nfunction setServerErrors(\n  submittedField: FieldNode,\n  errors: OneOrMany<WithOptionalField<ValidationError>>,\n) {\n  if (!isArray(errors)) {\n    errors = [errors];\n  }\n  const errorsByField = new Map<FieldNode, ValidationError[]>();\n  for (const error of errors) {\n    const errorWithField = addDefaultField(error, submittedField.fieldProxy);\n    const field = errorWithField.field() as FieldNode;\n    let fieldErrors = errorsByField.get(field);\n    if (!fieldErrors) {\n      fieldErrors = [];\n      errorsByField.set(field, fieldErrors);\n    }\n    fieldErrors.push(errorWithField);\n  }\n  for (const [field, fieldErrors] of errorsByField) {\n    field.submitState.serverErrors.set(fieldErrors);\n  }\n}\n\n/**\n * Creates a `Schema` that adds logic rules to a form.\n * @param fn A **non-reactive** function that sets up reactive logic rules for the form.\n * @returns A schema object that implements the given logic.\n * @template TValue The value type of a `FieldTree` that this schema binds to.\n *\n * @category structure\n * @experimental 21.0.0\n */\nexport function schema<TValue>(fn: SchemaFn<TValue>): Schema<TValue> {\n  return SchemaImpl.create(fn) as unknown as Schema<TValue>;\n}\n\n/** Marks a {@link node} and its descendants as touched. */\nfunction markAllAsTouched(node: FieldNode) {\n  node.markAsTouched();\n  for (const child of node.structure.children()) {\n    markAllAsTouched(child);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {StandardSchemaV1} from '@standard-schema/spec';\nimport {FieldTree} from './types';\n\n/**\n * Options used to create a `ValidationError`.\n */\ninterface ValidationErrorOptions {\n  /** Human readable error message. */\n  message?: string;\n}\n\n/**\n * A type that requires the given type `T` to have a `field` property.\n * @template T The type to add a `field` to.\n *\n * @experimental 21.0.0\n */\nexport type WithField<T> = T & {field: FieldTree<unknown>};\n\n/**\n * A type that allows the given type `T` to optionally have a `field` property.\n * @template T The type to optionally add a `field` to.\n *\n * @experimental 21.0.0\n */\nexport type WithOptionalField<T> = Omit<T, 'field'> & {field?: FieldTree<unknown>};\n\n/**\n * A type that ensures the given type `T` does not have a `field` property.\n * @template T The type to remove the `field` from.\n *\n * @experimental 21.0.0\n */\nexport type WithoutField<T> = T & {field: never};\n\n/**\n * Create a required error associated with the target field\n * @param options The validation error options\n *\n * @experimental 21.0.0\n */\nexport function requiredError(options: WithField<ValidationErrorOptions>): RequiredValidationError;\n/**\n * Create a required error\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function requiredError(\n  options?: ValidationErrorOptions,\n): WithoutField<RequiredValidationError>;\nexport function requiredError(\n  options?: ValidationErrorOptions,\n): WithOptionalField<RequiredValidationError> {\n  return new RequiredValidationError(options);\n}\n\n/**\n * Create a min value error associated with the target field\n * @param min The min value constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minError(\n  min: number,\n  options: WithField<ValidationErrorOptions>,\n): MinValidationError;\n/**\n * Create a min value error\n * @param min The min value constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minError(\n  min: number,\n  options?: ValidationErrorOptions,\n): WithoutField<MinValidationError>;\nexport function minError(\n  min: number,\n  options?: ValidationErrorOptions,\n): WithOptionalField<MinValidationError> {\n  return new MinValidationError(min, options);\n}\n\n/**\n * Create a max value error associated with the target field\n * @param max The max value constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxError(\n  max: number,\n  options: WithField<ValidationErrorOptions>,\n): MaxValidationError;\n/**\n * Create a max value error\n * @param max The max value constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxError(\n  max: number,\n  options?: ValidationErrorOptions,\n): WithoutField<MaxValidationError>;\nexport function maxError(\n  max: number,\n  options?: ValidationErrorOptions,\n): WithOptionalField<MaxValidationError> {\n  return new MaxValidationError(max, options);\n}\n\n/**\n * Create a minLength error associated with the target field\n * @param minLength The minLength constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minLengthError(\n  minLength: number,\n  options: WithField<ValidationErrorOptions>,\n): MinLengthValidationError;\n/**\n * Create a minLength error\n * @param minLength The minLength constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minLengthError(\n  minLength: number,\n  options?: ValidationErrorOptions,\n): WithoutField<MinLengthValidationError>;\nexport function minLengthError(\n  minLength: number,\n  options?: ValidationErrorOptions,\n): WithOptionalField<MinLengthValidationError> {\n  return new MinLengthValidationError(minLength, options);\n}\n\n/**\n * Create a maxLength error associated with the target field\n * @param maxLength The maxLength constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxLengthError(\n  maxLength: number,\n  options: WithField<ValidationErrorOptions>,\n): MaxLengthValidationError;\n/**\n * Create a maxLength error\n * @param maxLength The maxLength constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxLengthError(\n  maxLength: number,\n  options?: ValidationErrorOptions,\n): WithoutField<MaxLengthValidationError>;\nexport function maxLengthError(\n  maxLength: number,\n  options?: ValidationErrorOptions,\n): WithOptionalField<MaxLengthValidationError> {\n  return new MaxLengthValidationError(maxLength, options);\n}\n\n/**\n * Create a pattern matching error associated with the target field\n * @param pattern The violated pattern\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function patternError(\n  pattern: RegExp,\n  options: WithField<ValidationErrorOptions>,\n): PatternValidationError;\n/**\n * Create a pattern matching error\n * @param pattern The violated pattern\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function patternError(\n  pattern: RegExp,\n  options?: ValidationErrorOptions,\n): WithoutField<PatternValidationError>;\nexport function patternError(\n  pattern: RegExp,\n  options?: ValidationErrorOptions,\n): WithOptionalField<PatternValidationError> {\n  return new PatternValidationError(pattern, options);\n}\n\n/**\n * Create an email format error associated with the target field\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function emailError(options: WithField<ValidationErrorOptions>): EmailValidationError;\n/**\n * Create an email format error\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function emailError(options?: ValidationErrorOptions): WithoutField<EmailValidationError>;\nexport function emailError(\n  options?: ValidationErrorOptions,\n): WithOptionalField<EmailValidationError> {\n  return new EmailValidationError(options);\n}\n\n/**\n * Create a standard schema issue error associated with the target field\n * @param issue The standard schema issue\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function standardSchemaError(\n  issue: StandardSchemaV1.Issue,\n  options: WithField<ValidationErrorOptions>,\n): StandardSchemaValidationError;\n/**\n * Create a standard schema issue error\n * @param issue The standard schema issue\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function standardSchemaError(\n  issue: StandardSchemaV1.Issue,\n  options?: ValidationErrorOptions,\n): WithoutField<StandardSchemaValidationError>;\nexport function standardSchemaError(\n  issue: StandardSchemaV1.Issue,\n  options?: ValidationErrorOptions,\n): WithOptionalField<StandardSchemaValidationError> {\n  return new StandardSchemaValidationError(issue, options);\n}\n\n/**\n * Create a custom error associated with the target field\n * @param obj The object to create an error from\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function customError<E extends Partial<ValidationError>>(\n  obj: WithField<E>,\n): CustomValidationError;\n/**\n * Create a custom error\n * @param obj The object to create an error from\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function customError<E extends Partial<ValidationError>>(\n  obj?: E,\n): WithoutField<CustomValidationError>;\nexport function customError<E extends Partial<ValidationError>>(\n  obj?: E,\n): WithOptionalField<CustomValidationError> {\n  return new CustomValidationError(obj);\n}\n\n/**\n * Common interface for all validation errors.\n *\n * Use the creation functions to create an instance (e.g. `requiredError`, `minError`, etc.).\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport interface ValidationError {\n  /** Identifies the kind of error. */\n  readonly kind: string;\n  /** The field associated with this error. */\n  readonly field: FieldTree<unknown>;\n  /** Human readable error message. */\n  readonly message?: string;\n}\n\n/**\n * A custom error that may contain additional properties\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class CustomValidationError implements ValidationError {\n  /** Brand the class to avoid Typescript structural matching */\n  private __brand = undefined;\n\n  /**\n   * Allow the user to attach arbitrary other properties.\n   */\n  [key: PropertyKey]: unknown;\n\n  /** Identifies the kind of error. */\n  readonly kind: string = '';\n\n  /** The field associated with this error. */\n  readonly field!: FieldTree<unknown>;\n\n  /** Human readable error message. */\n  readonly message?: string;\n\n  constructor(options?: ValidationErrorOptions) {\n    if (options) {\n      Object.assign(this, options);\n    }\n  }\n}\n\n/**\n * Internal version of `NgValidationError`, we create this separately so we can change its type on\n * the exported version to a type union of the possible sub-classes.\n *\n * @experimental 21.0.0\n */\nabstract class _NgValidationError implements ValidationError {\n  /** Brand the class to avoid Typescript structural matching */\n  private __brand = undefined;\n\n  /** Identifies the kind of error. */\n  readonly kind: string = '';\n\n  /** The field associated with this error. */\n  readonly field!: FieldTree<unknown>;\n\n  /** Human readable error message. */\n  readonly message?: string;\n\n  constructor(options?: ValidationErrorOptions) {\n    if (options) {\n      Object.assign(this, options);\n    }\n  }\n}\n\n/**\n * An error used to indicate that a required field is empty.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class RequiredValidationError extends _NgValidationError {\n  override readonly kind = 'required';\n}\n\n/**\n * An error used to indicate that a value is lower than the minimum allowed.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MinValidationError extends _NgValidationError {\n  override readonly kind = 'min';\n\n  constructor(\n    readonly min: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is higher than the maximum allowed.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MaxValidationError extends _NgValidationError {\n  override readonly kind = 'max';\n\n  constructor(\n    readonly max: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is shorter than the minimum allowed length.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MinLengthValidationError extends _NgValidationError {\n  override readonly kind = 'minLength';\n\n  constructor(\n    readonly minLength: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is longer than the maximum allowed length.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MaxLengthValidationError extends _NgValidationError {\n  override readonly kind = 'maxLength';\n\n  constructor(\n    readonly maxLength: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value does not match the required pattern.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class PatternValidationError extends _NgValidationError {\n  override readonly kind = 'pattern';\n\n  constructor(\n    readonly pattern: RegExp,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is not a valid email.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class EmailValidationError extends _NgValidationError {\n  override readonly kind = 'email';\n}\n\n/**\n * An error used to indicate an issue validating against a standard schema.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class StandardSchemaValidationError extends _NgValidationError {\n  override readonly kind = 'standardSchema';\n\n  constructor(\n    readonly issue: StandardSchemaV1.Issue,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * The base class for all built-in, non-custom errors. This class can be used to check if an error\n * is one of the standard kinds, allowing you to switch on the kind to further narrow the type.\n *\n * @example\n * ```\n * const f = form(...);\n * for (const e of form().errors()) {\n *   if (e instanceof NgValidationError) {\n *     switch(e.kind) {\n *       case 'required':\n *         console.log('This is required!');\n *         break;\n *       case 'min':\n *         console.log(`Must be at least ${e.min}`);\n *         break;\n *       ...\n *     }\n *   }\n * }\n * ```\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const NgValidationError: abstract new () => NgValidationError = _NgValidationError as any;\nexport type NgValidationError =\n  | RequiredValidationError\n  | MinValidationError\n  | MaxValidationError\n  | MinLengthValidationError\n  | MaxLengthValidationError\n  | PatternValidationError\n  | EmailValidationError\n  | StandardSchemaValidationError;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {LogicFn, OneOrMany, PathKind, type FieldContext} from '../types';\nimport {ValidationError, WithoutField} from '../validation_errors';\n\n/** Represents a value that has a length or size, such as an array or string, or set. */\nexport type ValueWithLengthOrSize = {length: number} | {size: number};\n\n/** Common options available on the standard validators. */\nexport type BaseValidatorConfig<TValue, TPathKind extends PathKind = PathKind.Root> =\n  | {\n      /** A user-facing error message to include with the error. */\n      message?: string | LogicFn<TValue, string, TPathKind>;\n      error?: never;\n    }\n  | {\n      /**\n       * Custom validation error(s) to report instead of the default,\n       * or a function that receives the `FieldContext` and returns custom validation error(s).\n       */\n      error?:\n        | OneOrMany<WithoutField<ValidationError>>\n        | LogicFn<TValue, OneOrMany<WithoutField<ValidationError>>, TPathKind>;\n      message?: never;\n    };\n\n/** Gets the length or size of the given value. */\nexport function getLengthOrSize(value: ValueWithLengthOrSize) {\n  const v = value as {length: number; size: number};\n  return typeof v.length === 'number' ? v.length : v.size;\n}\n\n/**\n * Gets the value for an option that may be either a static value or a logic function that produces\n * the option value.\n *\n * @param opt The option from BaseValidatorConfig.\n * @param ctx The current FieldContext.\n * @returns The value for the option.\n */\nexport function getOption<TOption, TValue, TPathKind extends PathKind = PathKind.Root>(\n  opt: Exclude<TOption, Function> | LogicFn<TValue, TOption, TPathKind> | undefined,\n  ctx: FieldContext<TValue, TPathKind>,\n): TOption | undefined {\n  return opt instanceof Function ? opt(ctx) : opt;\n}\n\n/**\n * Checks if the given value is considered empty. Empty values are: null, undefined, '', false, NaN.\n */\nexport function isEmpty(value: unknown): boolean {\n  if (typeof value === 'number') {\n    return isNaN(value);\n  }\n  return value === '' || value === false || value == null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {validate} from '../logic';\nimport {FieldPath, PathKind} from '../types';\nimport {emailError} from '../validation_errors';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\n\n/**\n * A regular expression that matches valid e-mail addresses.\n *\n * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:\n * - `local-part` consists of one or more of the allowed characters (alphanumeric and some\n *   punctuation symbols).\n * - `local-part` cannot begin or end with a period (`.`).\n * - `local-part` cannot be longer than 64 characters.\n * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or\n *   `foo.com`.\n * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and\n *   periods (`.`)).\n * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).\n * - A `label` cannot be longer than 63 characters.\n * - The whole address cannot be longer than 254 characters.\n *\n * ## Implementation background\n *\n * This regexp was ported over from AngularJS (see there for git history):\n * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27\n * It is based on the\n * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n * lengths of different parts of the address). The main differences from the WHATWG version are:\n *   - Disallow `local-part` to begin or end with a period (`.`).\n *   - Disallow `local-part` length to exceed 64 characters.\n *   - Disallow total address length to exceed 254 characters.\n *\n * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.\n */\nconst EMAIL_REGEXP =\n  /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\n/**\n * Binds a validator to the given path that requires the value to match the standard email format.\n * This function can only be called on string paths.\n *\n * @param path Path of the field to validate\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.email()`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function email<TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<string, TPathKind>,\n  config?: BaseValidatorConfig<string, TPathKind>,\n) {\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    if (!EMAIL_REGEXP.test(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return emailError({message: getOption(config?.message, ctx)});\n      }\n    }\n\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {MAX} from '../metadata';\nimport {FieldPath, LogicFn, PathKind} from '../types';\nimport {maxError} from '../validation_errors';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\n\n/**\n * Binds a validator to the given path that requires the value to be less than or equal to the\n * given `maxValue`.\n * This function can only be called on number paths.\n * In addition to binding a validator, this function adds `MAX` property to the field.\n *\n * @param path Path of the field to validate\n * @param maxValue The maximum value, or a LogicFn that returns the maximum value.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.max(maxValue)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function max<TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<number, TPathKind>,\n  maxValue: number | LogicFn<number, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<number, TPathKind>,\n) {\n  const MAX_MEMO = metadata(path, (ctx) =>\n    computed(() => (typeof maxValue === 'number' ? maxValue : maxValue(ctx))),\n  );\n  aggregateMetadata(path, MAX, ({state}) => state.metadata(MAX_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const max = ctx.state.metadata(MAX_MEMO)!();\n    if (max === undefined || Number.isNaN(max)) {\n      return undefined;\n    }\n    if (ctx.value() > max) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return maxError(max, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {MAX_LENGTH} from '../metadata';\nimport {FieldPath, LogicFn, PathKind} from '../types';\nimport {maxLengthError} from '../validation_errors';\nimport {\n  BaseValidatorConfig,\n  getLengthOrSize,\n  getOption,\n  isEmpty,\n  ValueWithLengthOrSize,\n} from './util';\n\n/**\n * Binds a validator to the given path that requires the length of the value to be less than or\n * equal to the given `maxLength`.\n * This function can only be called on string or array paths.\n * In addition to binding a validator, this function adds `MAX_LENGTH` property to the field.\n *\n * @param path Path of the field to validate\n * @param maxLength The maximum length, or a LogicFn that returns the maximum length.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.maxLength(maxLength)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxLength<\n  TValue extends ValueWithLengthOrSize,\n  TPathKind extends PathKind = PathKind.Root,\n>(\n  path: FieldPath<TValue, TPathKind>,\n  maxLength: number | LogicFn<TValue, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<TValue, TPathKind>,\n) {\n  const MAX_LENGTH_MEMO = metadata(path, (ctx) =>\n    computed(() => (typeof maxLength === 'number' ? maxLength : maxLength(ctx))),\n  );\n  aggregateMetadata(path, MAX_LENGTH, ({state}) => state.metadata(MAX_LENGTH_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const maxLength = ctx.state.metadata(MAX_LENGTH_MEMO)!();\n    if (maxLength === undefined) {\n      return undefined;\n    }\n    if (getLengthOrSize(ctx.value()) > maxLength) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return maxLengthError(maxLength, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {MIN} from '../metadata';\nimport {FieldPath, LogicFn, PathKind} from '../types';\nimport {minError} from '../validation_errors';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\n\n/**\n * Binds a validator to the given path that requires the value to be greater than or equal to\n * the given `minValue`.\n * This function can only be called on number paths.\n * In addition to binding a validator, this function adds `MIN` property to the field.\n *\n * @param path Path of the field to validate\n * @param minValue The minimum value, or a LogicFn that returns the minimum value.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.min(minValue)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function min<TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<number, TPathKind>,\n  minValue: number | LogicFn<number, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<number, TPathKind>,\n) {\n  const MIN_MEMO = metadata(path, (ctx) =>\n    computed(() => (typeof minValue === 'number' ? minValue : minValue(ctx))),\n  );\n  aggregateMetadata(path, MIN, ({state}) => state.metadata(MIN_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const min = ctx.state.metadata(MIN_MEMO)!();\n    if (min === undefined || Number.isNaN(min)) {\n      return undefined;\n    }\n    if (ctx.value() < min) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return minError(min, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {MIN_LENGTH} from '../metadata';\nimport {FieldPath, LogicFn, PathKind} from '../types';\nimport {minLengthError} from '../validation_errors';\nimport {\n  BaseValidatorConfig,\n  getLengthOrSize,\n  getOption,\n  isEmpty,\n  ValueWithLengthOrSize,\n} from './util';\n\n/**\n * Binds a validator to the given path that requires the length of the value to be greater than or\n * equal to the given `minLength`.\n * This function can only be called on string or array paths.\n * In addition to binding a validator, this function adds `MIN_LENGTH` property to the field.\n *\n * @param path Path of the field to validate\n * @param minLength The minimum length, or a LogicFn that returns the minimum length.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.minLength(minLength)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minLength<\n  TValue extends ValueWithLengthOrSize,\n  TPathKind extends PathKind = PathKind.Root,\n>(\n  path: FieldPath<TValue, TPathKind>,\n  minLength: number | LogicFn<TValue, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<TValue, TPathKind>,\n) {\n  const MIN_LENGTH_MEMO = metadata(path, (ctx) =>\n    computed(() => (typeof minLength === 'number' ? minLength : minLength(ctx))),\n  );\n  aggregateMetadata(path, MIN_LENGTH, ({state}) => state.metadata(MIN_LENGTH_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const minLength = ctx.state.metadata(MIN_LENGTH_MEMO)!();\n    if (minLength === undefined) {\n      return undefined;\n    }\n    if (getLengthOrSize(ctx.value()) < minLength) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return minLengthError(minLength, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {PATTERN} from '../metadata';\nimport {FieldPath, LogicFn, PathKind} from '../types';\nimport {patternError} from '../validation_errors';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\n\n/**\n * Binds a validator to the given path that requires the value to match a specific regex pattern.\n * This function can only be called on string paths.\n * In addition to binding a validator, this function adds `PATTERN` property to the field.\n *\n * @param path Path of the field to validate\n * @param pattern The RegExp pattern to match, or a LogicFn that returns the RegExp pattern.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.pattern(pattern)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function pattern<TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<string, TPathKind>,\n  pattern: RegExp | LogicFn<string | undefined, RegExp | undefined, TPathKind>,\n  config?: BaseValidatorConfig<string, TPathKind>,\n) {\n  const PATTERN_MEMO = metadata(path, (ctx) =>\n    computed(() => (pattern instanceof RegExp ? pattern : pattern(ctx))),\n  );\n  aggregateMetadata(path, PATTERN, ({state}) => state.metadata(PATTERN_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const pattern = ctx.state.metadata(PATTERN_MEMO)!();\n    if (pattern === undefined) {\n      return undefined;\n    }\n    if (!pattern.test(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return patternError(pattern, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {REQUIRED} from '../metadata';\nimport {FieldPath, LogicFn, PathKind} from '../types';\nimport {requiredError} from '../validation_errors';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\n\n/**\n * Binds a validator to the given path that requires the value to be non-empty.\n * This function can only be called on any type of path.\n * In addition to binding a validator, this function adds `REQUIRED` property to the field.\n *\n * @param path Path of the field to validate\n * @param config Optional, allows providing any of the following options:\n *  - `message`: A user-facing message for the error.\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.required()`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n *  - `when`: A function that receives the `FieldContext` and returns true if the field is required\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function required<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: FieldPath<TValue, TPathKind>,\n  config?: BaseValidatorConfig<TValue, TPathKind> & {\n    when?: NoInfer<LogicFn<TValue, boolean, TPathKind>>;\n  },\n): void {\n  const REQUIRED_MEMO = metadata(path, (ctx) =>\n    computed(() => (config?.when ? config.when(ctx) : true)),\n  );\n  aggregateMetadata(path, REQUIRED, ({state}) => state.metadata(REQUIRED_MEMO)!());\n  validate(path, (ctx) => {\n    if (ctx.state.metadata(REQUIRED_MEMO)!() && isEmpty(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return requiredError({message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, resource, ÉµisPromise} from '@angular/core';\nimport type {StandardSchemaV1} from '@standard-schema/spec';\nimport {addDefaultField} from '../../field/validation';\nimport {validateAsync} from '../async';\nimport {metadata, validateTree} from '../logic';\nimport {FieldPath, FieldTree} from '../types';\nimport {standardSchemaError, StandardSchemaValidationError} from '../validation_errors';\n\n/**\n * Utility type that removes a string index key when its value is `unknown`,\n * i.e. `{[key: string]: unknown}`. It allows specific string keys to pass through, even if their\n * value is `unknown`, e.g. `{key: unknown}`.\n *\n * @experimental 21.0.0\n */\nexport type RemoveStringIndexUnknownKey<K, V> = string extends K\n  ? unknown extends V\n    ? never\n    : K\n  : K;\n\n/**\n * Utility type that recursively ignores unknown string index properties on the given object.\n * We use this on the `TSchema` type in `validateStandardSchema` in order to accommodate Zod's\n * `looseObject` which includes `{[key: string]: unknown}` as part of the type.\n *\n * @experimental 21.0.0\n */\nexport type IgnoreUnknownProperties<T> =\n  T extends Record<PropertyKey, unknown>\n    ? {\n        [K in keyof T as RemoveStringIndexUnknownKey<K, T[K]>]: IgnoreUnknownProperties<T[K]>;\n      }\n    : T;\n\n/**\n * Validates a field using a `StandardSchemaV1` compatible validator (e.g. a Zod validator).\n *\n * See https://github.com/standard-schema/standard-schema for more about standard schema.\n *\n * @param path The `FieldPath` to the field to validate.\n * @param schema The standard schema compatible validator to use for validation.\n * @template TSchema The type validated by the schema. This may be either the full `TValue` type,\n *   or a partial of it.\n * @template TValue The type of value stored in the field being validated.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function validateStandardSchema<TSchema, TValue extends IgnoreUnknownProperties<TSchema>>(\n  path: FieldPath<TValue>,\n  schema: StandardSchemaV1<TSchema>,\n) {\n  // We create both a sync and async validator because the standard schema validator can return\n  // either a sync result or a Promise, and we need to handle both cases. The sync validator\n  // handles the sync result, and the async validator handles the Promise.\n  // We memoize the result of the validation function here, so that it is only run once for both\n  // validators, it can then be passed through both sync & async validation.\n  const VALIDATOR_MEMO = metadata(path, ({value}) => {\n    return computed(() => schema['~standard'].validate(value()));\n  });\n  validateTree(path, ({state, fieldOf}) => {\n    // Skip sync validation if the result is a Promise.\n    const result = state.metadata(VALIDATOR_MEMO)!();\n    if (ÉµisPromise(result)) {\n      return [];\n    }\n    return result.issues?.map((issue) => standardIssueToFormTreeError(fieldOf(path), issue)) ?? [];\n  });\n  validateAsync(path, {\n    params: ({state}) => {\n      // Skip async validation if the result is *not* a Promise.\n      const result = state.metadata(VALIDATOR_MEMO)!();\n      return ÉµisPromise(result) ? result : undefined;\n    },\n    factory: (params) => {\n      return resource({\n        params,\n        loader: async ({params}) => (await params)?.issues ?? [],\n      });\n    },\n    errors: (issues, {fieldOf}) => {\n      return issues.map((issue) => standardIssueToFormTreeError(fieldOf(path), issue));\n    },\n  });\n}\n\n/**\n * Converts a `StandardSchemaV1.Issue` to a `FormTreeError`.\n *\n * @param field The root field to which the issue's path is relative.\n * @param issue The `StandardSchemaV1.Issue` to convert.\n * @returns A `ValidationError` representing the issue.\n */\nfunction standardIssueToFormTreeError(\n  field: FieldTree<unknown>,\n  issue: StandardSchemaV1.Issue,\n): StandardSchemaValidationError {\n  let target = field as FieldTree<Record<PropertyKey, unknown>>;\n  for (const pathPart of issue.path ?? []) {\n    const pathKey = typeof pathPart === 'object' ? pathPart.key : pathPart;\n    target = target[pathKey] as FieldTree<Record<PropertyKey, unknown>>;\n  }\n  return addDefaultField(standardSchemaError(issue), target);\n}\n"],"names":["ÉµCONTROL","ÉµisPromise"],"mappings":"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"}
{"version":3,"file":"control_value_accessor.js","sourceRoot":"","sources":["../../../../../../packages/forms/src/directives/control_value_accessor.ts"],"names":[],"mappings":";;;;;;;;;;;AAQA,OAAO,EAAC,cAAc,EAAC,MAAM,eAAe,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6G7C,MAAM,CAAC,qBAAM,iBAAiB,GAAG,IAAI,cAAc,CAAuB,iBAAiB,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * A `ControlValueAccessor` acts as a bridge between the Angular forms API and a\n * native element in the DOM.\n *\n * Implement this interface if you want to create a custom form control directive\n * that integrates with Angular forms.\n *\n *\n */\nexport interface ControlValueAccessor {\n  /**\n   * Writes a new value to the element.\n   *\n   * This method will be called by the forms API to write to the view when programmatic\n   * (model -> view) changes are requested.\n   *\n   * Example implementation of `writeValue`:\n   *\n   * ```ts\n   * writeValue(value: any): void {\n   *   this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);\n   * }\n   * ```\n   */\n  writeValue(obj: any): void;\n\n  /**\n   * Registers a callback function that should be called when the control's value\n   * changes in the UI.\n   *\n   * This is called by the forms API on initialization so it can update the form\n   * model when values propagate from the view (view -> model).\n   *\n   * If you are implementing `registerOnChange` in your own value accessor, you\n   * will typically want to save the given function so your class can call it\n   * at the appropriate time.\n   *\n   * ```ts\n   * registerOnChange(fn: (_: any) => void): void {\n   *   this._onChange = fn;\n   * }\n   * ```\n   *\n   * When the value changes in the UI, your class should call the registered\n   * function to allow the forms API to update itself:\n   *\n   * ```ts\n   * host: {\n   *    (change): '_onChange($event.target.value)'\n   * }\n   * ```\n   *\n   */\n  registerOnChange(fn: any): void;\n\n  /**\n   * Registers a callback function that should be called when the control receives\n   * a blur event.\n   *\n   * This is called by the forms API on initialization so it can update the form model\n   * on blur.\n   *\n   * If you are implementing `registerOnTouched` in your own value accessor, you\n   * will typically want to save the given function so your class can call it\n   * when the control should be considered blurred (a.k.a. \"touched\").\n   *\n   * ```ts\n   * registerOnTouched(fn: any): void {\n   *   this._onTouched = fn;\n   * }\n   * ```\n   *\n   * On blur (or equivalent), your class should call the registered function to allow\n   * the forms API to update itself:\n   *\n   * ```ts\n   * host: {\n   *    '(blur)': '_onTouched()'\n   * }\n   * ```\n   */\n  registerOnTouched(fn: any): void;\n\n  /**\n   * This function is called by the forms API when the control status changes to\n   * or from \"DISABLED\". Depending on the value, it should enable or disable the\n   * appropriate DOM element.\n   *\n   * Example implementation of `setDisabledState`:\n   *\n   * ```ts\n   * setDisabledState(isDisabled: boolean): void {\n   *   this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n   * }\n   * ```\n   *\n   * @param isDisabled\n   */\n  setDisabledState?(isDisabled: boolean): void;\n}\n\n/**\n * Used to provide a `ControlValueAccessor` for form controls.\n *\n * See `DefaultValueAccessor` for how to implement one.\n *\n */\nexport const NG_VALUE_ACCESSOR = new InjectionToken<ControlValueAccessor>('NgValueAccessor');\n"]}